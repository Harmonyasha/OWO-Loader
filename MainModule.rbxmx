<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXF136849F9B3E4D37952CD90A374AFCE7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">MainModule</string>
			<string name="ScriptGuid">{7CF707B9-0B46-4883-BA20-95DAD0B147C9}</string>
			<ProtectedString name="Source"><![CDATA[local function reverse(t) local reversedTable = {} local itemCount = #t for k, v in t do reversedTable[itemCount + 1 - k] = v end return reversedTable end
local luauvariables = {} luauvariables["nil"] = nil luauvariables["false"] = false luauvariables["true"] = true
local ignoreerrors = {"is not a valid member of"}
local function tabletonumber(tab)  for i,v in tab do if tonumber(v) then v = tonumber(v) end tab[i] = v end return tab end
local function checkignore(text) local ret = false for i,v in ignoreerrors do if string.find(text,v) then ret = true break end return ret end end
function randomstring(Length) local Text = "" for i = 1, Length or math.random(5,15) do	Text = Text..utf8.char(math.random(44032,55291)) end return Text end
local collection = {error = error,warn = warn,print = print}
local ignoreparameters = {"ModelMeshData","Capabilities","SourceAssetId","Tags","DefinesCapabilities","AttributesSerialize","Velocity","MaterialVariantSerialized","FormFactorRaw","CustomPhysicalProperties","Source","ScriptGuid","PlaybackRegion","LoopRegion"}
local ignoreClassName = {"ParticleEmitter","Model"}
local function checkonplayers(obj) local ret = nil for i,v in game:GetService("Players"):GetPlayers() do	if obj:IsDescendantOf(v) then ret = v break end end return ret end
local notsupportedobjects = {"ParticleEmitter"}
local error = function(...) task.defer(collection["error"],...) end
collection["error2"] = error
local scripts = {script = {"Script","ModuleScript"},localscript = {"LocalScript"}}
local url = "http://localhost:5699/scripts"
local waitforlocalscripts = false
local firstrun = true
local rem = nil
local remember_localsource = {}
local remconnects = {}

local interop = {}
for i,v in script.interop:children() do
	interop[v.Name] = require(v)
end

local apidump = interop.ApiDump()

local scriptrunner = require(script.core.ScriptRunner)
function clients() 
	local memory = {}
	return setmetatable({},{__newindex = function(self,index,newindex)
		memory[index] = newindex
	end,
	__index = function(self,index)
		return memory[index]
	end,
	})
end

local clients = clients()
function setuprem()
	for i,v:RBXScriptConnection in remconnects do 
		v:Disconnect()
	end
	pcall(game.Destroy,rem)

	rem = Instance.new("RemoteFunction",game:GetService("VoiceChatService"))
	rem.Name = "OWOLOADER"	
	scriptrunner:NFL_setremote(rem)


	table.insert(remconnects,rem:GetPropertyChangedSignal("Parent"):Connect(function()
		if rem.Parent ~= game:GetService("VoiceChatService") then
			setuprem()
		end
	end))

	table.insert(remconnects,rem:GetPropertyChangedSignal("Name"):Connect(function()
		setuprem()
	end))

end
local ENV = {
	["script"] = nil
}
local csharp = require(script.modules["C# module"])



local p = newproxy(true)
getmetatable(p).__call=function(_,id,scriptname,password,user,debugg,source)
	if firstrun then

		for i,v in script.core:children() do 
			local req = require(v)
			local functions = {}
			for i,v in req do 
				if not csharp.StartWith(i,"NFL_") then
					functions[i] = v
				end
			end
			ENV[v.Name] = functions
		end
		for i,plr in game:GetService("Players"):GetPlayers() do 
			clients[plr] = "Loading"
			script.LocalScript:Clone().Parent = plr:WaitForChild("PlayerGui")
		end

		game:GetService("Players").PlayerAdded:Connect(function(plr)
			clients[plr] = "Loading"
			script.LocalScript:Clone().Parent = plr:WaitForChild("PlayerGui")
		end)

		game:GetService("Players").PlayerRemoving:Connect(function(plr)
			clients[plr] = nil
		end)

		firstrun = false
		setuprem()

		game:GetService("RunService").Heartbeat:Connect(function()
			rem.OnServerInvoke = function(plr,_1)
				if _1[0] == "get" then

				end

			end
		end)

		coroutine.resume(coroutine.create(function()
			while wait(.2) do 
				pcall(setuprem)
			end
		end))
	end

	if (typeof(source) == "string" or typeof(source) == "table") and debugg then
		scriptrunner:Server(ENV,source)
		return
	end

	local content = game:GetService("HttpService"):JSONEncode{get={id,scriptname,password,unpack(user)}}

	local post =game:GetService("HttpService"):PostAsync(url,content, Enum.HttpContentType.ApplicationJson,false)

	post = game:GetService("HttpService"):JSONDecode(post)
	if typeof(post) == "string" then
		warn(post)
		return
	end


	local postcount = 0 
	local firstparented = nil
	for i,v in post do postcount += 1 end
	print = collection["print"]
	warn = collection["warn"] 
	error = collection["error2"]

	if postcount > 20000 then
		error(`Any Outputs will be automaticly disabled for crash prevention because of a large number of objects {postcount} after loading all output's come back`)
		print = function() end
		warn = function() end
		error = function() end
	elseif not debugg then
		error(`Debug is turning off`)
		print = function() end
		warn = function() end
		error = function() end
	end
	local tempfolder = Instance.new("Folder",script)
	tempfolder.Name = randomstring(50)
	local tempscripts = {}
	local templocalscripts = {}
	local templocalmodules = {}
	local created = {OWOLOADER = tempfolder}
	local notdonethings = {welds = {}}
	for i,v in reverse(post.parents) do
		local object = nil
		v = string.split(v," parent of ")

		if post[v[1]]["propertytype"] == "MeshPart" then post[v[1]]["propertytype"] = "Part" end


		if table.find(scripts["script"],post[v[1]]["propertytype"]) then
			created[v[1]] = Instance.new(post[v[1]]["propertytype"],created[v[2]])--fakescript:Clone()
			object = created[v[1]]
			object.Parent = created[v[2]]
			object:SetAttribute("id",v[1])
			object:SetAttribute("property",post[v[1]]["propertytype"])
		elseif table.find(scripts["localscript"],post[v[1]]["propertytype"]) then
			created[v[1]] = Instance.new(post[v[1]]["propertytype"],created[v[2]])
			object = created[v[1]]
			object:SetAttribute("id",v[1])
			object:SetAttribute("property",post[v[1]]["propertytype"])
		else
			created[v[1]] = Instance.new(post[v[1]]["propertytype"],created[v[2]])
			object = created[v[1]]
		end

		if firstparented == nil then
			firstparented  = created[v[1]]
		end

		post[v[1]]["propertytype"] = nil

		for parameter,set in post[v[1]] do 
			parameter = string.upper(string.sub(parameter,1,1))..string.sub(parameter,2,#parameter)
			if set == "null" then set = nil end
			if set == "nil" or luauvariables[set] then set =  luauvariables[set] end

			parameter,set = interop.ParametersConvert(parameter,set)
			set = tonumber(set) or set

			if parameter == "MeshId" then local mesh = Instance.new("SpecialMesh",object) mesh.MeshId = set end
			if parameter == "TextureID" then local texture = Instance.new("Texture",object) texture.Texture = set end
			if parameter == "LinkedSource" then continue end

			if parameter == "Part1" or parameter == "Part0" then if notdonethings["welds"][i] == nil then notdonethings["welds"][i] = {} end notdonethings["welds"][i][parameter] = {} notdonethings["welds"][i][parameter] = {object,set} end

			--print(object:GetAttribute("property"),parameter,set)

			if parameter == "Source" and table.find(scripts["script"],object:GetAttribute("property"))  then 
				tempscripts[object] = set	
			elseif parameter == "Source" and table.find(scripts["localscript"],object:GetAttribute("property")) then
				interop.LocalStorage:Import(object:GetAttribute("id"),set,"localscript")
				templocalscripts[object] = set
			end


			local successed, returnedData = pcall(function()

				object[parameter] = set 
			end)
			if successed then
				--print(object.ClassName,parameter,typeof(set),set)
			elseif not table.find(ignoreparameters,parameter) and not table.find(ignoreClassName,object.ClassName) then	
				warn(object.ClassName,parameter,typeof(set),"::>",set)
			end
			if returnedData and checkignore(returnedData) then
				--	print(returnedData)
			end

		end

	end




	for object:Script,set in tempscripts do 
		if table.find(scripts["script"],object:GetAttribute("property")) and object:GetAttribute("property") ~= "ModuleScript" and object ~= firstparented then
			require(script.modules["ServerScript Emulator"]:Clone())(object,set,object:GetAttribute("id"),object:GetAttribute("property"),ENV)
		end
	end
	for object:Script,set in templocalscripts do 
		for i,v in object:GetDescendants() do 
			if v:IsA("ModuleScript") then
				templocalmodules[v] = tempscripts[v]
				interop.LocalStorage:Import(object:GetAttribute("id"),set,"modulescript")
			end
		end
	end

	if firstparented:IsA("ModuleScript") then
		local fake = script.modules["ServerScript Emulator"]:Clone()
		require(fake)(firstparented,tempscripts[firstparented],firstparented:GetAttribute("id"),firstparented:GetAttribute("property"),ENV)
		return require(fake)()(unpack(user))
	else
		return firstparented
	end



end
getmetatable(p).__metatable={}

return p ]]></ProtectedString>
			<int64 name="SourceAssetId">15521788629</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="LocalScript" referent="RBX9B25CD6A98D74C6EA4BD6234FCAFF48B">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LocalScript</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{21C57715-CAC9-408D-9EEE-1342569D48E6}</string>
				<ProtectedString name="Source"><![CDATA[task.wait()
script.Parent = nil

local compiler = script.local_compiler
compiler.Parent = nil
local plr = game:GetService("Players").LocalPlayer
local objectalreadyrunning = {}
local tempconnectwhilenotnill = {}
local remember_localsource = {}
local function searchIn(collection, searchFor, multiple)
	multiple = multiple or 2
	local founded = 0
	for _, item in collection do
		if item.Name == searchFor then
			founded += 1
			if founded >= multiple then
				return true
			end
		end
	end
	return false
end
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://5153737200"
sound.PlayOnRemove = true
sound.Volume = 2
sound.Parent = game:GetService("SoundService")
pcall(workspace.Destroy,sound)
local rem	
repeat task.wait()
	warn("wait for remote")
	rem = game:GetService("VoiceChatService"):FindFirstChild("OWOLOADER")
until rem ~= nil

local function checkifcanrun(objecttocheck:LocalScript)
	
	if objecttocheck.Disabled == false and objecttocheck:IsDescendantOf(game:GetService("Players").LocalPlayer) and not table.find(objectalreadyrunning,objecttocheck) then
		warn(table.find(objectalreadyrunning,objecttocheck),objecttocheck.Parent)
		table.insert(objectalreadyrunning,objecttocheck)
		local id = objecttocheck:GetAttribute("id")
		--warn("RUN LOCAL	",id,objecttocheck.Parent)
		task.delay(.1,function()
			for i,v:RBXScriptConnection in tempconnectwhilenotnill[objecttocheck] do v:Disconnect() end
			tempconnectwhilenotnill[objecttocheck] = nil
		end)
		--print("args2",remember_localsource[objecttocheck:GetAttribute("id")])
		print(objecttocheck:GetAttribute("id"))
		print("run")
		local s,err1
		s,err = pcall(function()
			remember_localsource[objecttocheck:GetAttribute("id")]({script = objecttocheck})
		end)
		if not s then
			warn("script error ",err)
		end
		
	end	
	
end

plr.DescendantAdded:Connect(function(object)
	--print(object:IsA("LocalScript"),remember_localsource[object:GetAttribute("id")] ~= nil)
	--print(remember_localsource,object:GetAttribute("id"),object.Name)
	if object:IsA("LocalScript") and remember_localsource[object:GetAttribute("id")] ~= nil then
		local id = object:GetAttribute("id")
		tempconnectwhilenotnill[object] = {}
		checkifcanrun(object)
		
		table.insert(tempconnectwhilenotnill[object],object:GetPropertyChangedSignal("Parent"):Connect(function()
			checkifcanrun(object)
		end))

		table.insert(tempconnectwhilenotnill[object],object:GetPropertyChangedSignal("Disabled"):Connect(function()
			checkifcanrun(object)
		end))
		
	end 
end)




local function remsetup()
	if rem == nil then return end
	rem.OnClientInvoke = (function(args)
		
	
		
		end)
end


spawn(function()
	while task.wait() do
		
		if searchIn(game:GetService("VoiceChatService"):GetChildren(),"OWOLOADER") then
			for i,v in game:GetService("VoiceChatService"):GetChildren() do 
				if v.Name == "OWOLOADER" then
					pcall(game.Destroy,v)
				end
			end
		end
		
		rem = game:GetService("VoiceChatService"):FindFirstChild("OWOLOADER")
		remsetup()
	end
end)

rem:InvokeServer("Get status")]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX501751DF3D83490F9F821D8FDEFE105F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalHandler</string>
					<string name="ScriptGuid">{0CC0EA79-FF0B-4B33-A747-01A86FE92A41}</string>
					<ProtectedString name="Source"><![CDATA[local plr = game:GetService("Players").LocalPlayer
local source = {}

local module = {}
return function ()
	plr.DescendantAdded:Connect(function(v)
		if v:IsA("LocalScript") or v:IsA("ModuleScript") then
			
		end
	end)
	
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX7484CD350D2E47C1B4CDD9186EB05B49">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">LocalScript Emulator</string>
						<string name="ScriptGuid">{3B2D8B77-58AA-4480-9A23-2979C87D79A7}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local function checkifcanrun(objecttocheck:LocalScript)

		if objecttocheck.Disabled == false and objecttocheck:IsDescendantOf(game:GetService("Players").LocalPlayer) and not table.find(objectalreadyrunning,objecttocheck) then
			warn(table.find(objectalreadyrunning,objecttocheck),objecttocheck.Parent)
			table.insert(objectalreadyrunning,objecttocheck)
			local id = objecttocheck:GetAttribute("id")
			--warn("RUN LOCAL	",id,objecttocheck.Parent)
			task.delay(.1,function()
				for i,v:RBXScriptConnection in tempconnectwhilenotnill[objecttocheck] do v:Disconnect() end
				tempconnectwhilenotnill[objecttocheck] = nil
			end)
			--print("args2",remember_localsource[objecttocheck:GetAttribute("id")])
			print(objecttocheck:GetAttribute("id"))
			print("run")
			local s,err1
			s,err = pcall(function()
				remember_localsource[objecttocheck:GetAttribute("id")]({script = objecttocheck})
			end)
			if not s then
				warn("script error ",err)
			end

		end	

	end

	plr.DescendantAdded:Connect(function(object)
		--print(object:IsA("LocalScript"),remember_localsource[object:GetAttribute("id")] ~= nil)
		--print(remember_localsource,object:GetAttribute("id"),object.Name)
		if object:IsA("LocalScript") and remember_localsource[object:GetAttribute("id")] ~= nil then
			local id = object:GetAttribute("id")
			tempconnectwhilenotnill[object] = {}
			checkifcanrun(object)

			table.insert(tempconnectwhilenotnill[object],object:GetPropertyChangedSignal("Parent"):Connect(function()
				checkifcanrun(object)
			end))

			table.insert(tempconnectwhilenotnill[object],object:GetPropertyChangedSignal("Disabled"):Connect(function()
				checkifcanrun(object)
			end))

		end 
	end)
	
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB311826862554E6094778BD63A5C65E9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">local_compiler</string>
							<string name="ScriptGuid">{2448724A-795E-40DD-9FC9-38CCA1F38B19}</string>
							<ProtectedString name="Source"><![CDATA[local moduleload = false
local zerogetfenv = nil
local function compile(sfenv,source, additionalEnv, ...)
	if moduleload then
		for i,v in sfenv do 
			getfenv(2)[i] = v
		end
	end
	
	local compiled = loadstring(source)
	
	if compiled == nil then
		warn("source is none or source got error")
		local s,err = pcall(function()
			loadstring(source)()
		end)
		warn(err)
		--warn(source)
		return nil
	end
	if not moduleload then
	local fenv = getfenv(compiled)
	for i,v in sfenv do 
		fenv[i] = v
	end

	local j=  setmetatable(additionalEnv or {}, {
		__index = function(_, index)
			return fenv[index]
		end
	})
	setfenv(compiled, j)
	end
	
	return compiled
end

return function(fenv,scriptt,scripttype)
	warn("local compiler")
	if not pcall(loadstring, "--") then
		warn("Loadstring set on custom")
		getfenv().loadstring = require(script.b)
		moduleload = true
	end
	if zerogetfenv ~= nil then
		for i,v in getfenv(2) do 
			getfenv(2)[i] = nil
		end
		
		for i,v in zerogetfenv do 
			getfenv(2)[i] = v
		end
		
	end
	zerogetfenv = getfenv(2)

	local sandbox

	if typeof(scriptt) == "table" then
		sandbox = compile(fenv,table.concat(scriptt,"\n"))
	else
		sandbox = compile(fenv,scriptt)
	end

	return sandbox
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX5F45F9B2E468433E8E67683093368BFC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">b</string>
								<string name="ScriptGuid">{4BFCE636-B115-4FA9-ADDF-D22ECEB21D9F}</string>
								<ProtectedString name="Source"><![CDATA[local compile
do
	local name
	local luaZ = {}
	local luaY = {}
	local luaX = {}
	local luaP = {}
	local luaU = {}
	local luaK = {}
	local size_size_t = 8
	local function lua_assert(test)
		if not test then
			error("assertion failed!")
		end
	end
	function luaZ:make_getS(buff)
		local b = buff
		return function()
			if not b then
				return nil
			end
			local data = b
			b = nil
			return data
		end
	end
	function luaZ:make_getF(source)
		local LUAL_BUFFERSIZE = 512
		local pos = 1
		return function()
			local buff = source:sub(pos, pos + LUAL_BUFFERSIZE - 1)
			pos = math.min(#source + 1, pos + LUAL_BUFFERSIZE)
			return buff
		end
	end
	function luaZ:init(reader, data)
		if not reader then
			return
		end
		local z = {}
		z.reader = reader
		z.data = data or ""
		z.name = name
		if not data or data == "" then
			z.n = 0
		else
			z.n = #data
		end
		z.p = 0
		return z
	end
	function luaZ:fill(z)
		local buff = z.reader()
		z.data = buff
		if not buff or buff == "" then
			return "EOZ"
		end
		z.n, z.p = #buff - 1, 1
		return string.sub(buff, 1, 1)
	end
	function luaZ:zgetc(z)
		local n, p = z.n, z.p + 1
		if n > 0 then
			z.n, z.p = n - 1, p
			return string.sub(z.data, p, p)
		else
			return self:fill(z)
		end
	end
	luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]
	luaX.MAXSRC = 80
	luaX.MAX_INT = 2147483645
	luaX.LUA_QS = "'%s'"
	luaX.LUA_COMPAT_LSTR = 1
	function luaX:init()
		local tokens, enums = {}, {}
		for v in string.gmatch(self.RESERVED, "[^\n]+") do
			local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)")
			tokens[tok] = str
			enums[str] = tok
		end
		self.tokens = tokens
		self.enums = enums
	end
	function luaX:chunkid(source, bufflen)
		local out
		local first = string.sub(source, 1, 1)
		if first == "=" then
			out = string.sub(source, 2, bufflen)
		else
			if first == "@" then
				source = string.sub(source, 2)
				bufflen = bufflen - #" '...' "
				local l = #source
				out = ""
				if l > bufflen then
					source = string.sub(source, 1 + l - bufflen)
					out = out .. "..."
				end
				out = out .. source
			else
				local len = string.find(source, "[\n\r]")
				len = len and (len - 1) or #source
				bufflen = bufflen - #' [string "..."] '
				if len > bufflen then
					len = bufflen
				end
				out = '[string "'
				if len < #source then
					out = out .. string.sub(source, 1, len) .. "..."
				else
					out = out .. source
				end
				out = out .. '"]'
			end
		end
		return out
	end
	function luaX:token2str(_, token)
		if string.sub(token, 1, 3) ~= "TK_" then
			if string.find(token, "%c") then
				return string.format("char(%d)", string.byte(token))
			end
			return token
		else
			return self.tokens[token]
		end
	end
	function luaX:lexerror(ls, msg, token)
		local function txtToken(ls, token)
			if token == "TK_NAME" or token == "TK_STRING" or token == "TK_NUMBER" then
				return ls.buff
			else
				return self:token2str(ls, token)
			end
		end
		local buff = self:chunkid(ls.source, self.MAXSRC)
		local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg)
		if token then
			msg = string.format("%s near " .. self.LUA_QS, msg, txtToken(ls, token))
		end
		error(msg)
	end
	function luaX:syntaxerror(ls, msg)
		self:lexerror(ls, msg, ls.t.token)
	end
	function luaX:currIsNewline(ls)
		return ls.current == "\n" or ls.current == "\r"
	end
	function luaX:inclinenumber(ls)
		local old = ls.current
		self:nextc(ls)
		if self:currIsNewline(ls) and ls.current ~= old then
			self:nextc(ls)
		end
		ls.linenumber = ls.linenumber + 1
		if ls.linenumber >= self.MAX_INT then
			self:syntaxerror(ls, "chunk has too many lines")
		end
	end
	function luaX:setinput(L, ls, z, source)
		if not ls then
			ls = {}
		end
		if not ls.lookahead then
			ls.lookahead = {}
		end
		if not ls.t then
			ls.t = {}
		end
		ls.decpoint = "."
		ls.L = L
		ls.lookahead.token = "TK_EOS"
		ls.z = z
		ls.fs = nil
		ls.linenumber = 1
		ls.lastline = 1
		ls.source = source
		self:nextc(ls)
	end
	function luaX:check_next(ls, set)
		if not string.find(set, ls.current, 1, 1) then
			return false
		end
		self:save_and_next(ls)
		return true
	end
	function luaX:next(ls)
		ls.lastline = ls.linenumber
		if ls.lookahead.token ~= "TK_EOS" then
			ls.t.seminfo = ls.lookahead.seminfo
			ls.t.token = ls.lookahead.token
			ls.lookahead.token = "TK_EOS"
		else
			ls.t.token = self:llex(ls, ls.t)
		end
	end
	function luaX:lookahead(ls)
		ls.lookahead.token = self:llex(ls, ls.lookahead)
	end
	function luaX:nextc(ls)
		local c = luaZ:zgetc(ls.z)
		ls.current = c
		return c
	end
	function luaX:save(ls, c)
		local buff = ls.buff
		ls.buff = buff .. c
	end
	function luaX:save_and_next(ls)
		self:save(ls, ls.current)
		return self:nextc(ls)
	end
	function luaX:str2d(s)
		local result = tonumber(s)
		if result then
			return result
		end
		if string.lower(string.sub(s, 1, 2)) == "0x" then
			result = tonumber(s, 16)
			if result then
				return result
			end
		end
		return nil
	end
	function luaX:buffreplace(ls, from, to)
		local result, buff = "", ls.buff
		for p = 1, #buff do
			local c = string.sub(buff, p, p)
			if c == from then
				c = to
			end
			result = result .. c
		end
		ls.buff = result
	end
	function luaX:trydecpoint(ls, Token)
		local old = ls.decpoint
		self:buffreplace(ls, old, ls.decpoint)
		local seminfo = self:str2d(ls.buff)
		Token.seminfo = seminfo
		if not seminfo then
			self:buffreplace(ls, ls.decpoint, ".")
			self:lexerror(ls, "malformed number", "TK_NUMBER")
		end
	end
	function luaX:read_numeral(ls, Token)
		repeat
			self:save_and_next(ls)
		until string.find(ls.current, "%D") and ls.current ~= "."
		if self:check_next(ls, "Ee") then
			self:check_next(ls, "+-")
		end
		while string.find(ls.current, "^%w$") or ls.current == "_" do
			self:save_and_next(ls)
		end
		self:buffreplace(ls, ".", ls.decpoint)
		local seminfo = self:str2d(ls.buff)
		Token.seminfo = seminfo
		if not seminfo then
			self:trydecpoint(ls, Token)
		end
	end
	function luaX:skip_sep(ls)
		local count = 0
		local s = ls.current
		self:save_and_next(ls)
		while ls.current == "=" do
			self:save_and_next(ls)
			count = count + 1
		end
		return (ls.current == s) and count or -count - 1
	end
	function luaX:read_long_string(ls, Token, sep)
		local cont = 0
		self:save_and_next(ls)
		if self:currIsNewline(ls) then
			self:inclinenumber(ls)
		end
		while true do
			local c = ls.current
			if c == "EOZ" then
				self:lexerror(ls, Token and "unfinished long string" or "unfinished long comment", "TK_EOS")
			elseif c == "[" then
				if self.LUA_COMPAT_LSTR then
					if self:skip_sep(ls) == sep then
						self:save_and_next(ls)
						cont = cont + 1
						if self.LUA_COMPAT_LSTR == 1 then
							if sep == 0 then
								self:lexerror(ls, "nesting of [[...]] is deprecated", "[")
							end
						end
					end
				end
			elseif c == "]" then
				if self:skip_sep(ls) == sep then
					self:save_and_next(ls)
					if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
						cont = cont - 1
						if sep == 0 and cont >= 0 then
							break
						end
					end
					break
				end
			elseif self:currIsNewline(ls) then
				self:save(ls, "\n")
				self:inclinenumber(ls)
				if not Token then
					ls.buff = ""
				end
			else
				if Token then
					self:save_and_next(ls)
				else
					self:nextc(ls)
				end
			end
		end
		if Token then
			local p = 3 + sep
			Token.seminfo = string.sub(ls.buff, p, -p)
		end
	end
	function luaX:read_string(ls, del, Token)
		self:save_and_next(ls)
		while ls.current ~= del do
			local c = ls.current
			if c == "EOZ" then
				self:lexerror(ls, "unfinished string", "TK_EOS")
			elseif self:currIsNewline(ls) then
				self:lexerror(ls, "unfinished string", "TK_STRING")
			elseif c == "\\" then
				c = self:nextc(ls)
				if self:currIsNewline(ls) then
					self:save(ls, "\n")
					self:inclinenumber(ls)
				elseif c ~= "EOZ" then
					local i = string.find("abfnrtv", c, 1, 1)
					if i then
						self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i))
						self:nextc(ls)
					elseif not string.find(c, "%d") then
						self:save_and_next(ls)
					else
						c, i = 0, 0
						repeat
							c = 10 * c + ls.current
							self:nextc(ls)
							i = i + 1
						until i >= 3 or not string.find(ls.current, "%d")
						if c > 255 then
							self:lexerror(ls, "escape sequence too large", "TK_STRING")
						end
						self:save(ls, string.char(c))
					end
				end
			else
				self:save_and_next(ls)
			end
		end
		self:save_and_next(ls)
		Token.seminfo = string.sub(ls.buff, 2, -2)
	end
	function luaX:llex(ls, Token)
		ls.buff = ""
		while true do
			local c = ls.current
			if self:currIsNewline(ls) then
				self:inclinenumber(ls)
			elseif c == "-" then
				c = self:nextc(ls)
				if c ~= "-" then
					return "-"
				end
				local sep = -1
				if self:nextc(ls) == "[" then
					sep = self:skip_sep(ls)
					ls.buff = ""
				end
				if sep >= 0 then
					self:read_long_string(ls, nil, sep)
					ls.buff = ""
				else
					while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
						self:nextc(ls)
					end
				end
			elseif c == "[" then
				local sep = self:skip_sep(ls)
				if sep >= 0 then
					self:read_long_string(ls, Token, sep)
					return "TK_STRING"
				elseif sep == -1 then
					return "["
				else
					self:lexerror(ls, "invalid long string delimiter", "TK_STRING")
				end
			elseif c == "=" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "="
				else
					self:nextc(ls)
					return "TK_EQ"
				end
			elseif c == "<" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "<"
				else
					self:nextc(ls)
					return "TK_LE"
				end
			elseif c == ">" then
				c = self:nextc(ls)
				if c ~= "=" then
					return ">"
				else
					self:nextc(ls)
					return "TK_GE"
				end
			elseif c == "~" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "~"
				else
					self:nextc(ls)
					return "TK_NE"
				end
			elseif c == '"' or c == "'" then
				self:read_string(ls, c, Token)
				return "TK_STRING"
			elseif c == "." then
				c = self:save_and_next(ls)
				if self:check_next(ls, ".") then
					if self:check_next(ls, ".") then
						return "TK_DOTS"
					else
						return "TK_CONCAT"
					end
				elseif not string.find(c, "%d") then
					return "."
				else
					self:read_numeral(ls, Token)
					return "TK_NUMBER"
				end
			elseif c == "EOZ" then
				return "TK_EOS"
			else
				if string.find(c, "%s") then
					self:nextc(ls)
				elseif string.find(c, "%d") then
					self:read_numeral(ls, Token)
					return "TK_NUMBER"
				elseif string.find(c, "[_%a]") then
					repeat
						c = self:save_and_next(ls)
					until c == "EOZ" or not string.find(c, "[_%w]")
					local ts = ls.buff
					local tok = self.enums[ts]
					if tok then
						return tok
					end
					Token.seminfo = ts
					return "TK_NAME"
				else
					self:nextc(ls)
					return c
				end
			end
		end
	end
	luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 }
	luaP.SIZE_C = 9
	luaP.SIZE_B = 9
	luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B
	luaP.SIZE_A = 8
	luaP.SIZE_OP = 6
	luaP.POS_OP = 0
	luaP.POS_A = luaP.POS_OP + luaP.SIZE_OP
	luaP.POS_C = luaP.POS_A + luaP.SIZE_A
	luaP.POS_B = luaP.POS_C + luaP.SIZE_C
	luaP.POS_Bx = luaP.POS_C
	luaP.MAXARG_Bx = math.ldexp(1, luaP.SIZE_Bx) - 1
	luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)
	luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1
	luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1
	luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1
	function luaP:GET_OPCODE(i)
		return self.ROpCode[i.OP]
	end
	function luaP:SET_OPCODE(i, o)
		i.OP = self.OpCode[o]
	end
	function luaP:GETARG_A(i)
		return i.A
	end
	function luaP:SETARG_A(i, u)
		i.A = u
	end
	function luaP:GETARG_B(i)
		return i.B
	end
	function luaP:SETARG_B(i, b)
		i.B = b
	end
	function luaP:GETARG_C(i)
		return i.C
	end
	function luaP:SETARG_C(i, b)
		i.C = b
	end
	function luaP:GETARG_Bx(i)
		return i.Bx
	end
	function luaP:SETARG_Bx(i, b)
		i.Bx = b
	end
	function luaP:GETARG_sBx(i)
		return i.Bx - self.MAXARG_sBx
	end
	function luaP:SETARG_sBx(i, b)
		i.Bx = b + self.MAXARG_sBx
	end
	function luaP:CREATE_ABC(o, a, b, c)
		return { OP = self.OpCode[o], A = a, B = b, C = c }
	end
	function luaP:CREATE_ABx(o, a, bc)
		return { OP = self.OpCode[o], A = a, Bx = bc }
	end
	function luaP:CREATE_Inst(c)
		local o = c % 64
		c = (c - o) / 64
		local a = c % 256
		c = (c - a) / 256
		return self:CREATE_ABx(o, a, c)
	end
	function luaP:Instruction(i)
		if i.Bx then
			i.C = i.Bx % 512
			i.B = (i.Bx - i.C) / 512
		end
		local I = i.A * 64 + i.OP
		local c0 = I % 256
		I = i.C * 64 + (I - c0) / 256
		local c1 = I % 256
		I = i.B * 128 + (I - c1) / 256
		local c2 = I % 256
		local c3 = (I - c2) / 256
		return string.char(c0, c1, c2, c3)
	end
	function luaP:DecodeInst(x)
		local byte = string.byte
		local i = {}
		local I = byte(x, 1)
		local op = I % 64
		i.OP = op
		I = byte(x, 2) * 4 + (I - op) / 64
		local a = I % 256
		i.A = a
		I = byte(x, 3) * 4 + (I - a) / 256
		local c = I % 512
		i.C = c
		i.B = byte(x, 4) * 2 + (I - c) / 512
		local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))]
		if opmode ~= "iABC" then
			i.Bx = i.B * 512 + i.C
		end
		return i
	end
	luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1)
	function luaP:ISK(x)
		return x >= self.BITRK
	end
	function luaP:INDEXK(r)
		return r - self.BITRK
	end
	luaP.MAXINDEXRK = luaP.BITRK - 1
	function luaP:RKASK(x)
		return x + self.BITRK
	end
	luaP.NO_REG = luaP.MAXARG_A
	luaP.opnames = {}
	luaP.OpCode = {}
	luaP.ROpCode = {}
	local i = 0
	for v in
		string.gmatch(
			[[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],
			"%S+"
		)
	do
		local n = "OP_" .. v
		luaP.opnames[i] = v
		luaP.OpCode[n] = i
		luaP.ROpCode[i] = n
		i = i + 1
	end
	luaP.NUM_OPCODES = i
	luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 }
	function luaP:getOpMode(m)
		return self.opmodes[self.OpCode[m]] % 4
	end
	function luaP:getBMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4
	end
	function luaP:getCMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4
	end
	function luaP:testAMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2
	end
	function luaP:testTMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 128)
	end
	luaP.LFIELDS_PER_FLUSH = 50
	local function opmode(t, a, b, c, m)
		local luaP = luaP
		return t * 128 + a * 64 + luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m]
	end
	luaP.opmodes = {
		opmode(0, 1, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgR", "OpArgK", "iABC"),
		opmode(0, 0, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 0, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgR", "iABC"),
		opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 1, "OpArgR", "OpArgU", "iABC"),
		opmode(1, 1, "OpArgR", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
		opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
		opmode(1, 0, "OpArgN", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgN", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABC"),
	}
	luaP.opmodes[0] = opmode(0, 1, "OpArgR", "OpArgN", "iABC")
	luaU.LUA_SIGNATURE = "\27Lua"
	luaU.LUA_TNUMBER = 3
	luaU.LUA_TSTRING = 4
	luaU.LUA_TNIL = 0
	luaU.LUA_TBOOLEAN = 1
	luaU.LUA_TNONE = -1
	luaU.LUAC_VERSION = 0x51
	luaU.LUAC_FORMAT = 0
	luaU.LUAC_HEADERSIZE = 12
	function luaU:make_setS()
		local buff = {}
		buff.data = ""
		local writer = function(s, buff)
			if not s then
				return 0
			end
			buff.data = buff.data .. s
			return 0
		end
		return writer, buff
	end
	function luaU:make_setF(filename)
		return nil
	end
	function luaU:ttype(o)
		local tt = type(o.value)
		if tt == "number" then
			return self.LUA_TNUMBER
		elseif tt == "string" then
			return self.LUA_TSTRING
		elseif tt == "nil" then
			return self.LUA_TNIL
		elseif tt == "boolean" then
			return self.LUA_TBOOLEAN
		else
			return self.LUA_TNONE
		end
	end
	function luaU:from_double(x)
		local function grab_byte(v)
			local c = v % 256
			return (v - c) / 256, string.char(c)
		end
		local sign = 0
		if x < 0 then
			sign = 1
			x = -x
		end
		local mantissa, exponent = math.frexp(x)
		if x == 0 then
			mantissa, exponent = 0, 0
		elseif x == 1 / 0 then
			mantissa, exponent = 0, 2047
		else
			mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
			exponent = exponent + 1022
		end
		local v, byte = "", nil
		x = math.floor(mantissa)
		for _ = 1, 6 do
			x, byte = grab_byte(x)
			v = v .. byte
		end
		x, byte = grab_byte(exponent * 16 + x)
		v = v .. byte
		x, byte = grab_byte(sign * 128 + x)
		v = v .. byte
		return v
	end
	function luaU:from_int(x)
		local v = ""
		x = math.floor(x)
		if x < 0 then
			x = 4294967296 + x
		end
		for _ = 1, 4 do
			local c = x % 256
			v = v .. string.char(c)
			x = math.floor(x / 256)
		end
		return v
	end
	function luaU:DumpBlock(b, D)
		if D.status == 0 then
			D.status = D.write(b, D.data)
		end
	end
	function luaU:DumpChar(y, D)
		self:DumpBlock(string.char(y), D)
	end
	function luaU:DumpInt(x, D)
		self:DumpBlock(self:from_int(x), D)
	end
	function luaU:DumpSizeT(x, D)
		self:DumpBlock(self:from_int(x), D)
		if size_size_t == 8 then
			self:DumpBlock(self:from_int(0), D)
		end
	end
	function luaU:DumpNumber(x, D)
		self:DumpBlock(self:from_double(x), D)
	end
	function luaU:DumpString(s, D)
		if s == nil then
			self:DumpSizeT(0, D)
		else
			s = s .. "\0"
			self:DumpSizeT(#s, D)
			self:DumpBlock(s, D)
		end
	end
	function luaU:DumpCode(f, D)
		local n = f.sizecode
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpBlock(luaP:Instruction(f.code[i]), D)
		end
	end
	function luaU:DumpConstants(f, D)
		local n = f.sizek
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			local o = f.k[i]
			local tt = self:ttype(o)
			self:DumpChar(tt, D)
			if tt == self.LUA_TNIL then
			elseif tt == self.LUA_TBOOLEAN then
				self:DumpChar(o.value and 1 or 0, D)
			elseif tt == self.LUA_TNUMBER then
				self:DumpNumber(o.value, D)
			elseif tt == self.LUA_TSTRING then
				self:DumpString(o.value, D)
			else
			end
		end
		n = f.sizep
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpFunction(f.p[i], f.source, D)
		end
	end
	function luaU:DumpDebug(f, D)
		local n
		n = D.strip and 0 or f.sizelineinfo
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpInt(f.lineinfo[i], D)
		end
		n = D.strip and 0 or f.sizelocvars
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpString(f.locvars[i].varname, D)
			self:DumpInt(f.locvars[i].startpc, D)
			self:DumpInt(f.locvars[i].endpc, D)
		end
		n = D.strip and 0 or f.sizeupvalues
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpString(f.upvalues[i], D)
		end
	end
	function luaU:DumpFunction(f, p, D)
		local source = f.source
		if source == p or D.strip then
			source = nil
		end
		self:DumpString(source, D)
		self:DumpInt(f.lineDefined, D)
		self:DumpInt(f.lastlinedefined, D)
		self:DumpChar(f.nups, D)
		self:DumpChar(f.numparams, D)
		self:DumpChar(f.is_vararg, D)
		self:DumpChar(f.maxstacksize, D)
		self:DumpCode(f, D)
		self:DumpConstants(f, D)
		self:DumpDebug(f, D)
	end
	function luaU:DumpHeader(D)
		local h = self:header()
		assert(#h == self.LUAC_HEADERSIZE)
		self:DumpBlock(h, D)
	end
	function luaU:header()
		local x = 1
		return self.LUA_SIGNATURE .. string.char(self.LUAC_VERSION, self.LUAC_FORMAT, x, 4, size_size_t, 4, 8, 0)
	end
	function luaU:dump(L, f, w, data, strip)
		local D = {}
		D.L = L
		D.write = w
		D.data = data
		D.strip = strip
		D.status = 0
		self:DumpHeader(D)
		self:DumpFunction(f, nil, D)
		D.write(nil, D.data)
		return D.status
	end
	luaK.MAXSTACK = 250
	function luaK:ttisnumber(o)
		if o then
			return type(o.value) == "number"
		else
			return false
		end
	end
	function luaK:nvalue(o)
		return o.value
	end
	function luaK:setnilvalue(o)
		o.value = nil
	end
	function luaK:setsvalue(o, x)
		o.value = x
	end
	luaK.setnvalue = luaK.setsvalue
	luaK.sethvalue = luaK.setsvalue
	luaK.setbvalue = luaK.setsvalue
	function luaK:numadd(a, b)
		return a + b
	end
	function luaK:numsub(a, b)
		return a - b
	end
	function luaK:nummul(a, b)
		return a * b
	end
	function luaK:numdiv(a, b)
		return a / b
	end
	function luaK:nummod(a, b)
		return a % b
	end
	function luaK:numpow(a, b)
		return a ^ b
	end
	function luaK:numunm(a)
		return -a
	end
	function luaK:numisnan(a)
		return a ~= a
	end
	luaK.NO_JUMP = -1
	luaK.BinOpr = {
		OPR_ADD = 0,
		OPR_SUB = 1,
		OPR_MUL = 2,
		OPR_DIV = 3,
		OPR_MOD = 4,
		OPR_POW = 5,
		OPR_CONCAT = 6,
		OPR_NE = 7,
		OPR_EQ = 8,
		OPR_LT = 9,
		OPR_LE = 10,
		OPR_GT = 11,
		OPR_GE = 12,
		OPR_AND = 13,
		OPR_OR = 14,
		OPR_NOBINOPR = 15,
	}
	luaK.UnOpr = {
		OPR_MINUS = 0,
		OPR_NOT = 1,
		OPR_LEN = 2,
		OPR_NOUNOPR = 3,
	}
	function luaK:getcode(fs, e)
		return fs.f.code[e.info]
	end
	function luaK:codeAsBx(fs, o, A, sBx)
		return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx)
	end
	function luaK:setmultret(fs, e)
		self:setreturns(fs, e, luaY.LUA_MULTRET)
	end
	function luaK:hasjumps(e)
		return e.t ~= e.f
	end
	function luaK:isnumeral(e)
		return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP
	end
	function luaK:_nil(fs, from, n)
		if fs.pc > fs.lasttarget then
			if fs.pc == 0 then
				if from >= fs.nactvar then
					return
				end
			else
				local previous = fs.f.code[fs.pc - 1]
				if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
					local pfrom = luaP:GETARG_A(previous)
					local pto = luaP:GETARG_B(previous)
					if pfrom <= from and from <= pto + 1 then
						if from + n - 1 > pto then
							luaP:SETARG_B(previous, from + n - 1)
						end
						return
					end
				end
			end
		end
		self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)
	end
	function luaK:jump(fs)
		local jpc = fs.jpc
		fs.jpc = self.NO_JUMP
		local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
		j = self:concat(fs, j, jpc)
		return j
	end
	function luaK:ret(fs, first, nret)
		self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
	end
	function luaK:condjump(fs, op, A, B, C)
		self:codeABC(fs, op, A, B, C)
		return self:jump(fs)
	end
	function luaK:fixjump(fs, pc, dest)
		local jmp = fs.f.code[pc]
		local offset = dest - (pc + 1)
		lua_assert(dest ~= self.NO_JUMP)
		if math.abs(offset) > luaP.MAXARG_sBx then
			luaX:syntaxerror(fs.ls, "control structure too long")
		end
		luaP:SETARG_sBx(jmp, offset)
	end
	function luaK:getlabel(fs)
		fs.lasttarget = fs.pc
		return fs.pc
	end
	function luaK:getjump(fs, pc)
		local offset = luaP:GETARG_sBx(fs.f.code[pc])
		if offset == self.NO_JUMP then
			return self.NO_JUMP
		else
			return (pc + 1) + offset
		end
	end
	function luaK:getjumpcontrol(fs, pc)
		local pi = fs.f.code[pc]
		local ppi = fs.f.code[pc - 1]
		if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
			return ppi
		else
			return pi
		end
	end
	function luaK:need_value(fs, list)
		while list ~= self.NO_JUMP do
			local i = self:getjumpcontrol(fs, list)
			if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
				return true
			end
			list = self:getjump(fs, list)
		end
		return false
	end
	function luaK:patchtestreg(fs, node, reg)
		local i = self:getjumpcontrol(fs, node)
		if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
			return false
		end
		if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
			luaP:SETARG_A(i, reg)
		else
			luaP:SET_OPCODE(i, "OP_TEST")
			local b = luaP:GETARG_B(i)
			luaP:SETARG_A(i, b)
			luaP:SETARG_B(i, 0)
		end
		return true
	end
	function luaK:removevalues(fs, list)
		while list ~= self.NO_JUMP do
			self:patchtestreg(fs, list, luaP.NO_REG)
			list = self:getjump(fs, list)
		end
	end
	function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
		while list ~= self.NO_JUMP do
			local _next = self:getjump(fs, list)
			if self:patchtestreg(fs, list, reg) then
				self:fixjump(fs, list, vtarget)
			else
				self:fixjump(fs, list, dtarget)
			end
			list = _next
		end
	end
	function luaK:dischargejpc(fs)
		self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
		fs.jpc = self.NO_JUMP
	end
	function luaK:patchlist(fs, list, target)
		if target == fs.pc then
			self:patchtohere(fs, list)
		else
			lua_assert(target < fs.pc)
			self:patchlistaux(fs, list, target, luaP.NO_REG, target)
		end
	end
	function luaK:patchtohere(fs, list)
		self:getlabel(fs)
		fs.jpc = self:concat(fs, fs.jpc, list)
	end
	function luaK:concat(fs, l1, l2)
		if l2 == self.NO_JUMP then
			return l1
		elseif l1 == self.NO_JUMP then
			return l2
		else
			local list = l1
			local _next = self:getjump(fs, list)
			while _next ~= self.NO_JUMP do
				list = _next
				_next = self:getjump(fs, list)
			end
			self:fixjump(fs, list, l2)
		end
		return l1
	end
	function luaK:checkstack(fs, n)
		local newstack = fs.freereg + n
		if newstack > fs.f.maxstacksize then
			if newstack >= self.MAXSTACK then
				luaX:syntaxerror(fs.ls, "function or expression too complex")
			end
			fs.f.maxstacksize = newstack
		end
	end
	function luaK:reserveregs(fs, n)
		self:checkstack(fs, n)
		fs.freereg = fs.freereg + n
	end
	function luaK:freereg(fs, reg)
		if not luaP:ISK(reg) and reg >= fs.nactvar then
			fs.freereg = fs.freereg - 1
			lua_assert(reg == fs.freereg)
		end
	end
	function luaK:freeexp(fs, e)
		if e.k == "VNONRELOC" then
			self:freereg(fs, e.info)
		end
	end
	function luaK:addk(fs, k, v)
		local L = fs.L
		local idx = fs.h[k.value]
		local f = fs.f
		if self:ttisnumber(idx) then
			return self:nvalue(idx)
		else
			idx = {}
			self:setnvalue(idx, fs.nk)
			fs.h[k.value] = idx
			luaY:growvector(L, f.k, fs.nk, f.sizek, nil, luaP.MAXARG_Bx, "constant table overflow")
			f.k[fs.nk] = v
			local nk = fs.nk
			fs.nk = fs.nk + 1
			return nk
		end
	end
	function luaK:stringK(fs, s)
		local o = {}
		self:setsvalue(o, s)
		return self:addk(fs, o, o)
	end
	function luaK:numberK(fs, r)
		local o = {}
		self:setnvalue(o, r)
		return self:addk(fs, o, o)
	end
	function luaK:boolK(fs, b)
		local o = {}
		self:setbvalue(o, b)
		return self:addk(fs, o, o)
	end
	function luaK:nilK(fs)
		local k, v = {}, {}
		self:setnilvalue(v)
		self:sethvalue(k, fs.h)
		return self:addk(fs, k, v)
	end
	function luaK:setreturns(fs, e, nresults)
		if e.k == "VCALL" then
			luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
		elseif e.k == "VVARARG" then
			luaP:SETARG_B(self:getcode(fs, e), nresults + 1)
			luaP:SETARG_A(self:getcode(fs, e), fs.freereg)
			luaK:reserveregs(fs, 1)
		end
	end
	function luaK:setoneret(fs, e)
		if e.k == "VCALL" then
			e.k = "VNONRELOC"
			e.info = luaP:GETARG_A(self:getcode(fs, e))
		elseif e.k == "VVARARG" then
			luaP:SETARG_B(self:getcode(fs, e), 2)
			e.k = "VRELOCABLE"
		end
	end
	function luaK:dischargevars(fs, e)
		local k = e.k
		if k == "VLOCAL" then
			e.k = "VNONRELOC"
		elseif k == "VUPVAL" then
			e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
			e.k = "VRELOCABLE"
		elseif k == "VGLOBAL" then
			e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
			e.k = "VRELOCABLE"
		elseif k == "VINDEXED" then
			self:freereg(fs, e.aux)
			self:freereg(fs, e.info)
			e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
			e.k = "VRELOCABLE"
		elseif k == "VVARARG" or k == "VCALL" then
			self:setoneret(fs, e)
		else
		end
	end
	function luaK:code_label(fs, A, b, jump)
		self:getlabel(fs)
		return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
	end
	function luaK:discharge2reg(fs, e, reg)
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" then
			self:_nil(fs, reg, 1)
		elseif k == "VFALSE" or k == "VTRUE" then
			self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
		elseif k == "VK" then
			self:codeABx(fs, "OP_LOADK", reg, e.info)
		elseif k == "VKNUM" then
			self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
		elseif k == "VRELOCABLE" then
			local pc = self:getcode(fs, e)
			luaP:SETARG_A(pc, reg)
		elseif k == "VNONRELOC" then
			if reg ~= e.info then
				self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
			end
		else
			lua_assert(e.k == "VVOID" or e.k == "VJMP")
			return
		end
		e.info = reg
		e.k = "VNONRELOC"
	end
	function luaK:discharge2anyreg(fs, e)
		if e.k ~= "VNONRELOC" then
			self:reserveregs(fs, 1)
			self:discharge2reg(fs, e, fs.freereg - 1)
		end
	end
	function luaK:exp2reg(fs, e, reg)
		self:discharge2reg(fs, e, reg)
		if e.k == "VJMP" then
			e.t = self:concat(fs, e.t, e.info)
		end
		if self:hasjumps(e) then
			local final
			local p_f = self.NO_JUMP
			local p_t = self.NO_JUMP
			if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
				local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
				p_f = self:code_label(fs, reg, 0, 1)
				p_t = self:code_label(fs, reg, 1, 0)
				self:patchtohere(fs, fj)
			end
			final = self:getlabel(fs)
			self:patchlistaux(fs, e.f, final, reg, p_f)
			self:patchlistaux(fs, e.t, final, reg, p_t)
		end
		e.f, e.t = self.NO_JUMP, self.NO_JUMP
		e.info = reg
		e.k = "VNONRELOC"
	end
	function luaK:exp2nextreg(fs, e)
		self:dischargevars(fs, e)
		self:freeexp(fs, e)
		self:reserveregs(fs, 1)
		self:exp2reg(fs, e, fs.freereg - 1)
	end
	function luaK:exp2anyreg(fs, e)
		self:dischargevars(fs, e)
		if e.k == "VNONRELOC" then
			if not self:hasjumps(e) then
				return e.info
			end
			if e.info >= fs.nactvar then
				self:exp2reg(fs, e, e.info)
				return e.info
			end
		end
		self:exp2nextreg(fs, e)
		return e.info
	end
	function luaK:exp2val(fs, e)
		if self:hasjumps(e) then
			self:exp2anyreg(fs, e)
		else
			self:dischargevars(fs, e)
		end
	end
	function luaK:exp2RK(fs, e)
		self:exp2val(fs, e)
		local k = e.k
		if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
			if fs.nk <= luaP.MAXINDEXRK then
				if e.k == "VNIL" then
					e.info = self:nilK(fs)
				else
					e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval) or self:boolK(fs, e.k == "VTRUE")
				end
				e.k = "VK"
				return luaP:RKASK(e.info)
			end
		elseif k == "VK" then
			if e.info <= luaP.MAXINDEXRK then
				return luaP:RKASK(e.info)
			end
		else
		end
		return self:exp2anyreg(fs, e)
	end
	function luaK:storevar(fs, var, ex)
		local k = var.k
		if k == "VLOCAL" then
			self:freeexp(fs, ex)
			self:exp2reg(fs, ex, var.info)
			return
		elseif k == "VUPVAL" then
			local e = self:exp2anyreg(fs, ex)
			self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
		elseif k == "VGLOBAL" then
			local e = self:exp2anyreg(fs, ex)
			self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
		elseif k == "VINDEXED" then
			local e = self:exp2RK(fs, ex)
			self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
		else
			lua_assert(0)
		end
		self:freeexp(fs, ex)
	end
	function luaK:_self(fs, e, key)
		self:exp2anyreg(fs, e)
		self:freeexp(fs, e)
		local func = fs.freereg
		self:reserveregs(fs, 2)
		self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
		self:freeexp(fs, key)
		e.info = func
		e.k = "VNONRELOC"
	end
	function luaK:invertjump(fs, e)
		local pc = self:getjumpcontrol(fs, e.info)
		lua_assert(
			luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0
				and luaP:GET_OPCODE(pc) ~= "OP_TESTSET"
				and luaP:GET_OPCODE(pc) ~= "OP_TEST"
		)
		luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
	end
	function luaK:jumponcond(fs, e, cond)
		if e.k == "VRELOCABLE" then
			local ie = self:getcode(fs, e)
			if luaP:GET_OPCODE(ie) == "OP_NOT" then
				fs.pc = fs.pc - 1
				return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
			end
		end
		self:discharge2anyreg(fs, e)
		self:freeexp(fs, e)
		return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
	end
	function luaK:goiftrue(fs, e)
		local pc
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VK" or k == "VKNUM" or k == "VTRUE" then
			pc = self.NO_JUMP
		elseif k == "VFALSE" then
			pc = self:jump(fs)
		elseif k == "VJMP" then
			self:invertjump(fs, e)
			pc = e.info
		else
			pc = self:jumponcond(fs, e, false)
		end
		e.f = self:concat(fs, e.f, pc)
		self:patchtohere(fs, e.t)
		e.t = self.NO_JUMP
	end
	function luaK:goiffalse(fs, e)
		local pc
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" or k == "VFALSE" then
			pc = self.NO_JUMP
		elseif k == "VTRUE" then
			pc = self:jump(fs)
		elseif k == "VJMP" then
			pc = e.info
		else
			pc = self:jumponcond(fs, e, true)
		end
		e.t = self:concat(fs, e.t, pc)
		self:patchtohere(fs, e.f)
		e.f = self.NO_JUMP
	end
	function luaK:codenot(fs, e)
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" or k == "VFALSE" then
			e.k = "VTRUE"
		elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
			e.k = "VFALSE"
		elseif k == "VJMP" then
			self:invertjump(fs, e)
		elseif k == "VRELOCABLE" or k == "VNONRELOC" then
			self:discharge2anyreg(fs, e)
			self:freeexp(fs, e)
			e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
			e.k = "VRELOCABLE"
		else
			lua_assert(0)
		end
		e.f, e.t = e.t, e.f
		self:removevalues(fs, e.f)
		self:removevalues(fs, e.t)
	end
	function luaK:indexed(fs, t, k)
		t.aux = self:exp2RK(fs, k)
		t.k = "VINDEXED"
	end
	function luaK:constfolding(op, e1, e2)
		local r
		if not self:isnumeral(e1) or not self:isnumeral(e2) then
			return false
		end
		local v1 = e1.nval
		local v2 = e2.nval
		if op == "OP_ADD" then
			r = self:numadd(v1, v2)
		elseif op == "OP_SUB" then
			r = self:numsub(v1, v2)
		elseif op == "OP_MUL" then
			r = self:nummul(v1, v2)
		elseif op == "OP_DIV" then
			if v2 == 0 then
				return false
			end
			r = self:numdiv(v1, v2)
		elseif op == "OP_MOD" then
			if v2 == 0 then
				return false
			end
			r = self:nummod(v1, v2)
		elseif op == "OP_POW" then
			r = self:numpow(v1, v2)
		elseif op == "OP_UNM" then
			r = self:numunm(v1)
		elseif op == "OP_LEN" then
			return false
		else
			lua_assert(0)
			r = 0
		end
		if self:numisnan(r) then
			return false
		end
		e1.nval = r
		return true
	end
	function luaK:codearith(fs, op, e1, e2)
		if self:constfolding(op, e1, e2) then
			return
		else
			local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
			local o1 = self:exp2RK(fs, e1)
			if o1 > o2 then
				self:freeexp(fs, e1)
				self:freeexp(fs, e2)
			else
				self:freeexp(fs, e2)
				self:freeexp(fs, e1)
			end
			e1.info = self:codeABC(fs, op, 0, o1, o2)
			e1.k = "VRELOCABLE"
		end
	end
	function luaK:codecomp(fs, op, cond, e1, e2)
		local o1 = self:exp2RK(fs, e1)
		local o2 = self:exp2RK(fs, e2)
		self:freeexp(fs, e2)
		self:freeexp(fs, e1)
		if cond == 0 and op ~= "OP_EQ" then
			o1, o2 = o2, o1
			cond = 1
		end
		e1.info = self:condjump(fs, op, cond, o1, o2)
		e1.k = "VJMP"
	end
	function luaK:prefix(fs, op, e)
		local e2 = {}
		e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
		e2.k = "VKNUM"
		e2.nval = 0
		if op == "OPR_MINUS" then
			if not self:isnumeral(e) then
				self:exp2anyreg(fs, e)
			end
			self:codearith(fs, "OP_UNM", e, e2)
		elseif op == "OPR_NOT" then
			self:codenot(fs, e)
		elseif op == "OPR_LEN" then
			self:exp2anyreg(fs, e)
			self:codearith(fs, "OP_LEN", e, e2)
		else
			lua_assert(0)
		end
	end
	function luaK:infix(fs, op, v)
		if op == "OPR_AND" then
			self:goiftrue(fs, v)
		elseif op == "OPR_OR" then
			self:goiffalse(fs, v)
		elseif op == "OPR_CONCAT" then
			self:exp2nextreg(fs, v)
		elseif
			op == "OPR_ADD"
			or op == "OPR_SUB"
			or op == "OPR_MUL"
			or op == "OPR_DIV"
			or op == "OPR_MOD"
			or op == "OPR_POW"
		then
			if not self:isnumeral(v) then
				self:exp2RK(fs, v)
			end
		else
			self:exp2RK(fs, v)
		end
	end
	luaK.arith_op = {
		OPR_ADD = "OP_ADD",
		OPR_SUB = "OP_SUB",
		OPR_MUL = "OP_MUL",
		OPR_DIV = "OP_DIV",
		OPR_MOD = "OP_MOD",
		OPR_POW = "OP_POW",
	}
	luaK.comp_op = {
		OPR_EQ = "OP_EQ",
		OPR_NE = "OP_EQ",
		OPR_LT = "OP_LT",
		OPR_LE = "OP_LE",
		OPR_GT = "OP_LT",
		OPR_GE = "OP_LE",
	}
	luaK.comp_cond = {
		OPR_EQ = 1,
		OPR_NE = 0,
		OPR_LT = 1,
		OPR_LE = 1,
		OPR_GT = 0,
		OPR_GE = 0,
	}
	function luaK:posfix(fs, op, e1, e2)
		local function copyexp(e1, e2)
			e1.k = e2.k
			e1.info = e2.info
			e1.aux = e2.aux
			e1.nval = e2.nval
			e1.t = e2.t
			e1.f = e2.f
		end
		if op == "OPR_AND" then
			lua_assert(e1.t == self.NO_JUMP)
			self:dischargevars(fs, e2)
			e2.f = self:concat(fs, e2.f, e1.f)
			copyexp(e1, e2)
		elseif op == "OPR_OR" then
			lua_assert(e1.f == self.NO_JUMP)
			self:dischargevars(fs, e2)
			e2.t = self:concat(fs, e2.t, e1.t)
			copyexp(e1, e2)
		elseif op == "OPR_CONCAT" then
			self:exp2val(fs, e2)
			if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
				lua_assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
				self:freeexp(fs, e1)
				luaP:SETARG_B(self:getcode(fs, e2), e1.info)
				e1.k = "VRELOCABLE"
				e1.info = e2.info
			else
				self:exp2nextreg(fs, e2)
				self:codearith(fs, "OP_CONCAT", e1, e2)
			end
		else
			local arith = self.arith_op[op]
			if arith then
				self:codearith(fs, arith, e1, e2)
			else
				local comp = self.comp_op[op]
				if comp then
					self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
				else
					lua_assert(0)
				end
			end
		end
	end
	function luaK:fixline(fs, line)
		fs.f.lineinfo[fs.pc - 1] = line
	end
	function luaK:code(fs, i, line)
		local f = fs.f
		self:dischargejpc(fs)
		luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil, luaY.MAX_INT, "code size overflow")
		f.code[fs.pc] = i
		luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil, luaY.MAX_INT, "code size overflow")
		f.lineinfo[fs.pc] = line
		local pc = fs.pc
		fs.pc = fs.pc + 1
		return pc
	end
	function luaK:codeABC(fs, o, a, b, c)
		lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
		lua_assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
		lua_assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
		return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
	end
	function luaK:codeABx(fs, o, a, bc)
		lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABx or luaP:getOpMode(o) == luaP.OpMode.iAsBx)
		lua_assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
		return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
	end
	function luaK:setlist(fs, base, nelems, tostore)
		local c = math.floor((nelems - 1) / luaP.LFIELDS_PER_FLUSH) + 1
		local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
		lua_assert(tostore ~= 0)
		if c <= luaP.MAXARG_C then
			self:codeABC(fs, "OP_SETLIST", base, b, c)
		else
			self:codeABC(fs, "OP_SETLIST", base, b, 0)
			self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
		end
		fs.freereg = base + 1
	end
	luaY.LUA_QS = luaX.LUA_QS or "'%s'"
	luaY.SHRT_MAX = 32767
	luaY.LUAI_MAXVARS = 200
	luaY.LUAI_MAXUPVALUES = 60
	luaY.MAX_INT = luaX.MAX_INT or 2147483645
	luaY.LUAI_MAXCCALLS = 200
	luaY.VARARG_HASARG = 1
	luaY.HASARG_MASK = 2
	luaY.VARARG_ISVARARG = 2
	luaY.VARARG_NEEDSARG = 4
	luaY.LUA_MULTRET = -1
	function luaY:LUA_QL(x)
		return "'" .. x .. "'"
	end
	function luaY:growvector(_, _, nelems, _, _, limit, e)
		if nelems >= limit then
			error(e)
		end
	end
	function luaY:newproto()
		local f = {}
		f.k = {}
		f.sizek = 0
		f.p = {}
		f.sizep = 0
		f.code = {}
		f.sizecode = 0
		f.sizelineinfo = 0
		f.sizeupvalues = 0
		f.nups = 0
		f.upvalues = {}
		f.numparams = 0
		f.is_vararg = 0
		f.maxstacksize = 0
		f.lineinfo = {}
		f.sizelocvars = 0
		f.locvars = {}
		f.lineDefined = 0
		f.lastlinedefined = 0
		f.source = nil
		return f
	end
	function luaY:int2fb(x)
		local e = 0
		while x >= 16 do
			x = math.floor((x + 1) / 2)
			e = e + 1
		end
		if x < 8 then
			return x
		else
			return ((e + 1) * 8) + (x - 8)
		end
	end
	function luaY:hasmultret(k)
		return k == "VCALL" or k == "VVARARG"
	end
	function luaY:getlocvar(fs, i)
		return fs.f.locvars[fs.actvar[i]]
	end
	function luaY:checklimit(fs, v, l, m)
		if v > l then
			self:errorlimit(fs, l, m)
		end
	end
	function luaY:error_expected(ls, token)
		luaX:syntaxerror(ls, string.format(self.LUA_QS .. " expected", luaX:token2str(ls, token)))
	end
	function luaY:errorlimit(fs, limit, what)
		local msg = (fs.f.linedefined == 0) and string.format("main function has more than %d %s", limit, what)
			or string.format("function at line %d has more than %d %s", fs.f.linedefined, limit, what)
		luaX:lexerror(fs.ls, msg, 0)
	end
	function luaY:testnext(ls, c)
		if ls.t.token == c then
			luaX:next(ls)
			return true
		else
			return false
		end
	end
	function luaY:check(ls, c)
		if ls.t.token ~= c then
			self:error_expected(ls, c)
		end
	end
	function luaY:checknext(ls, c)
		self:check(ls, c)
		luaX:next(ls)
	end
	function luaY:check_condition(ls, c, msg)
		if not c then
			luaX:syntaxerror(ls, msg)
		end
	end
	function luaY:check_match(ls, what, who, where)
		if not self:testnext(ls, what) then
			if where == ls.linenumber then
				self:error_expected(ls, what)
			else
				luaX:syntaxerror(
					ls,
					string.format(
						self.LUA_QS .. " expected (to close " .. self.LUA_QS .. " at line %d)",
						luaX:token2str(ls, what),
						luaX:token2str(ls, who),
						where
					)
				)
			end
		end
	end
	function luaY:str_checkname(ls)
		self:check(ls, "TK_NAME")
		local ts = ls.t.seminfo
		luaX:next(ls)
		return ts
	end
	function luaY:init_exp(e, k, i)
		e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
		e.k = k
		e.info = i
	end
	function luaY:codestring(ls, e, s)
		self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
	end
	function luaY:checkname(ls, e)
		self:codestring(ls, e, self:str_checkname(ls))
	end
	function luaY:registerlocalvar(ls, varname)
		local fs = ls.fs
		local f = fs.f
		self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars, nil, self.SHRT_MAX, "too many local variables")
		f.locvars[fs.nlocvars] = {}
		f.locvars[fs.nlocvars].varname = varname
		local nlocvars = fs.nlocvars
		fs.nlocvars = fs.nlocvars + 1
		return nlocvars
	end
	function luaY:new_localvarliteral(ls, v, n)
		self:new_localvar(ls, v, n)
	end
	function luaY:new_localvar(ls, name, n)
		local fs = ls.fs
		self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
		fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
	end
	function luaY:adjustlocalvars(ls, nvars)
		local fs = ls.fs
		fs.nactvar = fs.nactvar + nvars
		for i = nvars, 1, -1 do
			self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
		end
	end
	function luaY:removevars(ls, tolevel)
		local fs = ls.fs
		while fs.nactvar > tolevel do
			fs.nactvar = fs.nactvar - 1
			self:getlocvar(fs, fs.nactvar).endpc = fs.pc
		end
	end
	function luaY:indexupvalue(fs, name, v)
		local f = fs.f
		for i = 0, f.nups - 1 do
			if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
				lua_assert(f.upvalues[i] == name)
				return i
			end
		end
		self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
		self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues, nil, self.MAX_INT, "")
		f.upvalues[f.nups] = name
		lua_assert(v.k == "VLOCAL" or v.k == "VUPVAL")
		fs.upvalues[f.nups] = { k = v.k, info = v.info }
		local nups = f.nups
		f.nups = f.nups + 1
		return nups
	end
	function luaY:searchvar(fs, n)
		for i = fs.nactvar - 1, 0, -1 do
			if n == self:getlocvar(fs, i).varname then
				return i
			end
		end
		return -1
	end
	function luaY:markupval(fs, level)
		local bl = fs.bl
		while bl and bl.nactvar > level do
			bl = bl.previous
		end
		if bl then
			bl.upval = true
		end
	end
	function luaY:singlevaraux(fs, n, var, base)
		if fs == nil then
			self:init_exp(var, "VGLOBAL", luaP.NO_REG)
			return "VGLOBAL"
		else
			local v = self:searchvar(fs, n)
			if v >= 0 then
				self:init_exp(var, "VLOCAL", v)
				if base == 0 then
					self:markupval(fs, v)
				end
				return "VLOCAL"
			else
				if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
					return "VGLOBAL"
				end
				var.info = self:indexupvalue(fs, n, var)
				var.k = "VUPVAL"
				return "VUPVAL"
			end
		end
	end
	function luaY:singlevar(ls, var)
		local varname = self:str_checkname(ls)
		local fs = ls.fs
		if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
			var.info = luaK:stringK(fs, varname)
		end
	end
	function luaY:adjust_assign(ls, nvars, nexps, e)
		local fs = ls.fs
		local extra = nvars - nexps
		if self:hasmultret(e.k) then
			extra = extra + 1
			if extra <= 0 then
				extra = 0
			end
			luaK:setreturns(fs, e, extra)
			if extra > 1 then
				luaK:reserveregs(fs, extra - 1)
			end
		else
			if e.k ~= "VVOID" then
				luaK:exp2nextreg(fs, e)
			end
			if extra > 0 then
				local reg = fs.freereg
				luaK:reserveregs(fs, extra)
				luaK:_nil(fs, reg, extra)
			end
		end
	end
	function luaY:enterlevel(ls)
		ls.L.nCcalls = ls.L.nCcalls + 1
		if ls.L.nCcalls > self.LUAI_MAXCCALLS then
			luaX:lexerror(ls, "chunk has too many syntax levels", 0)
		end
	end
	function luaY:leavelevel(ls)
		ls.L.nCcalls = ls.L.nCcalls - 1
	end
	function luaY:enterblock(fs, bl, isbreakable)
		bl.breaklist = luaK.NO_JUMP
		bl.isbreakable = isbreakable
		bl.nactvar = fs.nactvar
		bl.upval = false
		bl.previous = fs.bl
		fs.bl = bl
		lua_assert(fs.freereg == fs.nactvar)
	end
	function luaY:leaveblock(fs)
		local bl = fs.bl
		fs.bl = bl.previous
		self:removevars(fs.ls, bl.nactvar)
		if bl.upval then
			luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
		end
		lua_assert(not bl.isbreakable or not bl.upval)
		lua_assert(bl.nactvar == fs.nactvar)
		fs.freereg = fs.nactvar
		luaK:patchtohere(fs, bl.breaklist)
	end
	function luaY:pushclosure(ls, func, v)
		local fs = ls.fs
		local f = fs.f
		self:growvector(ls.L, f.p, fs.np, f.sizep, nil, luaP.MAXARG_Bx, "constant table overflow")
		f.p[fs.np] = func.f
		fs.np = fs.np + 1
		self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
		for i = 0, func.f.nups - 1 do
			local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
			luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
		end
	end
	function luaY:open_func(ls, fs)
		local L = ls.L
		local f = self:newproto()
		fs.f = f
		fs.prev = ls.fs
		fs.ls = ls
		fs.L = L
		ls.fs = fs
		fs.pc = 0
		fs.lasttarget = -1
		fs.jpc = luaK.NO_JUMP
		fs.freereg = 0
		fs.nk = 0
		fs.np = 0
		fs.nlocvars = 0
		fs.nactvar = 0
		fs.bl = nil
		f.source = ls.source
		f.maxstacksize = 2
		fs.h = {}
	end
	function luaY:close_func(ls)
		local fs = ls.fs
		local f = fs.f
		self:removevars(ls, 0)
		luaK:ret(fs, 0, 0)
		f.sizecode = fs.pc
		f.sizelineinfo = fs.pc
		f.sizek = fs.nk
		f.sizep = fs.np
		f.sizelocvars = fs.nlocvars
		f.sizeupvalues = f.nups
		lua_assert(fs.bl == nil)
		ls.fs = fs.prev
	end
	function luaY:parser(L, z, buff, name)
		local lexstate = {}
		lexstate.t = {}
		lexstate.lookahead = {}
		local funcstate = {}
		funcstate.upvalues = {}
		funcstate.actvar = {}
		L.nCcalls = 0
		lexstate.buff = buff
		luaX:setinput(L, lexstate, z, name)
		self:open_func(lexstate, funcstate)
		funcstate.f.is_vararg = self.VARARG_ISVARARG
		luaX:next(lexstate)
		self:chunk(lexstate)
		self:check(lexstate, "TK_EOS")
		self:close_func(lexstate)
		lua_assert(funcstate.prev == nil)
		lua_assert(funcstate.f.nups == 0)
		lua_assert(lexstate.fs == nil)
		return funcstate.f
	end
	function luaY:field(ls, v)
		local fs = ls.fs
		local key = {}
		luaK:exp2anyreg(fs, v)
		luaX:next(ls)
		self:checkname(ls, key)
		luaK:indexed(fs, v, key)
	end
	function luaY:yindex(ls, v)
		luaX:next(ls)
		self:expr(ls, v)
		luaK:exp2val(ls.fs, v)
		self:checknext(ls, "]")
	end
	function luaY:recfield(ls, cc)
		local fs = ls.fs
		local reg = ls.fs.freereg
		local key, val = {}, {}
		if ls.t.token == "TK_NAME" then
			self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
			self:checkname(ls, key)
		else
			self:yindex(ls, key)
		end
		cc.nh = cc.nh + 1
		self:checknext(ls, "=")
		local rkkey = luaK:exp2RK(fs, key)
		self:expr(ls, val)
		luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
		fs.freereg = reg
	end
	function luaY:closelistfield(fs, cc)
		if cc.v.k == "VVOID" then
			return
		end
		luaK:exp2nextreg(fs, cc.v)
		cc.v.k = "VVOID"
		if cc.tostore == luaP.LFIELDS_PER_FLUSH then
			luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
			cc.tostore = 0
		end
	end
	function luaY:lastlistfield(fs, cc)
		if cc.tostore == 0 then
			return
		end
		if self:hasmultret(cc.v.k) then
			luaK:setmultret(fs, cc.v)
			luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
			cc.na = cc.na - 1
		else
			if cc.v.k ~= "VVOID" then
				luaK:exp2nextreg(fs, cc.v)
			end
			luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
		end
	end
	function luaY:listfield(ls, cc)
		self:expr(ls, cc.v)
		self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
		cc.na = cc.na + 1
		cc.tostore = cc.tostore + 1
	end
	function luaY:constructor(ls, t)
		local fs = ls.fs
		local line = ls.linenumber
		local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
		local cc = {}
		cc.v = {}
		cc.na, cc.nh, cc.tostore = 0, 0, 0
		cc.t = t
		self:init_exp(t, "VRELOCABLE", pc)
		self:init_exp(cc.v, "VVOID", 0)
		luaK:exp2nextreg(ls.fs, t)
		self:checknext(ls, "{")
		repeat
			lua_assert(cc.v.k == "VVOID" or cc.tostore > 0)
			if ls.t.token == "}" then
				break
			end
			self:closelistfield(fs, cc)
			local c = ls.t.token
			if c == "TK_NAME" then
				luaX:lookahead(ls)
				if ls.lookahead.token ~= "=" then
					self:listfield(ls, cc)
				else
					self:recfield(ls, cc)
				end
			elseif c == "[" then
				self:recfield(ls, cc)
			else
				self:listfield(ls, cc)
			end
		until not self:testnext(ls, ",") and not self:testnext(ls, ";")
		self:check_match(ls, "}", "{", line)
		self:lastlistfield(fs, cc)
		luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na))
		luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh))
	end
	function luaY:parlist(ls)
		local fs = ls.fs
		local f = fs.f
		local nparams = 0
		f.is_vararg = 0
		if ls.t.token ~= ")" then
			repeat
				local c = ls.t.token
				if c == "TK_NAME" then
					self:new_localvar(ls, self:str_checkname(ls), nparams)
					nparams = nparams + 1
				elseif c == "TK_DOTS" then
					luaX:next(ls)
					self:new_localvarliteral(ls, "arg", nparams)
					nparams = nparams + 1
					f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG
					f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
				else
					luaX:syntaxerror(ls, "<name> or " .. self:LUA_QL("...") .. " expected")
				end
			until f.is_vararg ~= 0 or not self:testnext(ls, ",")
		end
		self:adjustlocalvars(ls, nparams)
		f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
		luaK:reserveregs(fs, fs.nactvar)
	end
	function luaY:body(ls, e, needself, line)
		local new_fs = {}
		new_fs.upvalues = {}
		new_fs.actvar = {}
		self:open_func(ls, new_fs)
		new_fs.f.lineDefined = line
		self:checknext(ls, "(")
		if needself then
			self:new_localvarliteral(ls, "self", 0)
			self:adjustlocalvars(ls, 1)
		end
		self:parlist(ls)
		self:checknext(ls, ")")
		self:chunk(ls)
		new_fs.f.lastlinedefined = ls.linenumber
		self:check_match(ls, "TK_END", "TK_FUNCTION", line)
		self:close_func(ls)
		self:pushclosure(ls, new_fs, e)
	end
	function luaY:explist1(ls, v)
		local n = 1
		self:expr(ls, v)
		while self:testnext(ls, ",") do
			luaK:exp2nextreg(ls.fs, v)
			self:expr(ls, v)
			n = n + 1
		end
		return n
	end
	function luaY:funcargs(ls, f)
		local fs = ls.fs
		local args = {}
		local nparams
		local line = ls.linenumber
		local c = ls.t.token
		if c == "(" then
			if line ~= ls.lastline then
				luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
			end
			luaX:next(ls)
			if ls.t.token == ")" then
				args.k = "VVOID"
			else
				self:explist1(ls, args)
				luaK:setmultret(fs, args)
			end
			self:check_match(ls, ")", "(", line)
		elseif c == "{" then
			self:constructor(ls, args)
		elseif c == "TK_STRING" then
			self:codestring(ls, args, ls.t.seminfo)
			luaX:next(ls)
		else
			luaX:syntaxerror(ls, "function arguments expected")
			return
		end
		lua_assert(f.k == "VNONRELOC")
		local base = f.info
		if self:hasmultret(args.k) then
			nparams = self.LUA_MULTRET
		else
			if args.k ~= "VVOID" then
				luaK:exp2nextreg(fs, args)
			end
			nparams = fs.freereg - (base + 1)
		end
		self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
		luaK:fixline(fs, line)
		fs.freereg = base + 1
	end
	function luaY:prefixexp(ls, v)
		local c = ls.t.token
		if c == "(" then
			local line = ls.linenumber
			luaX:next(ls)
			self:expr(ls, v)
			self:check_match(ls, ")", "(", line)
			luaK:dischargevars(ls.fs, v)
		elseif c == "TK_NAME" then
			self:singlevar(ls, v)
		else
			luaX:syntaxerror(ls, "unexpected symbol")
		end
		return
	end
	function luaY:primaryexp(ls, v)
		local fs = ls.fs
		self:prefixexp(ls, v)
		while true do
			local c = ls.t.token
			if c == "." then
				self:field(ls, v)
			elseif c == "[" then
				local key = {}
				luaK:exp2anyreg(fs, v)
				self:yindex(ls, key)
				luaK:indexed(fs, v, key)
			elseif c == ":" then
				local key = {}
				luaX:next(ls)
				self:checkname(ls, key)
				luaK:_self(fs, v, key)
				self:funcargs(ls, v)
			elseif c == "(" or c == "TK_STRING" or c == "{" then
				luaK:exp2nextreg(fs, v)
				self:funcargs(ls, v)
			else
				return
			end
		end
	end
	function luaY:simpleexp(ls, v)
		local c = ls.t.token
		if c == "TK_NUMBER" then
			self:init_exp(v, "VKNUM", 0)
			v.nval = ls.t.seminfo
		elseif c == "TK_STRING" then
			self:codestring(ls, v, ls.t.seminfo)
		elseif c == "TK_NIL" then
			self:init_exp(v, "VNIL", 0)
		elseif c == "TK_TRUE" then
			self:init_exp(v, "VTRUE", 0)
		elseif c == "TK_FALSE" then
			self:init_exp(v, "VFALSE", 0)
		elseif c == "TK_DOTS" then
			local fs = ls.fs
			self:check_condition(
				ls,
				fs.f.is_vararg ~= 0,
				"cannot use " .. self:LUA_QL("...") .. " outside a vararg function"
			)
			local is_vararg = fs.f.is_vararg
			if is_vararg >= self.VARARG_NEEDSARG then
				fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG
			end
			self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
		elseif c == "{" then
			self:constructor(ls, v)
			return
		elseif c == "TK_FUNCTION" then
			luaX:next(ls)
			self:body(ls, v, false, ls.linenumber)
			return
		else
			self:primaryexp(ls, v)
			return
		end
		luaX:next(ls)
	end
	function luaY:getunopr(op)
		if op == "TK_NOT" then
			return "OPR_NOT"
		elseif op == "-" then
			return "OPR_MINUS"
		elseif op == "#" then
			return "OPR_LEN"
		else
			return "OPR_NOUNOPR"
		end
	end
	luaY.getbinopr_table = {
		["+"] = "OPR_ADD",
		["-"] = "OPR_SUB",
		["*"] = "OPR_MUL",
		["/"] = "OPR_DIV",
		["%"] = "OPR_MOD",
		["^"] = "OPR_POW",
		["TK_CONCAT"] = "OPR_CONCAT",
		["TK_NE"] = "OPR_NE",
		["TK_EQ"] = "OPR_EQ",
		["<"] = "OPR_LT",
		["TK_LE"] = "OPR_LE",
		[">"] = "OPR_GT",
		["TK_GE"] = "OPR_GE",
		["TK_AND"] = "OPR_AND",
		["TK_OR"] = "OPR_OR",
	}
	function luaY:getbinopr(op)
		local opr = self.getbinopr_table[op]
		if opr then
			return opr
		else
			return "OPR_NOBINOPR"
		end
	end
	luaY.priority = {
		{ 6, 6 },
		{ 6, 6 },
		{ 7, 7 },
		{ 7, 7 },
		{ 7, 7 },
		{ 10, 9 },
		{ 5, 4 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 2, 2 },
		{ 1, 1 },
	}
	luaY.UNARY_PRIORITY = 8
	function luaY:subexpr(ls, v, limit)
		self:enterlevel(ls)
		local uop = self:getunopr(ls.t.token)
		if uop ~= "OPR_NOUNOPR" then
			luaX:next(ls)
			self:subexpr(ls, v, self.UNARY_PRIORITY)
			luaK:prefix(ls.fs, uop, v)
		else
			self:simpleexp(ls, v)
		end
		local op = self:getbinopr(ls.t.token)
		while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
			local v2 = {}
			luaX:next(ls)
			luaK:infix(ls.fs, op, v)
			local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
			luaK:posfix(ls.fs, op, v, v2)
			op = nextop
		end
		self:leavelevel(ls)
		return op
	end
	function luaY:expr(ls, v)
		self:subexpr(ls, v, 0)
	end
	function luaY:block_follow(token)
		if
			token == "TK_ELSE"
			or token == "TK_ELSEIF"
			or token == "TK_END"
			or token == "TK_UNTIL"
			or token == "TK_EOS"
		then
			return true
		else
			return false
		end
	end
	function luaY:block(ls)
		local fs = ls.fs
		local bl = {}
		self:enterblock(fs, bl, false)
		self:chunk(ls)
		lua_assert(bl.breaklist == luaK.NO_JUMP)
		self:leaveblock(fs)
	end
	function luaY:check_conflict(ls, lh, v)
		local fs = ls.fs
		local extra = fs.freereg
		local conflict = false
		while lh do
			if lh.v.k == "VINDEXED" then
				if lh.v.info == v.info then
					conflict = true
					lh.v.info = extra
				end
				if lh.v.aux == v.info then
					conflict = true
					lh.v.aux = extra
				end
			end
			lh = lh.prev
		end
		if conflict then
			luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)
			luaK:reserveregs(fs, 1)
		end
	end
	function luaY:assignment(ls, lh, nvars)
		local e = {}
		local c = lh.v.k
		self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL" or c == "VINDEXED", "syntax error")
		if self:testnext(ls, ",") then
			local nv = {}
			nv.v = {}
			nv.prev = lh
			self:primaryexp(ls, nv.v)
			if nv.v.k == "VLOCAL" then
				self:check_conflict(ls, lh, nv.v)
			end
			self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls, "variables in assignment")
			self:assignment(ls, nv, nvars + 1)
		else
			self:checknext(ls, "=")
			local nexps = self:explist1(ls, e)
			if nexps ~= nvars then
				self:adjust_assign(ls, nvars, nexps, e)
				if nexps > nvars then
					ls.fs.freereg = ls.fs.freereg - (nexps - nvars)
				end
			else
				luaK:setoneret(ls.fs, e)
				luaK:storevar(ls.fs, lh.v, e)
				return
			end
		end
		self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)
		luaK:storevar(ls.fs, lh.v, e)
	end
	function luaY:cond(ls)
		local v = {}
		self:expr(ls, v)
		if v.k == "VNIL" then
			v.k = "VFALSE"
		end
		luaK:goiftrue(ls.fs, v)
		return v.f
	end
	function luaY:breakstat(ls)
		local fs = ls.fs
		local bl = fs.bl
		local upval = false
		while bl and not bl.isbreakable do
			if bl.upval then
				upval = true
			end
			bl = bl.previous
		end
		if not bl then
			luaX:syntaxerror(ls, "no loop to break")
		end
		if upval then
			luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
		end
		bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
	end
	function luaY:whilestat(ls, line)
		local fs = ls.fs
		local bl = {}
		luaX:next(ls)
		local whileinit = luaK:getlabel(fs)
		local condexit = self:cond(ls)
		self:enterblock(fs, bl, true)
		self:checknext(ls, "TK_DO")
		self:block(ls)
		luaK:patchlist(fs, luaK:jump(fs), whileinit)
		self:check_match(ls, "TK_END", "TK_WHILE", line)
		self:leaveblock(fs)
		luaK:patchtohere(fs, condexit)
	end
	function luaY:repeatstat(ls, line)
		local fs = ls.fs
		local repeat_init = luaK:getlabel(fs)
		local bl1, bl2 = {}, {}
		self:enterblock(fs, bl1, true)
		self:enterblock(fs, bl2, false)
		luaX:next(ls)
		self:chunk(ls)
		self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
		local condexit = self:cond(ls)
		if not bl2.upval then
			self:leaveblock(fs)
			luaK:patchlist(ls.fs, condexit, repeat_init)
		else
			self:breakstat(ls)
			luaK:patchtohere(ls.fs, condexit)
			self:leaveblock(fs)
			luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)
		end
		self:leaveblock(fs)
	end
	function luaY:exp1(ls)
		local e = {}
		self:expr(ls, e)
		local k = e.k
		luaK:exp2nextreg(ls.fs, e)
		return k
	end
	function luaY:forbody(ls, base, line, nvars, isnum)
		local bl = {}
		local fs = ls.fs
		self:adjustlocalvars(ls, 3)
		self:checknext(ls, "TK_DO")
		local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP) or luaK:jump(fs)
		self:enterblock(fs, bl, false)
		self:adjustlocalvars(ls, nvars)
		luaK:reserveregs(fs, nvars)
		self:block(ls)
		self:leaveblock(fs)
		luaK:patchtohere(fs, prep)
		local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
			or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
		luaK:fixline(fs, line)
		luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
	end
	function luaY:fornum(ls, varname, line)
		local fs = ls.fs
		local base = fs.freereg
		self:new_localvarliteral(ls, "(for index)", 0)
		self:new_localvarliteral(ls, "(for limit)", 1)
		self:new_localvarliteral(ls, "(for step)", 2)
		self:new_localvar(ls, varname, 3)
		self:checknext(ls, "=")
		self:exp1(ls)
		self:checknext(ls, ",")
		self:exp1(ls)
		if self:testnext(ls, ",") then
			self:exp1(ls)
		else
			luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
			luaK:reserveregs(fs, 1)
		end
		self:forbody(ls, base, line, 1, true)
	end
	function luaY:forlist(ls, indexname)
		local fs = ls.fs
		local e = {}
		local nvars = 0
		local base = fs.freereg
		self:new_localvarliteral(ls, "(for generator)", nvars)
		nvars = nvars + 1
		self:new_localvarliteral(ls, "(for state)", nvars)
		nvars = nvars + 1
		self:new_localvarliteral(ls, "(for control)", nvars)
		nvars = nvars + 1
		self:new_localvar(ls, indexname, nvars)
		nvars = nvars + 1
		while self:testnext(ls, ",") do
			self:new_localvar(ls, self:str_checkname(ls), nvars)
			nvars = nvars + 1
		end
		self:checknext(ls, "TK_IN")
		local line = ls.linenumber
		self:adjust_assign(ls, 3, self:explist1(ls, e), e)
		luaK:checkstack(fs, 3)
		self:forbody(ls, base, line, nvars - 3, false)
	end
	function luaY:forstat(ls, line)
		local fs = ls.fs
		local bl = {}
		self:enterblock(fs, bl, true)
		luaX:next(ls)
		local varname = self:str_checkname(ls)
		local c = ls.t.token
		if c == "=" then
			self:fornum(ls, varname, line)
		elseif c == "," or c == "TK_IN" then
			self:forlist(ls, varname)
		else
			luaX:syntaxerror(ls, self:LUA_QL("=") .. " or " .. self:LUA_QL("in") .. " expected")
		end
		self:check_match(ls, "TK_END", "TK_FOR", line)
		self:leaveblock(fs)
	end
	function luaY:test_then_block(ls)
		luaX:next(ls)
		local condexit = self:cond(ls)
		self:checknext(ls, "TK_THEN")
		self:block(ls)
		return condexit
	end
	function luaY:ifstat(ls, line)
		local fs = ls.fs
		local escapelist = luaK.NO_JUMP
		local flist = self:test_then_block(ls)
		while ls.t.token == "TK_ELSEIF" do
			escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
			luaK:patchtohere(fs, flist)
			flist = self:test_then_block(ls)
		end
		if ls.t.token == "TK_ELSE" then
			escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
			luaK:patchtohere(fs, flist)
			luaX:next(ls)
			self:block(ls)
		else
			escapelist = luaK:concat(fs, escapelist, flist)
		end
		luaK:patchtohere(fs, escapelist)
		self:check_match(ls, "TK_END", "TK_IF", line)
	end
	function luaY:localfunc(ls)
		local v, b = {}, {}
		local fs = ls.fs
		self:new_localvar(ls, self:str_checkname(ls), 0)
		self:init_exp(v, "VLOCAL", fs.freereg)
		luaK:reserveregs(fs, 1)
		self:adjustlocalvars(ls, 1)
		self:body(ls, b, false, ls.linenumber)
		luaK:storevar(fs, v, b)
		self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
	end
	function luaY:localstat(ls)
		local nvars = 0
		local nexps
		local e = {}
		repeat
			self:new_localvar(ls, self:str_checkname(ls), nvars)
			nvars = nvars + 1
		until not self:testnext(ls, ",")
		if self:testnext(ls, "=") then
			nexps = self:explist1(ls, e)
		else
			e.k = "VVOID"
			nexps = 0
		end
		self:adjust_assign(ls, nvars, nexps, e)
		self:adjustlocalvars(ls, nvars)
	end
	function luaY:funcname(ls, v)
		local needself = false
		self:singlevar(ls, v)
		while ls.t.token == "." do
			self:field(ls, v)
		end
		if ls.t.token == ":" then
			needself = true
			self:field(ls, v)
		end
		return needself
	end
	function luaY:funcstat(ls, line)
		local v, b = {}, {}
		luaX:next(ls)
		local needself = self:funcname(ls, v)
		self:body(ls, b, needself, line)
		luaK:storevar(ls.fs, v, b)
		luaK:fixline(ls.fs, line)
	end
	function luaY:exprstat(ls)
		local fs = ls.fs
		local v = {}
		v.v = {}
		self:primaryexp(ls, v.v)
		if v.v.k == "VCALL" then
			luaP:SETARG_C(luaK:getcode(fs, v.v), 1)
		else
			v.prev = nil
			self:assignment(ls, v, 1)
		end
	end
	function luaY:retstat(ls)
		local fs = ls.fs
		local e = {}
		local first, nret
		luaX:next(ls)
		if self:block_follow(ls.t.token) or ls.t.token == ";" then
			first, nret = 0, 0
		else
			nret = self:explist1(ls, e)
			if self:hasmultret(e.k) then
				luaK:setmultret(fs, e)
				if e.k == "VCALL" and nret == 1 then
					luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
					lua_assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
				end
				first = fs.nactvar
				nret = self.LUA_MULTRET
			else
				if nret == 1 then
					first = luaK:exp2anyreg(fs, e)
				else
					luaK:exp2nextreg(fs, e)
					first = fs.nactvar
					lua_assert(nret == fs.freereg - first)
				end
			end
		end
		luaK:ret(fs, first, nret)
	end
	function luaY:statement(ls)
		local line = ls.linenumber
		local c = ls.t.token
		if c == "TK_IF" then
			self:ifstat(ls, line)
			return false
		elseif c == "TK_WHILE" then
			self:whilestat(ls, line)
			return false
		elseif c == "TK_DO" then
			luaX:next(ls)
			self:block(ls)
			self:check_match(ls, "TK_END", "TK_DO", line)
			return false
		elseif c == "TK_FOR" then
			self:forstat(ls, line)
			return false
		elseif c == "TK_REPEAT" then
			self:repeatstat(ls, line)
			return false
		elseif c == "TK_FUNCTION" then
			self:funcstat(ls, line)
			return false
		elseif c == "TK_LOCAL" then
			luaX:next(ls)
			if self:testnext(ls, "TK_FUNCTION") then
				self:localfunc(ls)
			else
				self:localstat(ls)
			end
			return false
		elseif c == "TK_RETURN" then
			self:retstat(ls)
			return true
		elseif c == "TK_BREAK" then
			luaX:next(ls)
			self:breakstat(ls)
			return true
		else
			self:exprstat(ls)
			return false
		end
	end
	function luaY:chunk(ls)
		local islast = false
		self:enterlevel(ls)
		while not islast and not self:block_follow(ls.t.token) do
			islast = self:statement(ls)
			self:testnext(ls, ";")
			lua_assert(ls.fs.f.maxstacksize >= ls.fs.freereg and ls.fs.freereg >= ls.fs.nactvar)
			ls.fs.freereg = ls.fs.nactvar
		end
		self:leavelevel(ls)
	end
	luaX:init()
	local LuaState = {}
	compile = function(source, name_)
		name = name_ or "compiled-lua"
		local zio = luaZ:init(luaZ:make_getF(source), nil)
		if not zio then
			return
		end
		local func = luaY:parser(LuaState, zio, nil, "@" .. name)
		local writer, buff = luaU:make_setS()
		luaU:dump(LuaState, func, writer, buff)
		return buff.data
	end
end
local createExecutable
do
	local lua_wrap_state
	local stm_lua_func
	local FIELDS_PER_FLUSH = 50
	local OPCODE_RM = {
		[22] = 18,
		[31] = 8,
		[33] = 28,
		[0] = 3,
		[1] = 13,
		[2] = 23,
		[26] = 33,
		[12] = 1,
		[13] = 6,
		[14] = 10,
		[15] = 16,
		[16] = 20,
		[17] = 26,
		[18] = 30,
		[19] = 36,
		[3] = 0,
		[4] = 2,
		[5] = 4,
		[6] = 7,
		[7] = 9,
		[8] = 12,
		[9] = 14,
		[10] = 17,
		[20] = 19,
		[21] = 22,
		[23] = 24,
		[24] = 27,
		[25] = 29,
		[27] = 32,
		[32] = 34,
		[34] = 37,
		[11] = 5,
		[28] = 11,
		[29] = 15,
		[30] = 21,
		[35] = 25,
		[36] = 31,
		[37] = 35,
	}
	local OPCODE_T = {
		[0] = "ABC",
		"ABx",
		"ABC",
		"ABC",
		"ABC",
		"ABx",
		"ABC",
		"ABx",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"AsBx",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"AsBx",
		"AsBx",
		"ABC",
		"ABC",
		"ABC",
		"ABx",
		"ABC",
	}
	local OPCODE_M = {
		[0] = { b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgR" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgR", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgN", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgN", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
	}
	local function rd_int_basic(src, s, e, d)
		local num = 0
		for i = s, e, d do
			local mul = 256 ^ math.abs(i - s)
			num = num + mul * string.byte(src, i, i)
		end
		return num
	end
	local function rd_flt_basic(f1, f2, f3, f4)
		local sign = (-1) ^ bit32.rshift(f4, 7)
		local exp = bit32.rshift(f3, 7) + bit32.lshift(bit32.band(f4, 0x7F), 1)
		local frac = f1 + bit32.lshift(f2, 8) + bit32.lshift(bit32.band(f3, 0x7F), 16)
		local normal = 1
		if exp == 0 then
			if frac == 0 then
				return sign * 0
			else
				normal = 0
				exp = 1
			end
		elseif exp == 0x7F then
			if frac == 0 then
				return sign * (1 / 0)
			else
				return sign * (0 / 0)
			end
		end
		return sign * 2 ^ (exp - 127) * (1 + normal / 2 ^ 23)
	end
	local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
		local sign = (-1) ^ bit32.rshift(f8, 7)
		local exp = bit32.lshift(bit32.band(f8, 0x7F), 4) + bit32.rshift(f7, 4)
		local frac = bit32.band(f7, 0x0F) * 2 ^ 48
		local normal = 1
		frac = frac + (f6 * 2 ^ 40) + (f5 * 2 ^ 32) + (f4 * 2 ^ 24) + (f3 * 2 ^ 16) + (f2 * 2 ^ 8) + f1
		if exp == 0 then
			if frac == 0 then
				return sign * 0
			else
				normal = 0
				exp = 1
			end
		elseif exp == 0x7FF then
			if frac == 0 then
				return sign * (1 / 0)
			else
				return sign * (0 / 0)
			end
		end
		return sign * 2 ^ (exp - 1023) * (normal + frac / 2 ^ 52)
	end
	local function rd_int_le(src, s, e)
		return rd_int_basic(src, s, e - 1, 1)
	end
	local function rd_int_be(src, s, e)
		return rd_int_basic(src, e - 1, s, -1)
	end
	local function rd_flt_le(src, s)
		return rd_flt_basic(string.byte(src, s, s + 3))
	end
	local function rd_flt_be(src, s)
		local f1, f2, f3, f4 = string.byte(src, s, s + 3)
		return rd_flt_basic(f4, f3, f2, f1)
	end
	local function rd_dbl_le(src, s)
		return rd_dbl_basic(string.byte(src, s, s + 7))
	end
	local function rd_dbl_be(src, s)
		local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7)
		return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1)
	end
	local float_types = {
		[4] = { little = rd_flt_le, big = rd_flt_be },
		[8] = { little = rd_dbl_le, big = rd_dbl_be },
	}
	local function stm_byte(S)
		local idx = S.index
		local bt = string.byte(S.source, idx, idx)
		S.index = idx + 1
		return bt
	end
	local function stm_string(S, len)
		local pos = S.index + len
		local str = string.sub(S.source, S.index, pos - 1)
		S.index = pos
		return str
	end
	local function stm_lstring(S)
		local len = S:s_szt()
		local str
		if len ~= 0 then
			str = string.sub(stm_string(S, len), 1, -2)
		end
		return str
	end
	local function cst_int_rdr(len, func)
		return function(S)
			local pos = S.index + len
			local int = func(S.source, S.index, pos)
			S.index = pos
			return int
		end
	end
	local function cst_flt_rdr(len, func)
		return function(S)
			local flt = func(S.source, S.index)
			S.index = S.index + len
			return flt
		end
	end
	local function stm_inst_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			local ins = S:s_ins()
			local op = bit32.band(ins, 0x3F)
			local args = OPCODE_T[op]
			local mode = OPCODE_M[op]
			local data = { value = ins, op = OPCODE_RM[op], A = bit32.band(bit32.rshift(ins, 6), 0xFF) }
			if args == "ABC" then
				data.B = bit32.band(bit32.rshift(ins, 23), 0x1FF)
				data.C = bit32.band(bit32.rshift(ins, 14), 0x1FF)
				data.is_KB = mode.b == "OpArgK" and data.B > 0xFF
				data.is_KC = mode.c == "OpArgK" and data.C > 0xFF
			elseif args == "ABx" then
				data.Bx = bit32.band(bit32.rshift(ins, 14), 0x3FFFF)
				data.is_K = mode.b == "OpArgK"
			elseif args == "AsBx" then
				data.sBx = bit32.band(bit32.rshift(ins, 14), 0x3FFFF) - 131071
			end
			list[i] = data
		end
		return list
	end
	local function stm_const_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			local tt = stm_byte(S)
			local k
			if tt == 1 then
				k = stm_byte(S) ~= 0
			elseif tt == 3 then
				k = S:s_num()
			elseif tt == 4 then
				k = stm_lstring(S)
			end
			list[i] = k
		end
		return list
	end
	local function stm_sub_list(S, src)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = stm_lua_func(S, src)
		end
		return list
	end
	local function stm_line_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = S:s_int()
		end
		return list
	end
	local function stm_loc_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = { varname = stm_lstring(S), startpc = S:s_int(), endpc = S:s_int() }
		end
		return list
	end
	local function stm_upval_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = stm_lstring(S)
		end
		return list
	end
	function stm_lua_func(S, psrc)
		local proto = {}
		local src = stm_lstring(S) or psrc
		proto.source = src
		S:s_int()
		S:s_int()
		proto.num_upval = stm_byte(S)
		proto.num_param = stm_byte(S)
		stm_byte(S)
		proto.max_stack = stm_byte(S)
		proto.code = stm_inst_list(S)
		proto.const = stm_const_list(S)
		proto.subs = stm_sub_list(S, src)
		proto.lines = stm_line_list(S)
		stm_loc_list(S)
		stm_upval_list(S)
		for _, v in ipairs(proto.code) do
			if v.is_K then
				v.const = proto.const[v.Bx + 1]
			else
				if v.is_KB then
					v.const_B = proto.const[v.B - 0xFF]
				end
				if v.is_KC then
					v.const_C = proto.const[v.C - 0xFF]
				end
			end
		end
		return proto
	end
	local function lua_bc_to_state(src)
		local rdr_func
		local little
		local size_int
		local size_szt
		local size_ins
		local size_num
		local flag_int
		local stream = {
			index = 1,
			source = src,
		}
		assert(stm_string(stream, 4) == "\27Lua", "invalid Lua signature")
		assert(stm_byte(stream) == 0x51, "invalid Lua version")
		assert(stm_byte(stream) == 0, "invalid Lua format")
		little = stm_byte(stream) ~= 0
		size_int = stm_byte(stream)
		size_szt = stm_byte(stream)
		size_ins = stm_byte(stream)
		size_num = stm_byte(stream)
		flag_int = stm_byte(stream) ~= 0
		rdr_func = little and rd_int_le or rd_int_be
		stream.s_int = cst_int_rdr(size_int, rdr_func)
		stream.s_szt = cst_int_rdr(size_szt, rdr_func)
		stream.s_ins = cst_int_rdr(size_ins, rdr_func)
		if flag_int then
			stream.s_num = cst_int_rdr(size_num, rdr_func)
		elseif float_types[size_num] then
			stream.s_num = cst_flt_rdr(size_num, float_types[size_num][little and "little" or "big"])
		else
			error("unsupported float size")
		end
		return stm_lua_func(stream, "@virtual")
	end
	local function close_lua_upvalues(list, index)
		for i, uv in pairs(list) do
			if uv.index >= index then
				uv.value = uv.store[uv.index]
				uv.store = uv
				uv.index = "value"
				list[i] = nil
			end
		end
	end
	local function open_lua_upvalue(list, index, memory)
		local prev = list[index]
		if not prev then
			prev = { index = index, store = memory }
			list[index] = prev
		end
		return prev
	end
	local function on_lua_error(failed, err)
		local src = failed.source
		local line = failed.lines[failed.pc - 1]
		error(string.format("%s:%i: %s", src, line, err), 0)
	end
	local function run_lua_func(state, env, upvals)
		local code = state.code
		local subs = state.subs
		local vararg = state.vararg
		local top_index = -1
		local open_list = {}
		local memory = state.memory
		local pc = state.pc
		while true do
			local inst = code[pc]
			local op = inst.op
			pc = pc + 1
			if op < 18 then
				if op < 8 then
					if op < 3 then
						if op < 1 then
							for i = inst.A, inst.B do
								memory[i] = nil
							end
						elseif op > 1 then
							local uv = upvals[inst.B]
							memory[inst.A] = uv.store[uv.index]
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs + rhs
						end
					elseif op > 3 then
						if op < 6 then
							if op > 4 then
								local A = inst.A
								local B = inst.B
								local index
								if inst.is_KC then
									index = inst.const_C
								else
									index = memory[inst.C]
								end
								memory[A + 1] = memory[B]
								memory[A] = memory[B][index]
							else
								memory[inst.A] = env[inst.const]
							end
						elseif op > 6 then
							local index
							if inst.is_KC then
								index = inst.const_C
							else
								index = memory[inst.C]
							end
							memory[inst.A] = memory[inst.B][index]
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs - rhs
						end
					else
						memory[inst.A] = memory[inst.B]
					end
				elseif op > 8 then
					if op < 13 then
						if op < 10 then
							env[inst.const] = memory[inst.A]
						elseif op > 10 then
							if op < 12 then
								local A = inst.A
								local B = inst.B
								local C = inst.C
								local params
								if B == 0 then
									params = top_index - A
								else
									params = B - 1
								end
								local ret_list = table.pack(memory[A](table.unpack(memory, A + 1, A + params)))
								local ret_num = ret_list.n
								if C == 0 then
									top_index = A + ret_num - 1
								else
									ret_num = C - 1
								end
								table.move(ret_list, 1, ret_num, A, memory)
							else
								local uv = upvals[inst.B]
								uv.store[uv.index] = memory[inst.A]
							end
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs * rhs
						end
					elseif op > 13 then
						if op < 16 then
							if op > 14 then
								local A = inst.A
								local B = inst.B
								local params
								if B == 0 then
									params = top_index - A
								else
									params = B - 1
								end
								close_lua_upvalues(open_list, 0)
								return memory[A](table.unpack(memory, A + 1, A + params))
							else
								local index, value
								if inst.is_KB then
									index = inst.const_B
								else
									index = memory[inst.B]
								end
								if inst.is_KC then
									value = inst.const_C
								else
									value = memory[inst.C]
								end
								memory[inst.A][index] = value
							end
						elseif op > 16 then
							memory[inst.A] = {}
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs / rhs
						end
					else
						memory[inst.A] = inst.const
					end
				else
					local A = inst.A
					local step = memory[A + 2]
					local index = memory[A] + step
					local limit = memory[A + 1]
					local loops
					if step == math.abs(step) then
						loops = index <= limit
					else
						loops = index >= limit
					end
					if loops then
						memory[A] = index
						memory[A + 3] = index
						pc = pc + inst.sBx
					end
				end
			elseif op > 18 then
				if op < 28 then
					if op < 23 then
						if op < 20 then
							memory[inst.A] = #memory[inst.B]
						elseif op > 20 then
							if op < 22 then
								local A = inst.A
								local B = inst.B
								local len
								if B == 0 then
									len = top_index - A + 1
								else
									len = B - 1
								end
								close_lua_upvalues(open_list, 0)
								return table.unpack(memory, A, A + len - 1)
							else
								local B = inst.B
								local str = memory[B]
								for i = B + 1, inst.C do
									str = str .. memory[i]
								end
								memory[inst.A] = str
							end
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs % rhs
						end
					elseif op > 23 then
						if op < 26 then
							if op > 24 then
								close_lua_upvalues(open_list, inst.A)
							else
								local lhs, rhs
								if inst.is_KB then
									lhs = inst.const_B
								else
									lhs = memory[inst.B]
								end
								if inst.is_KC then
									rhs = inst.const_C
								else
									rhs = memory[inst.C]
								end
								if (lhs == rhs) == (inst.A ~= 0) then
									pc = pc + code[pc].sBx
								end
								pc = pc + 1
							end
						elseif op > 26 then
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							if (lhs < rhs) == (inst.A ~= 0) then
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs ^ rhs
						end
					else
						memory[inst.A] = inst.B ~= 0
						if inst.C ~= 0 then
							pc = pc + 1
						end
					end
				elseif op > 28 then
					if op < 33 then
						if op < 30 then
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							if (lhs <= rhs) == (inst.A ~= 0) then
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						elseif op > 30 then
							if op < 32 then
								local sub = subs[inst.Bx + 1]
								local nups = sub.num_upval
								local uvlist
								if nups ~= 0 then
									uvlist = {}
									for i = 1, nups do
										local pseudo = code[pc + i - 1]
										if pseudo.op == OPCODE_RM[0] then
											uvlist[i - 1] = open_lua_upvalue(open_list, pseudo.B, memory)
										elseif pseudo.op == OPCODE_RM[4] then
											uvlist[i - 1] = upvals[pseudo.B]
										end
									end
									pc = pc + nups
								end
								memory[inst.A] = lua_wrap_state(sub, env, uvlist)
							else
								local A = inst.A
								local B = inst.B
								if (not memory[B]) ~= (inst.C ~= 0) then
									memory[A] = memory[B]
									pc = pc + code[pc].sBx
								end
								pc = pc + 1
							end
						else
							memory[inst.A] = -memory[inst.B]
						end
					elseif op > 33 then
						if op < 36 then
							if op > 34 then
								local A = inst.A
								local len = inst.B
								if len == 0 then
									len = vararg.len
									top_index = A + len - 1
								end
								table.move(vararg.list, 1, len, A, memory)
							else
								local A = inst.A
								local init, limit, step
								init = assert(tonumber(memory[A]), "`for` initial value must be a number")
								limit = assert(tonumber(memory[A + 1]), "`for` limit must be a number")
								step = assert(tonumber(memory[A + 2]), "`for` step must be a number")
								memory[A] = init - step
								memory[A + 1] = limit
								memory[A + 2] = step
								pc = pc + inst.sBx
							end
						elseif op > 36 then
							local A = inst.A
							local C = inst.C
							local len = inst.B
							local tab = memory[A]
							local offset
							if len == 0 then
								len = top_index - A
							end
							if C == 0 then
								C = inst[pc].value
								pc = pc + 1
							end
							offset = (C - 1) * FIELDS_PER_FLUSH
							table.move(memory, A + 1, A + len, offset + 1, tab)
						else
							memory[inst.A] = not memory[inst.B]
						end
					else
						if (not memory[inst.A]) ~= (inst.C ~= 0) then
							pc = pc + code[pc].sBx
						end
						pc = pc + 1
					end
				else
					local A = inst.A
					local base = A + 3
					local vals = { memory[A](memory[A + 1], memory[A + 2]) }
					table.move(vals, 1, inst.C, base, memory)
					if memory[base] ~= nil then
						memory[A + 2] = memory[base]
						pc = pc + code[pc].sBx
					end
					pc = pc + 1
				end
			else
				pc = pc + inst.sBx
			end
			state.pc = pc
		end
	end
	function lua_wrap_state(proto, env, upval)
		local function wrapped(...)
			local passed = table.pack(...)
			local memory = table.create(proto.max_stack)
			local vararg = { len = 0, list = {} }
			table.move(passed, 1, proto.num_param, 0, memory)
			if proto.num_param < passed.n then
				local start = proto.num_param + 1
				local len = passed.n - proto.num_param
				vararg.len = len
				table.move(passed, start, start + len - 1, 1, vararg.list)
			end
			local state = { vararg = vararg, memory = memory, code = proto.code, subs = proto.subs, pc = 1 }
			local result = table.pack(pcall(run_lua_func, state, env, upval))
			if result[1] then
				return table.unpack(result, 2, result.n)
			else
				local failed = { pc = state.pc, source = proto.source, lines = proto.lines }
				on_lua_error(failed, result[2])
				return
			end
		end
		return wrapped
	end
	createExecutable = function(bCode, env)
		return lua_wrap_state(lua_bc_to_state(bCode), env or getfenv(0))
	end
end
getfenv().script = nil

return setmetatable({},{__metatable={"Protected metatable"},__call=function(self,source,abc)
	local executable
	for i,v in getfenv(2) do 
		getfenv(1)[i] = v
	end
	local env = getfenv(1)
	local name = (env.script and env.script:GetFullName())
	local ran, failureReason = pcall(function()
		local compiledBytecode = compile(source, name)
		executable = createExecutable(compiledBytecode, env)
	end)

	if ran then
		return setmetatable({},{__metatable="protected loadstring",__call=function(self,fenv)
			if typeof(fenv) == "table" then for i,v in fenv do env[i] = v end end
			return setfenv(executable, env)()
		end})
	end
	return nil, failureReason
end,})]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX28556BEFE71C4A64BF8A1C8C289BCD91">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">core</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXAB228D5671CD4B42BCEDAC172566C261">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ScriptRunner</string>
					<string name="ScriptGuid">{52A22D55-E793-4699-B78D-C533AB58CA69}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}
local rem = nil
local err = error
--local loader = require(script.Parent.Loader)
local error = function(...)
	local args = table.pack(...)
	local whatfunction = args[1]
	table.remove(args,1)
	task.defer(err,`OwOLoader.{script.Parent.Name}.{script.Name}:{whatfunction}:: {table.unpack(args)}`) return 
end

function module:NFL_setremote(rem2) 
	rem = rem2
end

function module:Client(env:Table,source:string|Table,Player:Player|"All")
	local whatfunction = "client"
	if typeof(env) ~= "table" then 
		error(whatfunction,"Argument 1 (ENV) is not a table") 
	elseif typeof(source) ~= "string" and typeof(source) ~= "table" then
		error(whatfunction,"Argument 2 (SOURCE) is not a table or string")
	elseif typeof(Player) ~= "Instance" and Player ~= "All" then
		error(whatfunction,"Argument 3 (PLAYER) is not a Instance or string")
	elseif typeof(Player)	== "Instance" and not Player:IsA("Player") then
		error(whatfunction,"Argument 3 (PLAYER) is not a Player")
	end
	
	if Player == "All" then
		
		
		for i,v in game:GetService("Players"):GetPlayers() do 
			task.spawn(function()
				--loader:WaitForLoad(v,60)
				rem:InvokeClient(v,{"PermRun",env,source})
			end)
		end
	
	else
		rem:InvokeClient(Player,{"PermRun",env,source})
	end
	
	end

function module:Server(env:Table,source:string|Table)
	local whatfunction = "server"
	if typeof(env) ~= "table" then 
		error(whatfunction,"Argument 1 (ENV) is not a table") 
	elseif typeof(source) ~= "string" and typeof(source) ~= "table" then
		error(whatfunction,"Argument 2 (SOURCE) is not a table or string")
	end
	require(script.compiler:Clone())(env,source)()
end


return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXB772CCEEDA5B4CE5A7EFEADAACFDFC7C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">compiler</string>
						<string name="ScriptGuid">{E860D56A-A463-4A92-8880-70DA0BA37A30}</string>
						<ProtectedString name="Source"><![CDATA[local moduleload = false
local function compile(sfenv,source, additionalEnv, ...)
	if moduleload then
		for i,v in sfenv do 
			getfenv(2)[i] = v
		end
	end

	local compiled = loadstring(source)
	
	if compiled == nil then
		warn("source is none or source got error")
		local s,err = pcall(function()
			loadstring(source)()
		end)
		warn(`Debug>> {err}`)
		return nil
	end
	
	if not moduleload then
		local fenv = getfenv(compiled)
		for i,v in sfenv do 
			fenv[i] = v
		end
		
		setfenv(compiled, fenv)
	end
	
	return compiled
end

return function(fenv,scriptt)
	if not pcall(loadstring, "--") then
		warn("Loadstring set on custom")
		getfenv().loadstring = require(script.b)
		moduleload = true
	end
	local sandbox
	if typeof(scriptt) == "table" then
		sandbox = compile(fenv,table.concat(scriptt,"\n"))
	else
		sandbox = compile(fenv,scriptt)
	end

	return sandbox
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX9921BDE1E4E849219EE18836E42B1274">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">b</string>
							<string name="ScriptGuid">{7D6568F2-0B5C-4942-AB79-EB2CA22ACD63}</string>
							<ProtectedString name="Source"><![CDATA[local compile
do
	local name
	local luaZ = {}
	local luaY = {}
	local luaX = {}
	local luaP = {}
	local luaU = {}
	local luaK = {}
	local size_size_t = 8
	local function lua_assert(test)
		if not test then
			error("assertion failed!")
		end
	end
	function luaZ:make_getS(buff)
		local b = buff
		return function()
			if not b then
				return nil
			end
			local data = b
			b = nil
			return data
		end
	end
	function luaZ:make_getF(source)
		local LUAL_BUFFERSIZE = 512
		local pos = 1
		return function()
			local buff = source:sub(pos, pos + LUAL_BUFFERSIZE - 1)
			pos = math.min(#source + 1, pos + LUAL_BUFFERSIZE)
			return buff
		end
	end
	function luaZ:init(reader, data)
		if not reader then
			return
		end
		local z = {}
		z.reader = reader
		z.data = data or ""
		z.name = name
		if not data or data == "" then
			z.n = 0
		else
			z.n = #data
		end
		z.p = 0
		return z
	end
	function luaZ:fill(z)
		local buff = z.reader()
		z.data = buff
		if not buff or buff == "" then
			return "EOZ"
		end
		z.n, z.p = #buff - 1, 1
		return string.sub(buff, 1, 1)
	end
	function luaZ:zgetc(z)
		local n, p = z.n, z.p + 1
		if n > 0 then
			z.n, z.p = n - 1, p
			return string.sub(z.data, p, p)
		else
			return self:fill(z)
		end
	end
	luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]
	luaX.MAXSRC = 80
	luaX.MAX_INT = 2147483645
	luaX.LUA_QS = "'%s'"
	luaX.LUA_COMPAT_LSTR = 1
	function luaX:init()
		local tokens, enums = {}, {}
		for v in string.gmatch(self.RESERVED, "[^\n]+") do
			local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)")
			tokens[tok] = str
			enums[str] = tok
		end
		self.tokens = tokens
		self.enums = enums
	end
	function luaX:chunkid(source, bufflen)
		local out
		local first = string.sub(source, 1, 1)
		if first == "=" then
			out = string.sub(source, 2, bufflen)
		else
			if first == "@" then
				source = string.sub(source, 2)
				bufflen = bufflen - #" '...' "
				local l = #source
				out = ""
				if l > bufflen then
					source = string.sub(source, 1 + l - bufflen)
					out = out .. "..."
				end
				out = out .. source
			else
				local len = string.find(source, "[\n\r]")
				len = len and (len - 1) or #source
				bufflen = bufflen - #' [string "..."] '
				if len > bufflen then
					len = bufflen
				end
				out = '[string "'
				if len < #source then
					out = out .. string.sub(source, 1, len) .. "..."
				else
					out = out .. source
				end
				out = out .. '"]'
			end
		end
		return out
	end
	function luaX:token2str(_, token)
		if string.sub(token, 1, 3) ~= "TK_" then
			if string.find(token, "%c") then
				return string.format("char(%d)", string.byte(token))
			end
			return token
		else
			return self.tokens[token]
		end
	end
	function luaX:lexerror(ls, msg, token)
		local function txtToken(ls, token)
			if token == "TK_NAME" or token == "TK_STRING" or token == "TK_NUMBER" then
				return ls.buff
			else
				return self:token2str(ls, token)
			end
		end
		local buff = self:chunkid(ls.source, self.MAXSRC)
		local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg)
		if token then
			msg = string.format("%s near " .. self.LUA_QS, msg, txtToken(ls, token))
		end
		error(msg)
	end
	function luaX:syntaxerror(ls, msg)
		self:lexerror(ls, msg, ls.t.token)
	end
	function luaX:currIsNewline(ls)
		return ls.current == "\n" or ls.current == "\r"
	end
	function luaX:inclinenumber(ls)
		local old = ls.current
		self:nextc(ls)
		if self:currIsNewline(ls) and ls.current ~= old then
			self:nextc(ls)
		end
		ls.linenumber = ls.linenumber + 1
		if ls.linenumber >= self.MAX_INT then
			self:syntaxerror(ls, "chunk has too many lines")
		end
	end
	function luaX:setinput(L, ls, z, source)
		if not ls then
			ls = {}
		end
		if not ls.lookahead then
			ls.lookahead = {}
		end
		if not ls.t then
			ls.t = {}
		end
		ls.decpoint = "."
		ls.L = L
		ls.lookahead.token = "TK_EOS"
		ls.z = z
		ls.fs = nil
		ls.linenumber = 1
		ls.lastline = 1
		ls.source = source
		self:nextc(ls)
	end
	function luaX:check_next(ls, set)
		if not string.find(set, ls.current, 1, 1) then
			return false
		end
		self:save_and_next(ls)
		return true
	end
	function luaX:next(ls)
		ls.lastline = ls.linenumber
		if ls.lookahead.token ~= "TK_EOS" then
			ls.t.seminfo = ls.lookahead.seminfo
			ls.t.token = ls.lookahead.token
			ls.lookahead.token = "TK_EOS"
		else
			ls.t.token = self:llex(ls, ls.t)
		end
	end
	function luaX:lookahead(ls)
		ls.lookahead.token = self:llex(ls, ls.lookahead)
	end
	function luaX:nextc(ls)
		local c = luaZ:zgetc(ls.z)
		ls.current = c
		return c
	end
	function luaX:save(ls, c)
		local buff = ls.buff
		ls.buff = buff .. c
	end
	function luaX:save_and_next(ls)
		self:save(ls, ls.current)
		return self:nextc(ls)
	end
	function luaX:str2d(s)
		local result = tonumber(s)
		if result then
			return result
		end
		if string.lower(string.sub(s, 1, 2)) == "0x" then
			result = tonumber(s, 16)
			if result then
				return result
			end
		end
		return nil
	end
	function luaX:buffreplace(ls, from, to)
		local result, buff = "", ls.buff
		for p = 1, #buff do
			local c = string.sub(buff, p, p)
			if c == from then
				c = to
			end
			result = result .. c
		end
		ls.buff = result
	end
	function luaX:trydecpoint(ls, Token)
		local old = ls.decpoint
		self:buffreplace(ls, old, ls.decpoint)
		local seminfo = self:str2d(ls.buff)
		Token.seminfo = seminfo
		if not seminfo then
			self:buffreplace(ls, ls.decpoint, ".")
			self:lexerror(ls, "malformed number", "TK_NUMBER")
		end
	end
	function luaX:read_numeral(ls, Token)
		repeat
			self:save_and_next(ls)
		until string.find(ls.current, "%D") and ls.current ~= "."
		if self:check_next(ls, "Ee") then
			self:check_next(ls, "+-")
		end
		while string.find(ls.current, "^%w$") or ls.current == "_" do
			self:save_and_next(ls)
		end
		self:buffreplace(ls, ".", ls.decpoint)
		local seminfo = self:str2d(ls.buff)
		Token.seminfo = seminfo
		if not seminfo then
			self:trydecpoint(ls, Token)
		end
	end
	function luaX:skip_sep(ls)
		local count = 0
		local s = ls.current
		self:save_and_next(ls)
		while ls.current == "=" do
			self:save_and_next(ls)
			count = count + 1
		end
		return (ls.current == s) and count or -count - 1
	end
	function luaX:read_long_string(ls, Token, sep)
		local cont = 0
		self:save_and_next(ls)
		if self:currIsNewline(ls) then
			self:inclinenumber(ls)
		end
		while true do
			local c = ls.current
			if c == "EOZ" then
				self:lexerror(ls, Token and "unfinished long string" or "unfinished long comment", "TK_EOS")
			elseif c == "[" then
				if self.LUA_COMPAT_LSTR then
					if self:skip_sep(ls) == sep then
						self:save_and_next(ls)
						cont = cont + 1
						if self.LUA_COMPAT_LSTR == 1 then
							if sep == 0 then
								self:lexerror(ls, "nesting of [[...]] is deprecated", "[")
							end
						end
					end
				end
			elseif c == "]" then
				if self:skip_sep(ls) == sep then
					self:save_and_next(ls)
					if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
						cont = cont - 1
						if sep == 0 and cont >= 0 then
							break
						end
					end
					break
				end
			elseif self:currIsNewline(ls) then
				self:save(ls, "\n")
				self:inclinenumber(ls)
				if not Token then
					ls.buff = ""
				end
			else
				if Token then
					self:save_and_next(ls)
				else
					self:nextc(ls)
				end
			end
		end
		if Token then
			local p = 3 + sep
			Token.seminfo = string.sub(ls.buff, p, -p)
		end
	end
	function luaX:read_string(ls, del, Token)
		self:save_and_next(ls)
		while ls.current ~= del do
			local c = ls.current
			if c == "EOZ" then
				self:lexerror(ls, "unfinished string", "TK_EOS")
			elseif self:currIsNewline(ls) then
				self:lexerror(ls, "unfinished string", "TK_STRING")
			elseif c == "\\" then
				c = self:nextc(ls)
				if self:currIsNewline(ls) then
					self:save(ls, "\n")
					self:inclinenumber(ls)
				elseif c ~= "EOZ" then
					local i = string.find("abfnrtv", c, 1, 1)
					if i then
						self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i))
						self:nextc(ls)
					elseif not string.find(c, "%d") then
						self:save_and_next(ls)
					else
						c, i = 0, 0
						repeat
							c = 10 * c + ls.current
							self:nextc(ls)
							i = i + 1
						until i >= 3 or not string.find(ls.current, "%d")
						if c > 255 then
							self:lexerror(ls, "escape sequence too large", "TK_STRING")
						end
						self:save(ls, string.char(c))
					end
				end
			else
				self:save_and_next(ls)
			end
		end
		self:save_and_next(ls)
		Token.seminfo = string.sub(ls.buff, 2, -2)
	end
	function luaX:llex(ls, Token)
		ls.buff = ""
		while true do
			local c = ls.current
			if self:currIsNewline(ls) then
				self:inclinenumber(ls)
			elseif c == "-" then
				c = self:nextc(ls)
				if c ~= "-" then
					return "-"
				end
				local sep = -1
				if self:nextc(ls) == "[" then
					sep = self:skip_sep(ls)
					ls.buff = ""
				end
				if sep >= 0 then
					self:read_long_string(ls, nil, sep)
					ls.buff = ""
				else
					while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
						self:nextc(ls)
					end
				end
			elseif c == "[" then
				local sep = self:skip_sep(ls)
				if sep >= 0 then
					self:read_long_string(ls, Token, sep)
					return "TK_STRING"
				elseif sep == -1 then
					return "["
				else
					self:lexerror(ls, "invalid long string delimiter", "TK_STRING")
				end
			elseif c == "=" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "="
				else
					self:nextc(ls)
					return "TK_EQ"
				end
			elseif c == "<" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "<"
				else
					self:nextc(ls)
					return "TK_LE"
				end
			elseif c == ">" then
				c = self:nextc(ls)
				if c ~= "=" then
					return ">"
				else
					self:nextc(ls)
					return "TK_GE"
				end
			elseif c == "~" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "~"
				else
					self:nextc(ls)
					return "TK_NE"
				end
			elseif c == '"' or c == "'" then
				self:read_string(ls, c, Token)
				return "TK_STRING"
			elseif c == "." then
				c = self:save_and_next(ls)
				if self:check_next(ls, ".") then
					if self:check_next(ls, ".") then
						return "TK_DOTS"
					else
						return "TK_CONCAT"
					end
				elseif not string.find(c, "%d") then
					return "."
				else
					self:read_numeral(ls, Token)
					return "TK_NUMBER"
				end
			elseif c == "EOZ" then
				return "TK_EOS"
			else
				if string.find(c, "%s") then
					self:nextc(ls)
				elseif string.find(c, "%d") then
					self:read_numeral(ls, Token)
					return "TK_NUMBER"
				elseif string.find(c, "[_%a]") then
					repeat
						c = self:save_and_next(ls)
					until c == "EOZ" or not string.find(c, "[_%w]")
					local ts = ls.buff
					local tok = self.enums[ts]
					if tok then
						return tok
					end
					Token.seminfo = ts
					return "TK_NAME"
				else
					self:nextc(ls)
					return c
				end
			end
		end
	end
	luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 }
	luaP.SIZE_C = 9
	luaP.SIZE_B = 9
	luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B
	luaP.SIZE_A = 8
	luaP.SIZE_OP = 6
	luaP.POS_OP = 0
	luaP.POS_A = luaP.POS_OP + luaP.SIZE_OP
	luaP.POS_C = luaP.POS_A + luaP.SIZE_A
	luaP.POS_B = luaP.POS_C + luaP.SIZE_C
	luaP.POS_Bx = luaP.POS_C
	luaP.MAXARG_Bx = math.ldexp(1, luaP.SIZE_Bx) - 1
	luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)
	luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1
	luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1
	luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1
	function luaP:GET_OPCODE(i)
		return self.ROpCode[i.OP]
	end
	function luaP:SET_OPCODE(i, o)
		i.OP = self.OpCode[o]
	end
	function luaP:GETARG_A(i)
		return i.A
	end
	function luaP:SETARG_A(i, u)
		i.A = u
	end
	function luaP:GETARG_B(i)
		return i.B
	end
	function luaP:SETARG_B(i, b)
		i.B = b
	end
	function luaP:GETARG_C(i)
		return i.C
	end
	function luaP:SETARG_C(i, b)
		i.C = b
	end
	function luaP:GETARG_Bx(i)
		return i.Bx
	end
	function luaP:SETARG_Bx(i, b)
		i.Bx = b
	end
	function luaP:GETARG_sBx(i)
		return i.Bx - self.MAXARG_sBx
	end
	function luaP:SETARG_sBx(i, b)
		i.Bx = b + self.MAXARG_sBx
	end
	function luaP:CREATE_ABC(o, a, b, c)
		return { OP = self.OpCode[o], A = a, B = b, C = c }
	end
	function luaP:CREATE_ABx(o, a, bc)
		return { OP = self.OpCode[o], A = a, Bx = bc }
	end
	function luaP:CREATE_Inst(c)
		local o = c % 64
		c = (c - o) / 64
		local a = c % 256
		c = (c - a) / 256
		return self:CREATE_ABx(o, a, c)
	end
	function luaP:Instruction(i)
		if i.Bx then
			i.C = i.Bx % 512
			i.B = (i.Bx - i.C) / 512
		end
		local I = i.A * 64 + i.OP
		local c0 = I % 256
		I = i.C * 64 + (I - c0) / 256
		local c1 = I % 256
		I = i.B * 128 + (I - c1) / 256
		local c2 = I % 256
		local c3 = (I - c2) / 256
		return string.char(c0, c1, c2, c3)
	end
	function luaP:DecodeInst(x)
		local byte = string.byte
		local i = {}
		local I = byte(x, 1)
		local op = I % 64
		i.OP = op
		I = byte(x, 2) * 4 + (I - op) / 64
		local a = I % 256
		i.A = a
		I = byte(x, 3) * 4 + (I - a) / 256
		local c = I % 512
		i.C = c
		i.B = byte(x, 4) * 2 + (I - c) / 512
		local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))]
		if opmode ~= "iABC" then
			i.Bx = i.B * 512 + i.C
		end
		return i
	end
	luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1)
	function luaP:ISK(x)
		return x >= self.BITRK
	end
	function luaP:INDEXK(r)
		return r - self.BITRK
	end
	luaP.MAXINDEXRK = luaP.BITRK - 1
	function luaP:RKASK(x)
		return x + self.BITRK
	end
	luaP.NO_REG = luaP.MAXARG_A
	luaP.opnames = {}
	luaP.OpCode = {}
	luaP.ROpCode = {}
	local i = 0
	for v in
		string.gmatch(
			[[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],
			"%S+"
		)
	do
		local n = "OP_" .. v
		luaP.opnames[i] = v
		luaP.OpCode[n] = i
		luaP.ROpCode[i] = n
		i = i + 1
	end
	luaP.NUM_OPCODES = i
	luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 }
	function luaP:getOpMode(m)
		return self.opmodes[self.OpCode[m]] % 4
	end
	function luaP:getBMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4
	end
	function luaP:getCMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4
	end
	function luaP:testAMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2
	end
	function luaP:testTMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 128)
	end
	luaP.LFIELDS_PER_FLUSH = 50
	local function opmode(t, a, b, c, m)
		local luaP = luaP
		return t * 128 + a * 64 + luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m]
	end
	luaP.opmodes = {
		opmode(0, 1, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgR", "OpArgK", "iABC"),
		opmode(0, 0, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 0, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgR", "iABC"),
		opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 1, "OpArgR", "OpArgU", "iABC"),
		opmode(1, 1, "OpArgR", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
		opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
		opmode(1, 0, "OpArgN", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgN", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABC"),
	}
	luaP.opmodes[0] = opmode(0, 1, "OpArgR", "OpArgN", "iABC")
	luaU.LUA_SIGNATURE = "\27Lua"
	luaU.LUA_TNUMBER = 3
	luaU.LUA_TSTRING = 4
	luaU.LUA_TNIL = 0
	luaU.LUA_TBOOLEAN = 1
	luaU.LUA_TNONE = -1
	luaU.LUAC_VERSION = 0x51
	luaU.LUAC_FORMAT = 0
	luaU.LUAC_HEADERSIZE = 12
	function luaU:make_setS()
		local buff = {}
		buff.data = ""
		local writer = function(s, buff)
			if not s then
				return 0
			end
			buff.data = buff.data .. s
			return 0
		end
		return writer, buff
	end
	function luaU:make_setF(filename)
		return nil
	end
	function luaU:ttype(o)
		local tt = type(o.value)
		if tt == "number" then
			return self.LUA_TNUMBER
		elseif tt == "string" then
			return self.LUA_TSTRING
		elseif tt == "nil" then
			return self.LUA_TNIL
		elseif tt == "boolean" then
			return self.LUA_TBOOLEAN
		else
			return self.LUA_TNONE
		end
	end
	function luaU:from_double(x)
		local function grab_byte(v)
			local c = v % 256
			return (v - c) / 256, string.char(c)
		end
		local sign = 0
		if x < 0 then
			sign = 1
			x = -x
		end
		local mantissa, exponent = math.frexp(x)
		if x == 0 then
			mantissa, exponent = 0, 0
		elseif x == 1 / 0 then
			mantissa, exponent = 0, 2047
		else
			mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
			exponent = exponent + 1022
		end
		local v, byte = "", nil
		x = math.floor(mantissa)
		for _ = 1, 6 do
			x, byte = grab_byte(x)
			v = v .. byte
		end
		x, byte = grab_byte(exponent * 16 + x)
		v = v .. byte
		x, byte = grab_byte(sign * 128 + x)
		v = v .. byte
		return v
	end
	function luaU:from_int(x)
		local v = ""
		x = math.floor(x)
		if x < 0 then
			x = 4294967296 + x
		end
		for _ = 1, 4 do
			local c = x % 256
			v = v .. string.char(c)
			x = math.floor(x / 256)
		end
		return v
	end
	function luaU:DumpBlock(b, D)
		if D.status == 0 then
			D.status = D.write(b, D.data)
		end
	end
	function luaU:DumpChar(y, D)
		self:DumpBlock(string.char(y), D)
	end
	function luaU:DumpInt(x, D)
		self:DumpBlock(self:from_int(x), D)
	end
	function luaU:DumpSizeT(x, D)
		self:DumpBlock(self:from_int(x), D)
		if size_size_t == 8 then
			self:DumpBlock(self:from_int(0), D)
		end
	end
	function luaU:DumpNumber(x, D)
		self:DumpBlock(self:from_double(x), D)
	end
	function luaU:DumpString(s, D)
		if s == nil then
			self:DumpSizeT(0, D)
		else
			s = s .. "\0"
			self:DumpSizeT(#s, D)
			self:DumpBlock(s, D)
		end
	end
	function luaU:DumpCode(f, D)
		local n = f.sizecode
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpBlock(luaP:Instruction(f.code[i]), D)
		end
	end
	function luaU:DumpConstants(f, D)
		local n = f.sizek
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			local o = f.k[i]
			local tt = self:ttype(o)
			self:DumpChar(tt, D)
			if tt == self.LUA_TNIL then
			elseif tt == self.LUA_TBOOLEAN then
				self:DumpChar(o.value and 1 or 0, D)
			elseif tt == self.LUA_TNUMBER then
				self:DumpNumber(o.value, D)
			elseif tt == self.LUA_TSTRING then
				self:DumpString(o.value, D)
			else
			end
		end
		n = f.sizep
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpFunction(f.p[i], f.source, D)
		end
	end
	function luaU:DumpDebug(f, D)
		local n
		n = D.strip and 0 or f.sizelineinfo
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpInt(f.lineinfo[i], D)
		end
		n = D.strip and 0 or f.sizelocvars
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpString(f.locvars[i].varname, D)
			self:DumpInt(f.locvars[i].startpc, D)
			self:DumpInt(f.locvars[i].endpc, D)
		end
		n = D.strip and 0 or f.sizeupvalues
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpString(f.upvalues[i], D)
		end
	end
	function luaU:DumpFunction(f, p, D)
		local source = f.source
		if source == p or D.strip then
			source = nil
		end
		self:DumpString(source, D)
		self:DumpInt(f.lineDefined, D)
		self:DumpInt(f.lastlinedefined, D)
		self:DumpChar(f.nups, D)
		self:DumpChar(f.numparams, D)
		self:DumpChar(f.is_vararg, D)
		self:DumpChar(f.maxstacksize, D)
		self:DumpCode(f, D)
		self:DumpConstants(f, D)
		self:DumpDebug(f, D)
	end
	function luaU:DumpHeader(D)
		local h = self:header()
		assert(#h == self.LUAC_HEADERSIZE)
		self:DumpBlock(h, D)
	end
	function luaU:header()
		local x = 1
		return self.LUA_SIGNATURE .. string.char(self.LUAC_VERSION, self.LUAC_FORMAT, x, 4, size_size_t, 4, 8, 0)
	end
	function luaU:dump(L, f, w, data, strip)
		local D = {}
		D.L = L
		D.write = w
		D.data = data
		D.strip = strip
		D.status = 0
		self:DumpHeader(D)
		self:DumpFunction(f, nil, D)
		D.write(nil, D.data)
		return D.status
	end
	luaK.MAXSTACK = 250
	function luaK:ttisnumber(o)
		if o then
			return type(o.value) == "number"
		else
			return false
		end
	end
	function luaK:nvalue(o)
		return o.value
	end
	function luaK:setnilvalue(o)
		o.value = nil
	end
	function luaK:setsvalue(o, x)
		o.value = x
	end
	luaK.setnvalue = luaK.setsvalue
	luaK.sethvalue = luaK.setsvalue
	luaK.setbvalue = luaK.setsvalue
	function luaK:numadd(a, b)
		return a + b
	end
	function luaK:numsub(a, b)
		return a - b
	end
	function luaK:nummul(a, b)
		return a * b
	end
	function luaK:numdiv(a, b)
		return a / b
	end
	function luaK:nummod(a, b)
		return a % b
	end
	function luaK:numpow(a, b)
		return a ^ b
	end
	function luaK:numunm(a)
		return -a
	end
	function luaK:numisnan(a)
		return a ~= a
	end
	luaK.NO_JUMP = -1
	luaK.BinOpr = {
		OPR_ADD = 0,
		OPR_SUB = 1,
		OPR_MUL = 2,
		OPR_DIV = 3,
		OPR_MOD = 4,
		OPR_POW = 5,
		OPR_CONCAT = 6,
		OPR_NE = 7,
		OPR_EQ = 8,
		OPR_LT = 9,
		OPR_LE = 10,
		OPR_GT = 11,
		OPR_GE = 12,
		OPR_AND = 13,
		OPR_OR = 14,
		OPR_NOBINOPR = 15,
	}
	luaK.UnOpr = {
		OPR_MINUS = 0,
		OPR_NOT = 1,
		OPR_LEN = 2,
		OPR_NOUNOPR = 3,
	}
	function luaK:getcode(fs, e)
		return fs.f.code[e.info]
	end
	function luaK:codeAsBx(fs, o, A, sBx)
		return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx)
	end
	function luaK:setmultret(fs, e)
		self:setreturns(fs, e, luaY.LUA_MULTRET)
	end
	function luaK:hasjumps(e)
		return e.t ~= e.f
	end
	function luaK:isnumeral(e)
		return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP
	end
	function luaK:_nil(fs, from, n)
		if fs.pc > fs.lasttarget then
			if fs.pc == 0 then
				if from >= fs.nactvar then
					return
				end
			else
				local previous = fs.f.code[fs.pc - 1]
				if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
					local pfrom = luaP:GETARG_A(previous)
					local pto = luaP:GETARG_B(previous)
					if pfrom <= from and from <= pto + 1 then
						if from + n - 1 > pto then
							luaP:SETARG_B(previous, from + n - 1)
						end
						return
					end
				end
			end
		end
		self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)
	end
	function luaK:jump(fs)
		local jpc = fs.jpc
		fs.jpc = self.NO_JUMP
		local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
		j = self:concat(fs, j, jpc)
		return j
	end
	function luaK:ret(fs, first, nret)
		self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
	end
	function luaK:condjump(fs, op, A, B, C)
		self:codeABC(fs, op, A, B, C)
		return self:jump(fs)
	end
	function luaK:fixjump(fs, pc, dest)
		local jmp = fs.f.code[pc]
		local offset = dest - (pc + 1)
		lua_assert(dest ~= self.NO_JUMP)
		if math.abs(offset) > luaP.MAXARG_sBx then
			luaX:syntaxerror(fs.ls, "control structure too long")
		end
		luaP:SETARG_sBx(jmp, offset)
	end
	function luaK:getlabel(fs)
		fs.lasttarget = fs.pc
		return fs.pc
	end
	function luaK:getjump(fs, pc)
		local offset = luaP:GETARG_sBx(fs.f.code[pc])
		if offset == self.NO_JUMP then
			return self.NO_JUMP
		else
			return (pc + 1) + offset
		end
	end
	function luaK:getjumpcontrol(fs, pc)
		local pi = fs.f.code[pc]
		local ppi = fs.f.code[pc - 1]
		if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
			return ppi
		else
			return pi
		end
	end
	function luaK:need_value(fs, list)
		while list ~= self.NO_JUMP do
			local i = self:getjumpcontrol(fs, list)
			if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
				return true
			end
			list = self:getjump(fs, list)
		end
		return false
	end
	function luaK:patchtestreg(fs, node, reg)
		local i = self:getjumpcontrol(fs, node)
		if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
			return false
		end
		if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
			luaP:SETARG_A(i, reg)
		else
			luaP:SET_OPCODE(i, "OP_TEST")
			local b = luaP:GETARG_B(i)
			luaP:SETARG_A(i, b)
			luaP:SETARG_B(i, 0)
		end
		return true
	end
	function luaK:removevalues(fs, list)
		while list ~= self.NO_JUMP do
			self:patchtestreg(fs, list, luaP.NO_REG)
			list = self:getjump(fs, list)
		end
	end
	function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
		while list ~= self.NO_JUMP do
			local _next = self:getjump(fs, list)
			if self:patchtestreg(fs, list, reg) then
				self:fixjump(fs, list, vtarget)
			else
				self:fixjump(fs, list, dtarget)
			end
			list = _next
		end
	end
	function luaK:dischargejpc(fs)
		self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
		fs.jpc = self.NO_JUMP
	end
	function luaK:patchlist(fs, list, target)
		if target == fs.pc then
			self:patchtohere(fs, list)
		else
			lua_assert(target < fs.pc)
			self:patchlistaux(fs, list, target, luaP.NO_REG, target)
		end
	end
	function luaK:patchtohere(fs, list)
		self:getlabel(fs)
		fs.jpc = self:concat(fs, fs.jpc, list)
	end
	function luaK:concat(fs, l1, l2)
		if l2 == self.NO_JUMP then
			return l1
		elseif l1 == self.NO_JUMP then
			return l2
		else
			local list = l1
			local _next = self:getjump(fs, list)
			while _next ~= self.NO_JUMP do
				list = _next
				_next = self:getjump(fs, list)
			end
			self:fixjump(fs, list, l2)
		end
		return l1
	end
	function luaK:checkstack(fs, n)
		local newstack = fs.freereg + n
		if newstack > fs.f.maxstacksize then
			if newstack >= self.MAXSTACK then
				luaX:syntaxerror(fs.ls, "function or expression too complex")
			end
			fs.f.maxstacksize = newstack
		end
	end
	function luaK:reserveregs(fs, n)
		self:checkstack(fs, n)
		fs.freereg = fs.freereg + n
	end
	function luaK:freereg(fs, reg)
		if not luaP:ISK(reg) and reg >= fs.nactvar then
			fs.freereg = fs.freereg - 1
			lua_assert(reg == fs.freereg)
		end
	end
	function luaK:freeexp(fs, e)
		if e.k == "VNONRELOC" then
			self:freereg(fs, e.info)
		end
	end
	function luaK:addk(fs, k, v)
		local L = fs.L
		local idx = fs.h[k.value]
		local f = fs.f
		if self:ttisnumber(idx) then
			return self:nvalue(idx)
		else
			idx = {}
			self:setnvalue(idx, fs.nk)
			fs.h[k.value] = idx
			luaY:growvector(L, f.k, fs.nk, f.sizek, nil, luaP.MAXARG_Bx, "constant table overflow")
			f.k[fs.nk] = v
			local nk = fs.nk
			fs.nk = fs.nk + 1
			return nk
		end
	end
	function luaK:stringK(fs, s)
		local o = {}
		self:setsvalue(o, s)
		return self:addk(fs, o, o)
	end
	function luaK:numberK(fs, r)
		local o = {}
		self:setnvalue(o, r)
		return self:addk(fs, o, o)
	end
	function luaK:boolK(fs, b)
		local o = {}
		self:setbvalue(o, b)
		return self:addk(fs, o, o)
	end
	function luaK:nilK(fs)
		local k, v = {}, {}
		self:setnilvalue(v)
		self:sethvalue(k, fs.h)
		return self:addk(fs, k, v)
	end
	function luaK:setreturns(fs, e, nresults)
		if e.k == "VCALL" then
			luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
		elseif e.k == "VVARARG" then
			luaP:SETARG_B(self:getcode(fs, e), nresults + 1)
			luaP:SETARG_A(self:getcode(fs, e), fs.freereg)
			luaK:reserveregs(fs, 1)
		end
	end
	function luaK:setoneret(fs, e)
		if e.k == "VCALL" then
			e.k = "VNONRELOC"
			e.info = luaP:GETARG_A(self:getcode(fs, e))
		elseif e.k == "VVARARG" then
			luaP:SETARG_B(self:getcode(fs, e), 2)
			e.k = "VRELOCABLE"
		end
	end
	function luaK:dischargevars(fs, e)
		local k = e.k
		if k == "VLOCAL" then
			e.k = "VNONRELOC"
		elseif k == "VUPVAL" then
			e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
			e.k = "VRELOCABLE"
		elseif k == "VGLOBAL" then
			e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
			e.k = "VRELOCABLE"
		elseif k == "VINDEXED" then
			self:freereg(fs, e.aux)
			self:freereg(fs, e.info)
			e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
			e.k = "VRELOCABLE"
		elseif k == "VVARARG" or k == "VCALL" then
			self:setoneret(fs, e)
		else
		end
	end
	function luaK:code_label(fs, A, b, jump)
		self:getlabel(fs)
		return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
	end
	function luaK:discharge2reg(fs, e, reg)
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" then
			self:_nil(fs, reg, 1)
		elseif k == "VFALSE" or k == "VTRUE" then
			self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
		elseif k == "VK" then
			self:codeABx(fs, "OP_LOADK", reg, e.info)
		elseif k == "VKNUM" then
			self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
		elseif k == "VRELOCABLE" then
			local pc = self:getcode(fs, e)
			luaP:SETARG_A(pc, reg)
		elseif k == "VNONRELOC" then
			if reg ~= e.info then
				self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
			end
		else
			lua_assert(e.k == "VVOID" or e.k == "VJMP")
			return
		end
		e.info = reg
		e.k = "VNONRELOC"
	end
	function luaK:discharge2anyreg(fs, e)
		if e.k ~= "VNONRELOC" then
			self:reserveregs(fs, 1)
			self:discharge2reg(fs, e, fs.freereg - 1)
		end
	end
	function luaK:exp2reg(fs, e, reg)
		self:discharge2reg(fs, e, reg)
		if e.k == "VJMP" then
			e.t = self:concat(fs, e.t, e.info)
		end
		if self:hasjumps(e) then
			local final
			local p_f = self.NO_JUMP
			local p_t = self.NO_JUMP
			if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
				local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
				p_f = self:code_label(fs, reg, 0, 1)
				p_t = self:code_label(fs, reg, 1, 0)
				self:patchtohere(fs, fj)
			end
			final = self:getlabel(fs)
			self:patchlistaux(fs, e.f, final, reg, p_f)
			self:patchlistaux(fs, e.t, final, reg, p_t)
		end
		e.f, e.t = self.NO_JUMP, self.NO_JUMP
		e.info = reg
		e.k = "VNONRELOC"
	end
	function luaK:exp2nextreg(fs, e)
		self:dischargevars(fs, e)
		self:freeexp(fs, e)
		self:reserveregs(fs, 1)
		self:exp2reg(fs, e, fs.freereg - 1)
	end
	function luaK:exp2anyreg(fs, e)
		self:dischargevars(fs, e)
		if e.k == "VNONRELOC" then
			if not self:hasjumps(e) then
				return e.info
			end
			if e.info >= fs.nactvar then
				self:exp2reg(fs, e, e.info)
				return e.info
			end
		end
		self:exp2nextreg(fs, e)
		return e.info
	end
	function luaK:exp2val(fs, e)
		if self:hasjumps(e) then
			self:exp2anyreg(fs, e)
		else
			self:dischargevars(fs, e)
		end
	end
	function luaK:exp2RK(fs, e)
		self:exp2val(fs, e)
		local k = e.k
		if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
			if fs.nk <= luaP.MAXINDEXRK then
				if e.k == "VNIL" then
					e.info = self:nilK(fs)
				else
					e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval) or self:boolK(fs, e.k == "VTRUE")
				end
				e.k = "VK"
				return luaP:RKASK(e.info)
			end
		elseif k == "VK" then
			if e.info <= luaP.MAXINDEXRK then
				return luaP:RKASK(e.info)
			end
		else
		end
		return self:exp2anyreg(fs, e)
	end
	function luaK:storevar(fs, var, ex)
		local k = var.k
		if k == "VLOCAL" then
			self:freeexp(fs, ex)
			self:exp2reg(fs, ex, var.info)
			return
		elseif k == "VUPVAL" then
			local e = self:exp2anyreg(fs, ex)
			self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
		elseif k == "VGLOBAL" then
			local e = self:exp2anyreg(fs, ex)
			self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
		elseif k == "VINDEXED" then
			local e = self:exp2RK(fs, ex)
			self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
		else
			lua_assert(0)
		end
		self:freeexp(fs, ex)
	end
	function luaK:_self(fs, e, key)
		self:exp2anyreg(fs, e)
		self:freeexp(fs, e)
		local func = fs.freereg
		self:reserveregs(fs, 2)
		self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
		self:freeexp(fs, key)
		e.info = func
		e.k = "VNONRELOC"
	end
	function luaK:invertjump(fs, e)
		local pc = self:getjumpcontrol(fs, e.info)
		lua_assert(
			luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0
				and luaP:GET_OPCODE(pc) ~= "OP_TESTSET"
				and luaP:GET_OPCODE(pc) ~= "OP_TEST"
		)
		luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
	end
	function luaK:jumponcond(fs, e, cond)
		if e.k == "VRELOCABLE" then
			local ie = self:getcode(fs, e)
			if luaP:GET_OPCODE(ie) == "OP_NOT" then
				fs.pc = fs.pc - 1
				return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
			end
		end
		self:discharge2anyreg(fs, e)
		self:freeexp(fs, e)
		return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
	end
	function luaK:goiftrue(fs, e)
		local pc
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VK" or k == "VKNUM" or k == "VTRUE" then
			pc = self.NO_JUMP
		elseif k == "VFALSE" then
			pc = self:jump(fs)
		elseif k == "VJMP" then
			self:invertjump(fs, e)
			pc = e.info
		else
			pc = self:jumponcond(fs, e, false)
		end
		e.f = self:concat(fs, e.f, pc)
		self:patchtohere(fs, e.t)
		e.t = self.NO_JUMP
	end
	function luaK:goiffalse(fs, e)
		local pc
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" or k == "VFALSE" then
			pc = self.NO_JUMP
		elseif k == "VTRUE" then
			pc = self:jump(fs)
		elseif k == "VJMP" then
			pc = e.info
		else
			pc = self:jumponcond(fs, e, true)
		end
		e.t = self:concat(fs, e.t, pc)
		self:patchtohere(fs, e.f)
		e.f = self.NO_JUMP
	end
	function luaK:codenot(fs, e)
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" or k == "VFALSE" then
			e.k = "VTRUE"
		elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
			e.k = "VFALSE"
		elseif k == "VJMP" then
			self:invertjump(fs, e)
		elseif k == "VRELOCABLE" or k == "VNONRELOC" then
			self:discharge2anyreg(fs, e)
			self:freeexp(fs, e)
			e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
			e.k = "VRELOCABLE"
		else
			lua_assert(0)
		end
		e.f, e.t = e.t, e.f
		self:removevalues(fs, e.f)
		self:removevalues(fs, e.t)
	end
	function luaK:indexed(fs, t, k)
		t.aux = self:exp2RK(fs, k)
		t.k = "VINDEXED"
	end
	function luaK:constfolding(op, e1, e2)
		local r
		if not self:isnumeral(e1) or not self:isnumeral(e2) then
			return false
		end
		local v1 = e1.nval
		local v2 = e2.nval
		if op == "OP_ADD" then
			r = self:numadd(v1, v2)
		elseif op == "OP_SUB" then
			r = self:numsub(v1, v2)
		elseif op == "OP_MUL" then
			r = self:nummul(v1, v2)
		elseif op == "OP_DIV" then
			if v2 == 0 then
				return false
			end
			r = self:numdiv(v1, v2)
		elseif op == "OP_MOD" then
			if v2 == 0 then
				return false
			end
			r = self:nummod(v1, v2)
		elseif op == "OP_POW" then
			r = self:numpow(v1, v2)
		elseif op == "OP_UNM" then
			r = self:numunm(v1)
		elseif op == "OP_LEN" then
			return false
		else
			lua_assert(0)
			r = 0
		end
		if self:numisnan(r) then
			return false
		end
		e1.nval = r
		return true
	end
	function luaK:codearith(fs, op, e1, e2)
		if self:constfolding(op, e1, e2) then
			return
		else
			local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
			local o1 = self:exp2RK(fs, e1)
			if o1 > o2 then
				self:freeexp(fs, e1)
				self:freeexp(fs, e2)
			else
				self:freeexp(fs, e2)
				self:freeexp(fs, e1)
			end
			e1.info = self:codeABC(fs, op, 0, o1, o2)
			e1.k = "VRELOCABLE"
		end
	end
	function luaK:codecomp(fs, op, cond, e1, e2)
		local o1 = self:exp2RK(fs, e1)
		local o2 = self:exp2RK(fs, e2)
		self:freeexp(fs, e2)
		self:freeexp(fs, e1)
		if cond == 0 and op ~= "OP_EQ" then
			o1, o2 = o2, o1
			cond = 1
		end
		e1.info = self:condjump(fs, op, cond, o1, o2)
		e1.k = "VJMP"
	end
	function luaK:prefix(fs, op, e)
		local e2 = {}
		e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
		e2.k = "VKNUM"
		e2.nval = 0
		if op == "OPR_MINUS" then
			if not self:isnumeral(e) then
				self:exp2anyreg(fs, e)
			end
			self:codearith(fs, "OP_UNM", e, e2)
		elseif op == "OPR_NOT" then
			self:codenot(fs, e)
		elseif op == "OPR_LEN" then
			self:exp2anyreg(fs, e)
			self:codearith(fs, "OP_LEN", e, e2)
		else
			lua_assert(0)
		end
	end
	function luaK:infix(fs, op, v)
		if op == "OPR_AND" then
			self:goiftrue(fs, v)
		elseif op == "OPR_OR" then
			self:goiffalse(fs, v)
		elseif op == "OPR_CONCAT" then
			self:exp2nextreg(fs, v)
		elseif
			op == "OPR_ADD"
			or op == "OPR_SUB"
			or op == "OPR_MUL"
			or op == "OPR_DIV"
			or op == "OPR_MOD"
			or op == "OPR_POW"
		then
			if not self:isnumeral(v) then
				self:exp2RK(fs, v)
			end
		else
			self:exp2RK(fs, v)
		end
	end
	luaK.arith_op = {
		OPR_ADD = "OP_ADD",
		OPR_SUB = "OP_SUB",
		OPR_MUL = "OP_MUL",
		OPR_DIV = "OP_DIV",
		OPR_MOD = "OP_MOD",
		OPR_POW = "OP_POW",
	}
	luaK.comp_op = {
		OPR_EQ = "OP_EQ",
		OPR_NE = "OP_EQ",
		OPR_LT = "OP_LT",
		OPR_LE = "OP_LE",
		OPR_GT = "OP_LT",
		OPR_GE = "OP_LE",
	}
	luaK.comp_cond = {
		OPR_EQ = 1,
		OPR_NE = 0,
		OPR_LT = 1,
		OPR_LE = 1,
		OPR_GT = 0,
		OPR_GE = 0,
	}
	function luaK:posfix(fs, op, e1, e2)
		local function copyexp(e1, e2)
			e1.k = e2.k
			e1.info = e2.info
			e1.aux = e2.aux
			e1.nval = e2.nval
			e1.t = e2.t
			e1.f = e2.f
		end
		if op == "OPR_AND" then
			lua_assert(e1.t == self.NO_JUMP)
			self:dischargevars(fs, e2)
			e2.f = self:concat(fs, e2.f, e1.f)
			copyexp(e1, e2)
		elseif op == "OPR_OR" then
			lua_assert(e1.f == self.NO_JUMP)
			self:dischargevars(fs, e2)
			e2.t = self:concat(fs, e2.t, e1.t)
			copyexp(e1, e2)
		elseif op == "OPR_CONCAT" then
			self:exp2val(fs, e2)
			if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
				lua_assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
				self:freeexp(fs, e1)
				luaP:SETARG_B(self:getcode(fs, e2), e1.info)
				e1.k = "VRELOCABLE"
				e1.info = e2.info
			else
				self:exp2nextreg(fs, e2)
				self:codearith(fs, "OP_CONCAT", e1, e2)
			end
		else
			local arith = self.arith_op[op]
			if arith then
				self:codearith(fs, arith, e1, e2)
			else
				local comp = self.comp_op[op]
				if comp then
					self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
				else
					lua_assert(0)
				end
			end
		end
	end
	function luaK:fixline(fs, line)
		fs.f.lineinfo[fs.pc - 1] = line
	end
	function luaK:code(fs, i, line)
		local f = fs.f
		self:dischargejpc(fs)
		luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil, luaY.MAX_INT, "code size overflow")
		f.code[fs.pc] = i
		luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil, luaY.MAX_INT, "code size overflow")
		f.lineinfo[fs.pc] = line
		local pc = fs.pc
		fs.pc = fs.pc + 1
		return pc
	end
	function luaK:codeABC(fs, o, a, b, c)
		lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
		lua_assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
		lua_assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
		return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
	end
	function luaK:codeABx(fs, o, a, bc)
		lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABx or luaP:getOpMode(o) == luaP.OpMode.iAsBx)
		lua_assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
		return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
	end
	function luaK:setlist(fs, base, nelems, tostore)
		local c = math.floor((nelems - 1) / luaP.LFIELDS_PER_FLUSH) + 1
		local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
		lua_assert(tostore ~= 0)
		if c <= luaP.MAXARG_C then
			self:codeABC(fs, "OP_SETLIST", base, b, c)
		else
			self:codeABC(fs, "OP_SETLIST", base, b, 0)
			self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
		end
		fs.freereg = base + 1
	end
	luaY.LUA_QS = luaX.LUA_QS or "'%s'"
	luaY.SHRT_MAX = 32767
	luaY.LUAI_MAXVARS = 200
	luaY.LUAI_MAXUPVALUES = 60
	luaY.MAX_INT = luaX.MAX_INT or 2147483645
	luaY.LUAI_MAXCCALLS = 200
	luaY.VARARG_HASARG = 1
	luaY.HASARG_MASK = 2
	luaY.VARARG_ISVARARG = 2
	luaY.VARARG_NEEDSARG = 4
	luaY.LUA_MULTRET = -1
	function luaY:LUA_QL(x)
		return "'" .. x .. "'"
	end
	function luaY:growvector(_, _, nelems, _, _, limit, e)
		if nelems >= limit then
			error(e)
		end
	end
	function luaY:newproto()
		local f = {}
		f.k = {}
		f.sizek = 0
		f.p = {}
		f.sizep = 0
		f.code = {}
		f.sizecode = 0
		f.sizelineinfo = 0
		f.sizeupvalues = 0
		f.nups = 0
		f.upvalues = {}
		f.numparams = 0
		f.is_vararg = 0
		f.maxstacksize = 0
		f.lineinfo = {}
		f.sizelocvars = 0
		f.locvars = {}
		f.lineDefined = 0
		f.lastlinedefined = 0
		f.source = nil
		return f
	end
	function luaY:int2fb(x)
		local e = 0
		while x >= 16 do
			x = math.floor((x + 1) / 2)
			e = e + 1
		end
		if x < 8 then
			return x
		else
			return ((e + 1) * 8) + (x - 8)
		end
	end
	function luaY:hasmultret(k)
		return k == "VCALL" or k == "VVARARG"
	end
	function luaY:getlocvar(fs, i)
		return fs.f.locvars[fs.actvar[i]]
	end
	function luaY:checklimit(fs, v, l, m)
		if v > l then
			self:errorlimit(fs, l, m)
		end
	end
	function luaY:error_expected(ls, token)
		luaX:syntaxerror(ls, string.format(self.LUA_QS .. " expected", luaX:token2str(ls, token)))
	end
	function luaY:errorlimit(fs, limit, what)
		local msg = (fs.f.linedefined == 0) and string.format("main function has more than %d %s", limit, what)
			or string.format("function at line %d has more than %d %s", fs.f.linedefined, limit, what)
		luaX:lexerror(fs.ls, msg, 0)
	end
	function luaY:testnext(ls, c)
		if ls.t.token == c then
			luaX:next(ls)
			return true
		else
			return false
		end
	end
	function luaY:check(ls, c)
		if ls.t.token ~= c then
			self:error_expected(ls, c)
		end
	end
	function luaY:checknext(ls, c)
		self:check(ls, c)
		luaX:next(ls)
	end
	function luaY:check_condition(ls, c, msg)
		if not c then
			luaX:syntaxerror(ls, msg)
		end
	end
	function luaY:check_match(ls, what, who, where)
		if not self:testnext(ls, what) then
			if where == ls.linenumber then
				self:error_expected(ls, what)
			else
				luaX:syntaxerror(
					ls,
					string.format(
						self.LUA_QS .. " expected (to close " .. self.LUA_QS .. " at line %d)",
						luaX:token2str(ls, what),
						luaX:token2str(ls, who),
						where
					)
				)
			end
		end
	end
	function luaY:str_checkname(ls)
		self:check(ls, "TK_NAME")
		local ts = ls.t.seminfo
		luaX:next(ls)
		return ts
	end
	function luaY:init_exp(e, k, i)
		e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
		e.k = k
		e.info = i
	end
	function luaY:codestring(ls, e, s)
		self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
	end
	function luaY:checkname(ls, e)
		self:codestring(ls, e, self:str_checkname(ls))
	end
	function luaY:registerlocalvar(ls, varname)
		local fs = ls.fs
		local f = fs.f
		self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars, nil, self.SHRT_MAX, "too many local variables")
		f.locvars[fs.nlocvars] = {}
		f.locvars[fs.nlocvars].varname = varname
		local nlocvars = fs.nlocvars
		fs.nlocvars = fs.nlocvars + 1
		return nlocvars
	end
	function luaY:new_localvarliteral(ls, v, n)
		self:new_localvar(ls, v, n)
	end
	function luaY:new_localvar(ls, name, n)
		local fs = ls.fs
		self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
		fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
	end
	function luaY:adjustlocalvars(ls, nvars)
		local fs = ls.fs
		fs.nactvar = fs.nactvar + nvars
		for i = nvars, 1, -1 do
			self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
		end
	end
	function luaY:removevars(ls, tolevel)
		local fs = ls.fs
		while fs.nactvar > tolevel do
			fs.nactvar = fs.nactvar - 1
			self:getlocvar(fs, fs.nactvar).endpc = fs.pc
		end
	end
	function luaY:indexupvalue(fs, name, v)
		local f = fs.f
		for i = 0, f.nups - 1 do
			if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
				lua_assert(f.upvalues[i] == name)
				return i
			end
		end
		self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
		self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues, nil, self.MAX_INT, "")
		f.upvalues[f.nups] = name
		lua_assert(v.k == "VLOCAL" or v.k == "VUPVAL")
		fs.upvalues[f.nups] = { k = v.k, info = v.info }
		local nups = f.nups
		f.nups = f.nups + 1
		return nups
	end
	function luaY:searchvar(fs, n)
		for i = fs.nactvar - 1, 0, -1 do
			if n == self:getlocvar(fs, i).varname then
				return i
			end
		end
		return -1
	end
	function luaY:markupval(fs, level)
		local bl = fs.bl
		while bl and bl.nactvar > level do
			bl = bl.previous
		end
		if bl then
			bl.upval = true
		end
	end
	function luaY:singlevaraux(fs, n, var, base)
		if fs == nil then
			self:init_exp(var, "VGLOBAL", luaP.NO_REG)
			return "VGLOBAL"
		else
			local v = self:searchvar(fs, n)
			if v >= 0 then
				self:init_exp(var, "VLOCAL", v)
				if base == 0 then
					self:markupval(fs, v)
				end
				return "VLOCAL"
			else
				if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
					return "VGLOBAL"
				end
				var.info = self:indexupvalue(fs, n, var)
				var.k = "VUPVAL"
				return "VUPVAL"
			end
		end
	end
	function luaY:singlevar(ls, var)
		local varname = self:str_checkname(ls)
		local fs = ls.fs
		if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
			var.info = luaK:stringK(fs, varname)
		end
	end
	function luaY:adjust_assign(ls, nvars, nexps, e)
		local fs = ls.fs
		local extra = nvars - nexps
		if self:hasmultret(e.k) then
			extra = extra + 1
			if extra <= 0 then
				extra = 0
			end
			luaK:setreturns(fs, e, extra)
			if extra > 1 then
				luaK:reserveregs(fs, extra - 1)
			end
		else
			if e.k ~= "VVOID" then
				luaK:exp2nextreg(fs, e)
			end
			if extra > 0 then
				local reg = fs.freereg
				luaK:reserveregs(fs, extra)
				luaK:_nil(fs, reg, extra)
			end
		end
	end
	function luaY:enterlevel(ls)
		ls.L.nCcalls = ls.L.nCcalls + 1
		if ls.L.nCcalls > self.LUAI_MAXCCALLS then
			luaX:lexerror(ls, "chunk has too many syntax levels", 0)
		end
	end
	function luaY:leavelevel(ls)
		ls.L.nCcalls = ls.L.nCcalls - 1
	end
	function luaY:enterblock(fs, bl, isbreakable)
		bl.breaklist = luaK.NO_JUMP
		bl.isbreakable = isbreakable
		bl.nactvar = fs.nactvar
		bl.upval = false
		bl.previous = fs.bl
		fs.bl = bl
		lua_assert(fs.freereg == fs.nactvar)
	end
	function luaY:leaveblock(fs)
		local bl = fs.bl
		fs.bl = bl.previous
		self:removevars(fs.ls, bl.nactvar)
		if bl.upval then
			luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
		end
		lua_assert(not bl.isbreakable or not bl.upval)
		lua_assert(bl.nactvar == fs.nactvar)
		fs.freereg = fs.nactvar
		luaK:patchtohere(fs, bl.breaklist)
	end
	function luaY:pushclosure(ls, func, v)
		local fs = ls.fs
		local f = fs.f
		self:growvector(ls.L, f.p, fs.np, f.sizep, nil, luaP.MAXARG_Bx, "constant table overflow")
		f.p[fs.np] = func.f
		fs.np = fs.np + 1
		self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
		for i = 0, func.f.nups - 1 do
			local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
			luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
		end
	end
	function luaY:open_func(ls, fs)
		local L = ls.L
		local f = self:newproto()
		fs.f = f
		fs.prev = ls.fs
		fs.ls = ls
		fs.L = L
		ls.fs = fs
		fs.pc = 0
		fs.lasttarget = -1
		fs.jpc = luaK.NO_JUMP
		fs.freereg = 0
		fs.nk = 0
		fs.np = 0
		fs.nlocvars = 0
		fs.nactvar = 0
		fs.bl = nil
		f.source = ls.source
		f.maxstacksize = 2
		fs.h = {}
	end
	function luaY:close_func(ls)
		local fs = ls.fs
		local f = fs.f
		self:removevars(ls, 0)
		luaK:ret(fs, 0, 0)
		f.sizecode = fs.pc
		f.sizelineinfo = fs.pc
		f.sizek = fs.nk
		f.sizep = fs.np
		f.sizelocvars = fs.nlocvars
		f.sizeupvalues = f.nups
		lua_assert(fs.bl == nil)
		ls.fs = fs.prev
	end
	function luaY:parser(L, z, buff, name)
		local lexstate = {}
		lexstate.t = {}
		lexstate.lookahead = {}
		local funcstate = {}
		funcstate.upvalues = {}
		funcstate.actvar = {}
		L.nCcalls = 0
		lexstate.buff = buff
		luaX:setinput(L, lexstate, z, name)
		self:open_func(lexstate, funcstate)
		funcstate.f.is_vararg = self.VARARG_ISVARARG
		luaX:next(lexstate)
		self:chunk(lexstate)
		self:check(lexstate, "TK_EOS")
		self:close_func(lexstate)
		lua_assert(funcstate.prev == nil)
		lua_assert(funcstate.f.nups == 0)
		lua_assert(lexstate.fs == nil)
		return funcstate.f
	end
	function luaY:field(ls, v)
		local fs = ls.fs
		local key = {}
		luaK:exp2anyreg(fs, v)
		luaX:next(ls)
		self:checkname(ls, key)
		luaK:indexed(fs, v, key)
	end
	function luaY:yindex(ls, v)
		luaX:next(ls)
		self:expr(ls, v)
		luaK:exp2val(ls.fs, v)
		self:checknext(ls, "]")
	end
	function luaY:recfield(ls, cc)
		local fs = ls.fs
		local reg = ls.fs.freereg
		local key, val = {}, {}
		if ls.t.token == "TK_NAME" then
			self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
			self:checkname(ls, key)
		else
			self:yindex(ls, key)
		end
		cc.nh = cc.nh + 1
		self:checknext(ls, "=")
		local rkkey = luaK:exp2RK(fs, key)
		self:expr(ls, val)
		luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
		fs.freereg = reg
	end
	function luaY:closelistfield(fs, cc)
		if cc.v.k == "VVOID" then
			return
		end
		luaK:exp2nextreg(fs, cc.v)
		cc.v.k = "VVOID"
		if cc.tostore == luaP.LFIELDS_PER_FLUSH then
			luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
			cc.tostore = 0
		end
	end
	function luaY:lastlistfield(fs, cc)
		if cc.tostore == 0 then
			return
		end
		if self:hasmultret(cc.v.k) then
			luaK:setmultret(fs, cc.v)
			luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
			cc.na = cc.na - 1
		else
			if cc.v.k ~= "VVOID" then
				luaK:exp2nextreg(fs, cc.v)
			end
			luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
		end
	end
	function luaY:listfield(ls, cc)
		self:expr(ls, cc.v)
		self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
		cc.na = cc.na + 1
		cc.tostore = cc.tostore + 1
	end
	function luaY:constructor(ls, t)
		local fs = ls.fs
		local line = ls.linenumber
		local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
		local cc = {}
		cc.v = {}
		cc.na, cc.nh, cc.tostore = 0, 0, 0
		cc.t = t
		self:init_exp(t, "VRELOCABLE", pc)
		self:init_exp(cc.v, "VVOID", 0)
		luaK:exp2nextreg(ls.fs, t)
		self:checknext(ls, "{")
		repeat
			lua_assert(cc.v.k == "VVOID" or cc.tostore > 0)
			if ls.t.token == "}" then
				break
			end
			self:closelistfield(fs, cc)
			local c = ls.t.token
			if c == "TK_NAME" then
				luaX:lookahead(ls)
				if ls.lookahead.token ~= "=" then
					self:listfield(ls, cc)
				else
					self:recfield(ls, cc)
				end
			elseif c == "[" then
				self:recfield(ls, cc)
			else
				self:listfield(ls, cc)
			end
		until not self:testnext(ls, ",") and not self:testnext(ls, ";")
		self:check_match(ls, "}", "{", line)
		self:lastlistfield(fs, cc)
		luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na))
		luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh))
	end
	function luaY:parlist(ls)
		local fs = ls.fs
		local f = fs.f
		local nparams = 0
		f.is_vararg = 0
		if ls.t.token ~= ")" then
			repeat
				local c = ls.t.token
				if c == "TK_NAME" then
					self:new_localvar(ls, self:str_checkname(ls), nparams)
					nparams = nparams + 1
				elseif c == "TK_DOTS" then
					luaX:next(ls)
					self:new_localvarliteral(ls, "arg", nparams)
					nparams = nparams + 1
					f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG
					f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
				else
					luaX:syntaxerror(ls, "<name> or " .. self:LUA_QL("...") .. " expected")
				end
			until f.is_vararg ~= 0 or not self:testnext(ls, ",")
		end
		self:adjustlocalvars(ls, nparams)
		f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
		luaK:reserveregs(fs, fs.nactvar)
	end
	function luaY:body(ls, e, needself, line)
		local new_fs = {}
		new_fs.upvalues = {}
		new_fs.actvar = {}
		self:open_func(ls, new_fs)
		new_fs.f.lineDefined = line
		self:checknext(ls, "(")
		if needself then
			self:new_localvarliteral(ls, "self", 0)
			self:adjustlocalvars(ls, 1)
		end
		self:parlist(ls)
		self:checknext(ls, ")")
		self:chunk(ls)
		new_fs.f.lastlinedefined = ls.linenumber
		self:check_match(ls, "TK_END", "TK_FUNCTION", line)
		self:close_func(ls)
		self:pushclosure(ls, new_fs, e)
	end
	function luaY:explist1(ls, v)
		local n = 1
		self:expr(ls, v)
		while self:testnext(ls, ",") do
			luaK:exp2nextreg(ls.fs, v)
			self:expr(ls, v)
			n = n + 1
		end
		return n
	end
	function luaY:funcargs(ls, f)
		local fs = ls.fs
		local args = {}
		local nparams
		local line = ls.linenumber
		local c = ls.t.token
		if c == "(" then
			if line ~= ls.lastline then
				luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
			end
			luaX:next(ls)
			if ls.t.token == ")" then
				args.k = "VVOID"
			else
				self:explist1(ls, args)
				luaK:setmultret(fs, args)
			end
			self:check_match(ls, ")", "(", line)
		elseif c == "{" then
			self:constructor(ls, args)
		elseif c == "TK_STRING" then
			self:codestring(ls, args, ls.t.seminfo)
			luaX:next(ls)
		else
			luaX:syntaxerror(ls, "function arguments expected")
			return
		end
		lua_assert(f.k == "VNONRELOC")
		local base = f.info
		if self:hasmultret(args.k) then
			nparams = self.LUA_MULTRET
		else
			if args.k ~= "VVOID" then
				luaK:exp2nextreg(fs, args)
			end
			nparams = fs.freereg - (base + 1)
		end
		self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
		luaK:fixline(fs, line)
		fs.freereg = base + 1
	end
	function luaY:prefixexp(ls, v)
		local c = ls.t.token
		if c == "(" then
			local line = ls.linenumber
			luaX:next(ls)
			self:expr(ls, v)
			self:check_match(ls, ")", "(", line)
			luaK:dischargevars(ls.fs, v)
		elseif c == "TK_NAME" then
			self:singlevar(ls, v)
		else
			luaX:syntaxerror(ls, "unexpected symbol")
		end
		return
	end
	function luaY:primaryexp(ls, v)
		local fs = ls.fs
		self:prefixexp(ls, v)
		while true do
			local c = ls.t.token
			if c == "." then
				self:field(ls, v)
			elseif c == "[" then
				local key = {}
				luaK:exp2anyreg(fs, v)
				self:yindex(ls, key)
				luaK:indexed(fs, v, key)
			elseif c == ":" then
				local key = {}
				luaX:next(ls)
				self:checkname(ls, key)
				luaK:_self(fs, v, key)
				self:funcargs(ls, v)
			elseif c == "(" or c == "TK_STRING" or c == "{" then
				luaK:exp2nextreg(fs, v)
				self:funcargs(ls, v)
			else
				return
			end
		end
	end
	function luaY:simpleexp(ls, v)
		local c = ls.t.token
		if c == "TK_NUMBER" then
			self:init_exp(v, "VKNUM", 0)
			v.nval = ls.t.seminfo
		elseif c == "TK_STRING" then
			self:codestring(ls, v, ls.t.seminfo)
		elseif c == "TK_NIL" then
			self:init_exp(v, "VNIL", 0)
		elseif c == "TK_TRUE" then
			self:init_exp(v, "VTRUE", 0)
		elseif c == "TK_FALSE" then
			self:init_exp(v, "VFALSE", 0)
		elseif c == "TK_DOTS" then
			local fs = ls.fs
			self:check_condition(
				ls,
				fs.f.is_vararg ~= 0,
				"cannot use " .. self:LUA_QL("...") .. " outside a vararg function"
			)
			local is_vararg = fs.f.is_vararg
			if is_vararg >= self.VARARG_NEEDSARG then
				fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG
			end
			self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
		elseif c == "{" then
			self:constructor(ls, v)
			return
		elseif c == "TK_FUNCTION" then
			luaX:next(ls)
			self:body(ls, v, false, ls.linenumber)
			return
		else
			self:primaryexp(ls, v)
			return
		end
		luaX:next(ls)
	end
	function luaY:getunopr(op)
		if op == "TK_NOT" then
			return "OPR_NOT"
		elseif op == "-" then
			return "OPR_MINUS"
		elseif op == "#" then
			return "OPR_LEN"
		else
			return "OPR_NOUNOPR"
		end
	end
	luaY.getbinopr_table = {
		["+"] = "OPR_ADD",
		["-"] = "OPR_SUB",
		["*"] = "OPR_MUL",
		["/"] = "OPR_DIV",
		["%"] = "OPR_MOD",
		["^"] = "OPR_POW",
		["TK_CONCAT"] = "OPR_CONCAT",
		["TK_NE"] = "OPR_NE",
		["TK_EQ"] = "OPR_EQ",
		["<"] = "OPR_LT",
		["TK_LE"] = "OPR_LE",
		[">"] = "OPR_GT",
		["TK_GE"] = "OPR_GE",
		["TK_AND"] = "OPR_AND",
		["TK_OR"] = "OPR_OR",
	}
	function luaY:getbinopr(op)
		local opr = self.getbinopr_table[op]
		if opr then
			return opr
		else
			return "OPR_NOBINOPR"
		end
	end
	luaY.priority = {
		{ 6, 6 },
		{ 6, 6 },
		{ 7, 7 },
		{ 7, 7 },
		{ 7, 7 },
		{ 10, 9 },
		{ 5, 4 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 2, 2 },
		{ 1, 1 },
	}
	luaY.UNARY_PRIORITY = 8
	function luaY:subexpr(ls, v, limit)
		self:enterlevel(ls)
		local uop = self:getunopr(ls.t.token)
		if uop ~= "OPR_NOUNOPR" then
			luaX:next(ls)
			self:subexpr(ls, v, self.UNARY_PRIORITY)
			luaK:prefix(ls.fs, uop, v)
		else
			self:simpleexp(ls, v)
		end
		local op = self:getbinopr(ls.t.token)
		while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
			local v2 = {}
			luaX:next(ls)
			luaK:infix(ls.fs, op, v)
			local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
			luaK:posfix(ls.fs, op, v, v2)
			op = nextop
		end
		self:leavelevel(ls)
		return op
	end
	function luaY:expr(ls, v)
		self:subexpr(ls, v, 0)
	end
	function luaY:block_follow(token)
		if
			token == "TK_ELSE"
			or token == "TK_ELSEIF"
			or token == "TK_END"
			or token == "TK_UNTIL"
			or token == "TK_EOS"
		then
			return true
		else
			return false
		end
	end
	function luaY:block(ls)
		local fs = ls.fs
		local bl = {}
		self:enterblock(fs, bl, false)
		self:chunk(ls)
		lua_assert(bl.breaklist == luaK.NO_JUMP)
		self:leaveblock(fs)
	end
	function luaY:check_conflict(ls, lh, v)
		local fs = ls.fs
		local extra = fs.freereg
		local conflict = false
		while lh do
			if lh.v.k == "VINDEXED" then
				if lh.v.info == v.info then
					conflict = true
					lh.v.info = extra
				end
				if lh.v.aux == v.info then
					conflict = true
					lh.v.aux = extra
				end
			end
			lh = lh.prev
		end
		if conflict then
			luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)
			luaK:reserveregs(fs, 1)
		end
	end
	function luaY:assignment(ls, lh, nvars)
		local e = {}
		local c = lh.v.k
		self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL" or c == "VINDEXED", "syntax error")
		if self:testnext(ls, ",") then
			local nv = {}
			nv.v = {}
			nv.prev = lh
			self:primaryexp(ls, nv.v)
			if nv.v.k == "VLOCAL" then
				self:check_conflict(ls, lh, nv.v)
			end
			self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls, "variables in assignment")
			self:assignment(ls, nv, nvars + 1)
		else
			self:checknext(ls, "=")
			local nexps = self:explist1(ls, e)
			if nexps ~= nvars then
				self:adjust_assign(ls, nvars, nexps, e)
				if nexps > nvars then
					ls.fs.freereg = ls.fs.freereg - (nexps - nvars)
				end
			else
				luaK:setoneret(ls.fs, e)
				luaK:storevar(ls.fs, lh.v, e)
				return
			end
		end
		self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)
		luaK:storevar(ls.fs, lh.v, e)
	end
	function luaY:cond(ls)
		local v = {}
		self:expr(ls, v)
		if v.k == "VNIL" then
			v.k = "VFALSE"
		end
		luaK:goiftrue(ls.fs, v)
		return v.f
	end
	function luaY:breakstat(ls)
		local fs = ls.fs
		local bl = fs.bl
		local upval = false
		while bl and not bl.isbreakable do
			if bl.upval then
				upval = true
			end
			bl = bl.previous
		end
		if not bl then
			luaX:syntaxerror(ls, "no loop to break")
		end
		if upval then
			luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
		end
		bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
	end
	function luaY:whilestat(ls, line)
		local fs = ls.fs
		local bl = {}
		luaX:next(ls)
		local whileinit = luaK:getlabel(fs)
		local condexit = self:cond(ls)
		self:enterblock(fs, bl, true)
		self:checknext(ls, "TK_DO")
		self:block(ls)
		luaK:patchlist(fs, luaK:jump(fs), whileinit)
		self:check_match(ls, "TK_END", "TK_WHILE", line)
		self:leaveblock(fs)
		luaK:patchtohere(fs, condexit)
	end
	function luaY:repeatstat(ls, line)
		local fs = ls.fs
		local repeat_init = luaK:getlabel(fs)
		local bl1, bl2 = {}, {}
		self:enterblock(fs, bl1, true)
		self:enterblock(fs, bl2, false)
		luaX:next(ls)
		self:chunk(ls)
		self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
		local condexit = self:cond(ls)
		if not bl2.upval then
			self:leaveblock(fs)
			luaK:patchlist(ls.fs, condexit, repeat_init)
		else
			self:breakstat(ls)
			luaK:patchtohere(ls.fs, condexit)
			self:leaveblock(fs)
			luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)
		end
		self:leaveblock(fs)
	end
	function luaY:exp1(ls)
		local e = {}
		self:expr(ls, e)
		local k = e.k
		luaK:exp2nextreg(ls.fs, e)
		return k
	end
	function luaY:forbody(ls, base, line, nvars, isnum)
		local bl = {}
		local fs = ls.fs
		self:adjustlocalvars(ls, 3)
		self:checknext(ls, "TK_DO")
		local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP) or luaK:jump(fs)
		self:enterblock(fs, bl, false)
		self:adjustlocalvars(ls, nvars)
		luaK:reserveregs(fs, nvars)
		self:block(ls)
		self:leaveblock(fs)
		luaK:patchtohere(fs, prep)
		local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
			or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
		luaK:fixline(fs, line)
		luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
	end
	function luaY:fornum(ls, varname, line)
		local fs = ls.fs
		local base = fs.freereg
		self:new_localvarliteral(ls, "(for index)", 0)
		self:new_localvarliteral(ls, "(for limit)", 1)
		self:new_localvarliteral(ls, "(for step)", 2)
		self:new_localvar(ls, varname, 3)
		self:checknext(ls, "=")
		self:exp1(ls)
		self:checknext(ls, ",")
		self:exp1(ls)
		if self:testnext(ls, ",") then
			self:exp1(ls)
		else
			luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
			luaK:reserveregs(fs, 1)
		end
		self:forbody(ls, base, line, 1, true)
	end
	function luaY:forlist(ls, indexname)
		local fs = ls.fs
		local e = {}
		local nvars = 0
		local base = fs.freereg
		self:new_localvarliteral(ls, "(for generator)", nvars)
		nvars = nvars + 1
		self:new_localvarliteral(ls, "(for state)", nvars)
		nvars = nvars + 1
		self:new_localvarliteral(ls, "(for control)", nvars)
		nvars = nvars + 1
		self:new_localvar(ls, indexname, nvars)
		nvars = nvars + 1
		while self:testnext(ls, ",") do
			self:new_localvar(ls, self:str_checkname(ls), nvars)
			nvars = nvars + 1
		end
		self:checknext(ls, "TK_IN")
		local line = ls.linenumber
		self:adjust_assign(ls, 3, self:explist1(ls, e), e)
		luaK:checkstack(fs, 3)
		self:forbody(ls, base, line, nvars - 3, false)
	end
	function luaY:forstat(ls, line)
		local fs = ls.fs
		local bl = {}
		self:enterblock(fs, bl, true)
		luaX:next(ls)
		local varname = self:str_checkname(ls)
		local c = ls.t.token
		if c == "=" then
			self:fornum(ls, varname, line)
		elseif c == "," or c == "TK_IN" then
			self:forlist(ls, varname)
		else
			luaX:syntaxerror(ls, self:LUA_QL("=") .. " or " .. self:LUA_QL("in") .. " expected")
		end
		self:check_match(ls, "TK_END", "TK_FOR", line)
		self:leaveblock(fs)
	end
	function luaY:test_then_block(ls)
		luaX:next(ls)
		local condexit = self:cond(ls)
		self:checknext(ls, "TK_THEN")
		self:block(ls)
		return condexit
	end
	function luaY:ifstat(ls, line)
		local fs = ls.fs
		local escapelist = luaK.NO_JUMP
		local flist = self:test_then_block(ls)
		while ls.t.token == "TK_ELSEIF" do
			escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
			luaK:patchtohere(fs, flist)
			flist = self:test_then_block(ls)
		end
		if ls.t.token == "TK_ELSE" then
			escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
			luaK:patchtohere(fs, flist)
			luaX:next(ls)
			self:block(ls)
		else
			escapelist = luaK:concat(fs, escapelist, flist)
		end
		luaK:patchtohere(fs, escapelist)
		self:check_match(ls, "TK_END", "TK_IF", line)
	end
	function luaY:localfunc(ls)
		local v, b = {}, {}
		local fs = ls.fs
		self:new_localvar(ls, self:str_checkname(ls), 0)
		self:init_exp(v, "VLOCAL", fs.freereg)
		luaK:reserveregs(fs, 1)
		self:adjustlocalvars(ls, 1)
		self:body(ls, b, false, ls.linenumber)
		luaK:storevar(fs, v, b)
		self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
	end
	function luaY:localstat(ls)
		local nvars = 0
		local nexps
		local e = {}
		repeat
			self:new_localvar(ls, self:str_checkname(ls), nvars)
			nvars = nvars + 1
		until not self:testnext(ls, ",")
		if self:testnext(ls, "=") then
			nexps = self:explist1(ls, e)
		else
			e.k = "VVOID"
			nexps = 0
		end
		self:adjust_assign(ls, nvars, nexps, e)
		self:adjustlocalvars(ls, nvars)
	end
	function luaY:funcname(ls, v)
		local needself = false
		self:singlevar(ls, v)
		while ls.t.token == "." do
			self:field(ls, v)
		end
		if ls.t.token == ":" then
			needself = true
			self:field(ls, v)
		end
		return needself
	end
	function luaY:funcstat(ls, line)
		local v, b = {}, {}
		luaX:next(ls)
		local needself = self:funcname(ls, v)
		self:body(ls, b, needself, line)
		luaK:storevar(ls.fs, v, b)
		luaK:fixline(ls.fs, line)
	end
	function luaY:exprstat(ls)
		local fs = ls.fs
		local v = {}
		v.v = {}
		self:primaryexp(ls, v.v)
		if v.v.k == "VCALL" then
			luaP:SETARG_C(luaK:getcode(fs, v.v), 1)
		else
			v.prev = nil
			self:assignment(ls, v, 1)
		end
	end
	function luaY:retstat(ls)
		local fs = ls.fs
		local e = {}
		local first, nret
		luaX:next(ls)
		if self:block_follow(ls.t.token) or ls.t.token == ";" then
			first, nret = 0, 0
		else
			nret = self:explist1(ls, e)
			if self:hasmultret(e.k) then
				luaK:setmultret(fs, e)
				if e.k == "VCALL" and nret == 1 then
					luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
					lua_assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
				end
				first = fs.nactvar
				nret = self.LUA_MULTRET
			else
				if nret == 1 then
					first = luaK:exp2anyreg(fs, e)
				else
					luaK:exp2nextreg(fs, e)
					first = fs.nactvar
					lua_assert(nret == fs.freereg - first)
				end
			end
		end
		luaK:ret(fs, first, nret)
	end
	function luaY:statement(ls)
		local line = ls.linenumber
		local c = ls.t.token
		if c == "TK_IF" then
			self:ifstat(ls, line)
			return false
		elseif c == "TK_WHILE" then
			self:whilestat(ls, line)
			return false
		elseif c == "TK_DO" then
			luaX:next(ls)
			self:block(ls)
			self:check_match(ls, "TK_END", "TK_DO", line)
			return false
		elseif c == "TK_FOR" then
			self:forstat(ls, line)
			return false
		elseif c == "TK_REPEAT" then
			self:repeatstat(ls, line)
			return false
		elseif c == "TK_FUNCTION" then
			self:funcstat(ls, line)
			return false
		elseif c == "TK_LOCAL" then
			luaX:next(ls)
			if self:testnext(ls, "TK_FUNCTION") then
				self:localfunc(ls)
			else
				self:localstat(ls)
			end
			return false
		elseif c == "TK_RETURN" then
			self:retstat(ls)
			return true
		elseif c == "TK_BREAK" then
			luaX:next(ls)
			self:breakstat(ls)
			return true
		else
			self:exprstat(ls)
			return false
		end
	end
	function luaY:chunk(ls)
		local islast = false
		self:enterlevel(ls)
		while not islast and not self:block_follow(ls.t.token) do
			islast = self:statement(ls)
			self:testnext(ls, ";")
			lua_assert(ls.fs.f.maxstacksize >= ls.fs.freereg and ls.fs.freereg >= ls.fs.nactvar)
			ls.fs.freereg = ls.fs.nactvar
		end
		self:leavelevel(ls)
	end
	luaX:init()
	local LuaState = {}
	compile = function(source, name_)
		name = name_ or "compiled-lua"
		local zio = luaZ:init(luaZ:make_getF(source), nil)
		if not zio then
			return
		end
		local func = luaY:parser(LuaState, zio, nil, "@" .. name)
		local writer, buff = luaU:make_setS()
		luaU:dump(LuaState, func, writer, buff)
		return buff.data
	end
end
local createExecutable
do
	local lua_wrap_state
	local stm_lua_func
	local FIELDS_PER_FLUSH = 50
	local OPCODE_RM = {
		[22] = 18,
		[31] = 8,
		[33] = 28,
		[0] = 3,
		[1] = 13,
		[2] = 23,
		[26] = 33,
		[12] = 1,
		[13] = 6,
		[14] = 10,
		[15] = 16,
		[16] = 20,
		[17] = 26,
		[18] = 30,
		[19] = 36,
		[3] = 0,
		[4] = 2,
		[5] = 4,
		[6] = 7,
		[7] = 9,
		[8] = 12,
		[9] = 14,
		[10] = 17,
		[20] = 19,
		[21] = 22,
		[23] = 24,
		[24] = 27,
		[25] = 29,
		[27] = 32,
		[32] = 34,
		[34] = 37,
		[11] = 5,
		[28] = 11,
		[29] = 15,
		[30] = 21,
		[35] = 25,
		[36] = 31,
		[37] = 35,
	}
	local OPCODE_T = {
		[0] = "ABC",
		"ABx",
		"ABC",
		"ABC",
		"ABC",
		"ABx",
		"ABC",
		"ABx",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"AsBx",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"AsBx",
		"AsBx",
		"ABC",
		"ABC",
		"ABC",
		"ABx",
		"ABC",
	}
	local OPCODE_M = {
		[0] = { b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgR" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgR", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgN", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgN", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
	}
	local function rd_int_basic(src, s, e, d)
		local num = 0
		for i = s, e, d do
			local mul = 256 ^ math.abs(i - s)
			num = num + mul * string.byte(src, i, i)
		end
		return num
	end
	local function rd_flt_basic(f1, f2, f3, f4)
		local sign = (-1) ^ bit32.rshift(f4, 7)
		local exp = bit32.rshift(f3, 7) + bit32.lshift(bit32.band(f4, 0x7F), 1)
		local frac = f1 + bit32.lshift(f2, 8) + bit32.lshift(bit32.band(f3, 0x7F), 16)
		local normal = 1
		if exp == 0 then
			if frac == 0 then
				return sign * 0
			else
				normal = 0
				exp = 1
			end
		elseif exp == 0x7F then
			if frac == 0 then
				return sign * (1 / 0)
			else
				return sign * (0 / 0)
			end
		end
		return sign * 2 ^ (exp - 127) * (1 + normal / 2 ^ 23)
	end
	local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
		local sign = (-1) ^ bit32.rshift(f8, 7)
		local exp = bit32.lshift(bit32.band(f8, 0x7F), 4) + bit32.rshift(f7, 4)
		local frac = bit32.band(f7, 0x0F) * 2 ^ 48
		local normal = 1
		frac = frac + (f6 * 2 ^ 40) + (f5 * 2 ^ 32) + (f4 * 2 ^ 24) + (f3 * 2 ^ 16) + (f2 * 2 ^ 8) + f1
		if exp == 0 then
			if frac == 0 then
				return sign * 0
			else
				normal = 0
				exp = 1
			end
		elseif exp == 0x7FF then
			if frac == 0 then
				return sign * (1 / 0)
			else
				return sign * (0 / 0)
			end
		end
		return sign * 2 ^ (exp - 1023) * (normal + frac / 2 ^ 52)
	end
	local function rd_int_le(src, s, e)
		return rd_int_basic(src, s, e - 1, 1)
	end
	local function rd_int_be(src, s, e)
		return rd_int_basic(src, e - 1, s, -1)
	end
	local function rd_flt_le(src, s)
		return rd_flt_basic(string.byte(src, s, s + 3))
	end
	local function rd_flt_be(src, s)
		local f1, f2, f3, f4 = string.byte(src, s, s + 3)
		return rd_flt_basic(f4, f3, f2, f1)
	end
	local function rd_dbl_le(src, s)
		return rd_dbl_basic(string.byte(src, s, s + 7))
	end
	local function rd_dbl_be(src, s)
		local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7)
		return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1)
	end
	local float_types = {
		[4] = { little = rd_flt_le, big = rd_flt_be },
		[8] = { little = rd_dbl_le, big = rd_dbl_be },
	}
	local function stm_byte(S)
		local idx = S.index
		local bt = string.byte(S.source, idx, idx)
		S.index = idx + 1
		return bt
	end
	local function stm_string(S, len)
		local pos = S.index + len
		local str = string.sub(S.source, S.index, pos - 1)
		S.index = pos
		return str
	end
	local function stm_lstring(S)
		local len = S:s_szt()
		local str
		if len ~= 0 then
			str = string.sub(stm_string(S, len), 1, -2)
		end
		return str
	end
	local function cst_int_rdr(len, func)
		return function(S)
			local pos = S.index + len
			local int = func(S.source, S.index, pos)
			S.index = pos
			return int
		end
	end
	local function cst_flt_rdr(len, func)
		return function(S)
			local flt = func(S.source, S.index)
			S.index = S.index + len
			return flt
		end
	end
	local function stm_inst_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			local ins = S:s_ins()
			local op = bit32.band(ins, 0x3F)
			local args = OPCODE_T[op]
			local mode = OPCODE_M[op]
			local data = { value = ins, op = OPCODE_RM[op], A = bit32.band(bit32.rshift(ins, 6), 0xFF) }
			if args == "ABC" then
				data.B = bit32.band(bit32.rshift(ins, 23), 0x1FF)
				data.C = bit32.band(bit32.rshift(ins, 14), 0x1FF)
				data.is_KB = mode.b == "OpArgK" and data.B > 0xFF
				data.is_KC = mode.c == "OpArgK" and data.C > 0xFF
			elseif args == "ABx" then
				data.Bx = bit32.band(bit32.rshift(ins, 14), 0x3FFFF)
				data.is_K = mode.b == "OpArgK"
			elseif args == "AsBx" then
				data.sBx = bit32.band(bit32.rshift(ins, 14), 0x3FFFF) - 131071
			end
			list[i] = data
		end
		return list
	end
	local function stm_const_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			local tt = stm_byte(S)
			local k
			if tt == 1 then
				k = stm_byte(S) ~= 0
			elseif tt == 3 then
				k = S:s_num()
			elseif tt == 4 then
				k = stm_lstring(S)
			end
			list[i] = k
		end
		return list
	end
	local function stm_sub_list(S, src)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = stm_lua_func(S, src)
		end
		return list
	end
	local function stm_line_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = S:s_int()
		end
		return list
	end
	local function stm_loc_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = { varname = stm_lstring(S), startpc = S:s_int(), endpc = S:s_int() }
		end
		return list
	end
	local function stm_upval_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = stm_lstring(S)
		end
		return list
	end
	function stm_lua_func(S, psrc)
		local proto = {}
		local src = stm_lstring(S) or psrc
		proto.source = src
		S:s_int()
		S:s_int()
		proto.num_upval = stm_byte(S)
		proto.num_param = stm_byte(S)
		stm_byte(S)
		proto.max_stack = stm_byte(S)
		proto.code = stm_inst_list(S)
		proto.const = stm_const_list(S)
		proto.subs = stm_sub_list(S, src)
		proto.lines = stm_line_list(S)
		stm_loc_list(S)
		stm_upval_list(S)
		for _, v in ipairs(proto.code) do
			if v.is_K then
				v.const = proto.const[v.Bx + 1]
			else
				if v.is_KB then
					v.const_B = proto.const[v.B - 0xFF]
				end
				if v.is_KC then
					v.const_C = proto.const[v.C - 0xFF]
				end
			end
		end
		return proto
	end
	local function lua_bc_to_state(src)
		local rdr_func
		local little
		local size_int
		local size_szt
		local size_ins
		local size_num
		local flag_int
		local stream = {
			index = 1,
			source = src,
		}
		assert(stm_string(stream, 4) == "\27Lua", "invalid Lua signature")
		assert(stm_byte(stream) == 0x51, "invalid Lua version")
		assert(stm_byte(stream) == 0, "invalid Lua format")
		little = stm_byte(stream) ~= 0
		size_int = stm_byte(stream)
		size_szt = stm_byte(stream)
		size_ins = stm_byte(stream)
		size_num = stm_byte(stream)
		flag_int = stm_byte(stream) ~= 0
		rdr_func = little and rd_int_le or rd_int_be
		stream.s_int = cst_int_rdr(size_int, rdr_func)
		stream.s_szt = cst_int_rdr(size_szt, rdr_func)
		stream.s_ins = cst_int_rdr(size_ins, rdr_func)
		if flag_int then
			stream.s_num = cst_int_rdr(size_num, rdr_func)
		elseif float_types[size_num] then
			stream.s_num = cst_flt_rdr(size_num, float_types[size_num][little and "little" or "big"])
		else
			error("unsupported float size")
		end
		return stm_lua_func(stream, "@virtual")
	end
	local function close_lua_upvalues(list, index)
		for i, uv in pairs(list) do
			if uv.index >= index then
				uv.value = uv.store[uv.index]
				uv.store = uv
				uv.index = "value"
				list[i] = nil
			end
		end
	end
	local function open_lua_upvalue(list, index, memory)
		local prev = list[index]
		if not prev then
			prev = { index = index, store = memory }
			list[index] = prev
		end
		return prev
	end
	local function on_lua_error(failed, err)
		local src = failed.source
		local line = failed.lines[failed.pc - 1]
		error(string.format("%s:%i: %s", src, line, err), 0)
	end
	local function run_lua_func(state, env, upvals)
		local code = state.code
		local subs = state.subs
		local vararg = state.vararg
		local top_index = -1
		local open_list = {}
		local memory = state.memory
		local pc = state.pc
		while true do
			local inst = code[pc]
			local op = inst.op
			pc = pc + 1
			if op < 18 then
				if op < 8 then
					if op < 3 then
						if op < 1 then
							for i = inst.A, inst.B do
								memory[i] = nil
							end
						elseif op > 1 then
							local uv = upvals[inst.B]
							memory[inst.A] = uv.store[uv.index]
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs + rhs
						end
					elseif op > 3 then
						if op < 6 then
							if op > 4 then
								local A = inst.A
								local B = inst.B
								local index
								if inst.is_KC then
									index = inst.const_C
								else
									index = memory[inst.C]
								end
								memory[A + 1] = memory[B]
								memory[A] = memory[B][index]
							else
								memory[inst.A] = env[inst.const]
							end
						elseif op > 6 then
							local index
							if inst.is_KC then
								index = inst.const_C
							else
								index = memory[inst.C]
							end
							memory[inst.A] = memory[inst.B][index]
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs - rhs
						end
					else
						memory[inst.A] = memory[inst.B]
					end
				elseif op > 8 then
					if op < 13 then
						if op < 10 then
							env[inst.const] = memory[inst.A]
						elseif op > 10 then
							if op < 12 then
								local A = inst.A
								local B = inst.B
								local C = inst.C
								local params
								if B == 0 then
									params = top_index - A
								else
									params = B - 1
								end
								local ret_list = table.pack(memory[A](table.unpack(memory, A + 1, A + params)))
								local ret_num = ret_list.n
								if C == 0 then
									top_index = A + ret_num - 1
								else
									ret_num = C - 1
								end
								table.move(ret_list, 1, ret_num, A, memory)
							else
								local uv = upvals[inst.B]
								uv.store[uv.index] = memory[inst.A]
							end
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs * rhs
						end
					elseif op > 13 then
						if op < 16 then
							if op > 14 then
								local A = inst.A
								local B = inst.B
								local params
								if B == 0 then
									params = top_index - A
								else
									params = B - 1
								end
								close_lua_upvalues(open_list, 0)
								return memory[A](table.unpack(memory, A + 1, A + params))
							else
								local index, value
								if inst.is_KB then
									index = inst.const_B
								else
									index = memory[inst.B]
								end
								if inst.is_KC then
									value = inst.const_C
								else
									value = memory[inst.C]
								end
								memory[inst.A][index] = value
							end
						elseif op > 16 then
							memory[inst.A] = {}
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs / rhs
						end
					else
						memory[inst.A] = inst.const
					end
				else
					local A = inst.A
					local step = memory[A + 2]
					local index = memory[A] + step
					local limit = memory[A + 1]
					local loops
					if step == math.abs(step) then
						loops = index <= limit
					else
						loops = index >= limit
					end
					if loops then
						memory[A] = index
						memory[A + 3] = index
						pc = pc + inst.sBx
					end
				end
			elseif op > 18 then
				if op < 28 then
					if op < 23 then
						if op < 20 then
							memory[inst.A] = #memory[inst.B]
						elseif op > 20 then
							if op < 22 then
								local A = inst.A
								local B = inst.B
								local len
								if B == 0 then
									len = top_index - A + 1
								else
									len = B - 1
								end
								close_lua_upvalues(open_list, 0)
								return table.unpack(memory, A, A + len - 1)
							else
								local B = inst.B
								local str = memory[B]
								for i = B + 1, inst.C do
									str = str .. memory[i]
								end
								memory[inst.A] = str
							end
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs % rhs
						end
					elseif op > 23 then
						if op < 26 then
							if op > 24 then
								close_lua_upvalues(open_list, inst.A)
							else
								local lhs, rhs
								if inst.is_KB then
									lhs = inst.const_B
								else
									lhs = memory[inst.B]
								end
								if inst.is_KC then
									rhs = inst.const_C
								else
									rhs = memory[inst.C]
								end
								if (lhs == rhs) == (inst.A ~= 0) then
									pc = pc + code[pc].sBx
								end
								pc = pc + 1
							end
						elseif op > 26 then
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							if (lhs < rhs) == (inst.A ~= 0) then
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs ^ rhs
						end
					else
						memory[inst.A] = inst.B ~= 0
						if inst.C ~= 0 then
							pc = pc + 1
						end
					end
				elseif op > 28 then
					if op < 33 then
						if op < 30 then
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							if (lhs <= rhs) == (inst.A ~= 0) then
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						elseif op > 30 then
							if op < 32 then
								local sub = subs[inst.Bx + 1]
								local nups = sub.num_upval
								local uvlist
								if nups ~= 0 then
									uvlist = {}
									for i = 1, nups do
										local pseudo = code[pc + i - 1]
										if pseudo.op == OPCODE_RM[0] then
											uvlist[i - 1] = open_lua_upvalue(open_list, pseudo.B, memory)
										elseif pseudo.op == OPCODE_RM[4] then
											uvlist[i - 1] = upvals[pseudo.B]
										end
									end
									pc = pc + nups
								end
								memory[inst.A] = lua_wrap_state(sub, env, uvlist)
							else
								local A = inst.A
								local B = inst.B
								if (not memory[B]) ~= (inst.C ~= 0) then
									memory[A] = memory[B]
									pc = pc + code[pc].sBx
								end
								pc = pc + 1
							end
						else
							memory[inst.A] = -memory[inst.B]
						end
					elseif op > 33 then
						if op < 36 then
							if op > 34 then
								local A = inst.A
								local len = inst.B
								if len == 0 then
									len = vararg.len
									top_index = A + len - 1
								end
								table.move(vararg.list, 1, len, A, memory)
							else
								local A = inst.A
								local init, limit, step
								init = assert(tonumber(memory[A]), "`for` initial value must be a number")
								limit = assert(tonumber(memory[A + 1]), "`for` limit must be a number")
								step = assert(tonumber(memory[A + 2]), "`for` step must be a number")
								memory[A] = init - step
								memory[A + 1] = limit
								memory[A + 2] = step
								pc = pc + inst.sBx
							end
						elseif op > 36 then
							local A = inst.A
							local C = inst.C
							local len = inst.B
							local tab = memory[A]
							local offset
							if len == 0 then
								len = top_index - A
							end
							if C == 0 then
								C = inst[pc].value
								pc = pc + 1
							end
							offset = (C - 1) * FIELDS_PER_FLUSH
							table.move(memory, A + 1, A + len, offset + 1, tab)
						else
							memory[inst.A] = not memory[inst.B]
						end
					else
						if (not memory[inst.A]) ~= (inst.C ~= 0) then
							pc = pc + code[pc].sBx
						end
						pc = pc + 1
					end
				else
					local A = inst.A
					local base = A + 3
					local vals = { memory[A](memory[A + 1], memory[A + 2]) }
					table.move(vals, 1, inst.C, base, memory)
					if memory[base] ~= nil then
						memory[A + 2] = memory[base]
						pc = pc + code[pc].sBx
					end
					pc = pc + 1
				end
			else
				pc = pc + inst.sBx
			end
			state.pc = pc
		end
	end
	function lua_wrap_state(proto, env, upval)
		local function wrapped(...)
			local passed = table.pack(...)
			local memory = table.create(proto.max_stack)
			local vararg = { len = 0, list = {} }
			table.move(passed, 1, proto.num_param, 0, memory)
			if proto.num_param < passed.n then
				local start = proto.num_param + 1
				local len = passed.n - proto.num_param
				vararg.len = len
				table.move(passed, start, start + len - 1, 1, vararg.list)
			end
			local state = { vararg = vararg, memory = memory, code = proto.code, subs = proto.subs, pc = 1 }
			local result = table.pack(pcall(run_lua_func, state, env, upval))
			if result[1] then
				return table.unpack(result, 2, result.n)
			else
				local failed = { pc = state.pc, source = proto.source, lines = proto.lines }
				on_lua_error(failed, result[2])
				return
			end
		end
		return wrapped
	end
	createExecutable = function(bCode, env)
		return lua_wrap_state(lua_bc_to_state(bCode), env or getfenv(0))
	end
end
getfenv().script = nil

return setmetatable({},{__metatable={"Protected metatable"},__call=function(self,source,env)
	local executable
	for i,v in getfenv(2) do 
		getfenv(1)[i] = v
	end
	local env = getfenv(1)
	local name = (env.script and env.script:GetFullName())
	local ran, failureReason = pcall(function()
		local compiledBytecode = compile(source, name)
		executable = createExecutable(compiledBytecode, env)
	end)

	if ran then
		return setmetatable({},{__metatable="protected loadstring",__call=function(self,...)
			return setfenv(executable, env)(...)
		end})
	end
	return nil, failureReason
end,})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX4E30B79F9E034B1CB2E0FD4EF505221D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">modules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX20C190C40E514CEA8FF8B66F3AE1F5DE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">C# module</string>
					<string name="ScriptGuid">{25F1671A-68AE-41B2-A4CB-15FB4F951626}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}
function module.StartWith(str,wat)
	if typeof(str) ~= "string" then error("Argument is not a string") return end
	if typeof(wat) ~= "string" then error("Argument 2 is not a string") return end
	local ret = false
	ret = string.sub(str,0,#wat) == wat
	return ret
end

function module.EndsWith(str,wat)
	if typeof(str) ~= "string" then error("Argument is not a string") return end
	if typeof(wat) ~= "string" then error("Argument 2 is not a string") return end
	local ret = false
	ret = string.sub(str,#str+1-#wat,#str) == wat
	return ret
end

function module.Replace(str,replace,wat,number)
	if typeof(str) ~= "string" then error("Argument is not a string") return end
	if typeof(replace) ~= "string" then error("Argument 2 is not a string") return end
	if typeof(wat) ~= "string" then error("Argument 3 is not a string") return end
	if typeof(number) ~= "number" then error("Argument 4 is not a number") return end
	
	return string.gsub(str,replace,wat,number)
end

function module.Reverse(str)
	if typeof(wat) ~= "string" then error("Argument is not a string") return end
	return string.reverse(str)
end

function module.CloneTableWithInstance(tab)
	local ret = {}
	if typeof(tab) ~= "table" then error("Argument is not a table") return end
	for i,v in pairs(tab) 	 do
		if typeof(v) == "Instance" then
			ret[i] = v	:Clone()
		else
			ret[i] = v
		end
	end
	return ret
end

function module.CloneTable(tab)
	local ret = {}
	if typeof(tab) ~= "table" then error("Argument is not a table") return end
	for i,v in pairs(tab) 	 do
		ret[i] = v
	end
	return ret
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">11992834257</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXB67C8A58B7A54214870117EF95F505DC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ServerScript Emulator</string>
					<string name="ScriptGuid">{D6ECC4D2-656D-4CB6-BBB2-8B6DC8AF66D8}</string>
					<ProtectedString name="Source"><![CDATA[local firstrun = true
local scriptid = nil
local source = nil	
local property = nil
local compiler = nil
local scriptsource = nil
local connects = {load = {},connects={}}
local alreadyrunning = {}

local function checkonplayers(check)
	local check = check or script
	local ret = false
	for i,v in game:GetService("Players"):GetPlayers() do
		if check:IsDescendantOf(v) then ret = true break end
	end
	return ret
end
local function ifcanrun(check)
	local check = check or script
	--print(check,check:IsDescendantOf(workspace) , check:IsDescendantOf(game:GetService("ServerScriptService") , checkonplayers(check)) and not check.Disabled)
	if (check:IsDescendantOf(workspace) or check:IsDescendantOf(game:GetService("ServerScriptService") or checkonplayers(check))) and not check.Disabled and not table.find(alreadyrunning,check) then
		table.insert(alreadyrunning,check)
		print(check,"script is running")
		local fenv = getfenv(source)
		fenv["script"] = check

		local j=  setmetatable({}, {
			__index = function(_, index)
				return fenv[index]
			end
		})

		setfenv(source,j)

		source()

		return true
	end
	return false
end

return function(...)

	if property == "ModuleScript" and not firstrun then
		return source()
	end

	if firstrun then
		local args = table.pack(...)
		compiler = script.compiler
		compiler.Parent = nil
		--if args[4] == "ModuleScript" then
		args[5]["script"] = args[1]

		source = require(compiler)(args[5],args[2])
		--end
		--print(args[1])
		script = args[1]--["script"]

		--print(script.ClassName)
		--	scriptsource = args[2]
		scriptid = args[3]
		property = args[4]
		firstrun = false
		if property == "ModuleScript" then return true end
		connects["connects"][args[1]] = {}

		game.DescendantAdded:Connect(function(v)
			if v:IsA("Script") and v:GetAttribute("id") == scriptid and v:GetAttribute("property") == property then
				connects["connects"][v] = {}
				ifcanrun(v)

				table.insert(connects["connects"][v],v:GetPropertyChangedSignal("Disabled"):Connect(function()
					if ifcanrun(v) then
						for i,v in connects["connects"][v] do v:Disconnect() end
					end
				end))

				table.insert(connects["connects"][v],v:GetPropertyChangedSignal("Parent"):Connect(function()
					if ifcanrun(v) then
						for i,v in connects["connects"][v] do v:Disconnect() end	
					end
				end))

			end
		end)

		game:GetService("ServerScriptService").DescendantAdded:Connect(function(v)

			if v:IsA("Script") and v:GetAttribute("id") == scriptid and v:GetAttribute("property") == property then
				connects["connects"][v] = {}
				ifcanrun(v)

				table.insert(connects["connects"][v],v:GetPropertyChangedSignal("Disabled"):Connect(function()
					if ifcanrun(v) then
						for i,v in connects["connects"][v] do v:Disconnect() end
					end
				end))

				table.insert(connects["connects"][v],v:GetPropertyChangedSignal("Parent"):Connect(function()
					if ifcanrun(v) then
						for i,v in connects["connects"][v] do v:Disconnect() end	
					end
				end))

			end
		end)



	end
	return true
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8C796F5CD06347DE9F71D4D042F8945A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">compiler</string>
						<string name="ScriptGuid">{DAA7A22A-2045-40DB-9965-2B739F7D0B36}</string>
						<ProtectedString name="Source"><![CDATA[local moduleload = false
local function compile(sfenv,source, additionalEnv, ...)
	if moduleload then
		for i,v in sfenv do 
			getfenv(2)[i] = v
		end
	end

	local compiled = loadstring(source)
	
	if compiled == nil then
		warn("source is none or source got error")
		local s,err = pcall(function()
			loadstring(source)()
		end)
		error(err)
		return nil
	end
	
	if not moduleload then
		local fenv = getfenv(compiled)
		for i,v in sfenv do 
			fenv[i] = v
		end
		local j=  setmetatable(additionalEnv or {}, {
			__index = function(_, index)
				return fenv[index]
			end,
			__tostring = function(_)
				return "You cant know getfenv bc yes"
			end,
		})
		
		setfenv(compiled, fenv)
	end
	
	return compiled
end

return function(fenv,scriptt)
	if not pcall(loadstring, "--") then
		warn("Loadstring set on custom")
		getfenv().loadstring = require(script.b)
		moduleload = true
	end
	local sandbox
	if typeof(scriptt) == "table" then
		sandbox = compile(fenv,table.concat(scriptt,"\n"))
	else
		sandbox = compile(fenv,scriptt)
	end

	return sandbox
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA474CF70EDD141579EB9F19752AFB0F8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">b</string>
							<string name="ScriptGuid">{DD024919-BD50-436F-9F93-47E20159B928}</string>
							<ProtectedString name="Source"><![CDATA[local compile
do
	local name
	local luaZ = {}
	local luaY = {}
	local luaX = {}
	local luaP = {}
	local luaU = {}
	local luaK = {}
	local size_size_t = 8
	local function lua_assert(test)
		if not test then
			error("assertion failed!")
		end
	end
	function luaZ:make_getS(buff)
		local b = buff
		return function()
			if not b then
				return nil
			end
			local data = b
			b = nil
			return data
		end
	end
	function luaZ:make_getF(source)
		local LUAL_BUFFERSIZE = 512
		local pos = 1
		return function()
			local buff = source:sub(pos, pos + LUAL_BUFFERSIZE - 1)
			pos = math.min(#source + 1, pos + LUAL_BUFFERSIZE)
			return buff
		end
	end
	function luaZ:init(reader, data)
		if not reader then
			return
		end
		local z = {}
		z.reader = reader
		z.data = data or ""
		z.name = name
		if not data or data == "" then
			z.n = 0
		else
			z.n = #data
		end
		z.p = 0
		return z
	end
	function luaZ:fill(z)
		local buff = z.reader()
		z.data = buff
		if not buff or buff == "" then
			return "EOZ"
		end
		z.n, z.p = #buff - 1, 1
		return string.sub(buff, 1, 1)
	end
	function luaZ:zgetc(z)
		local n, p = z.n, z.p + 1
		if n > 0 then
			z.n, z.p = n - 1, p
			return string.sub(z.data, p, p)
		else
			return self:fill(z)
		end
	end
	luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]
	luaX.MAXSRC = 80
	luaX.MAX_INT = 2147483645
	luaX.LUA_QS = "'%s'"
	luaX.LUA_COMPAT_LSTR = 1
	function luaX:init()
		local tokens, enums = {}, {}
		for v in string.gmatch(self.RESERVED, "[^\n]+") do
			local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)")
			tokens[tok] = str
			enums[str] = tok
		end
		self.tokens = tokens
		self.enums = enums
	end
	function luaX:chunkid(source, bufflen)
		local out
		local first = string.sub(source, 1, 1)
		if first == "=" then
			out = string.sub(source, 2, bufflen)
		else
			if first == "@" then
				source = string.sub(source, 2)
				bufflen = bufflen - #" '...' "
				local l = #source
				out = ""
				if l > bufflen then
					source = string.sub(source, 1 + l - bufflen)
					out = out .. "..."
				end
				out = out .. source
			else
				local len = string.find(source, "[\n\r]")
				len = len and (len - 1) or #source
				bufflen = bufflen - #' [string "..."] '
				if len > bufflen then
					len = bufflen
				end
				out = '[string "'
				if len < #source then
					out = out .. string.sub(source, 1, len) .. "..."
				else
					out = out .. source
				end
				out = out .. '"]'
			end
		end
		return out
	end
	function luaX:token2str(_, token)
		if string.sub(token, 1, 3) ~= "TK_" then
			if string.find(token, "%c") then
				return string.format("char(%d)", string.byte(token))
			end
			return token
		else
			return self.tokens[token]
		end
	end
	function luaX:lexerror(ls, msg, token)
		local function txtToken(ls, token)
			if token == "TK_NAME" or token == "TK_STRING" or token == "TK_NUMBER" then
				return ls.buff
			else
				return self:token2str(ls, token)
			end
		end
		local buff = self:chunkid(ls.source, self.MAXSRC)
		local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg)
		if token then
			msg = string.format("%s near " .. self.LUA_QS, msg, txtToken(ls, token))
		end
		error(msg)
	end
	function luaX:syntaxerror(ls, msg)
		self:lexerror(ls, msg, ls.t.token)
	end
	function luaX:currIsNewline(ls)
		return ls.current == "\n" or ls.current == "\r"
	end
	function luaX:inclinenumber(ls)
		local old = ls.current
		self:nextc(ls)
		if self:currIsNewline(ls) and ls.current ~= old then
			self:nextc(ls)
		end
		ls.linenumber = ls.linenumber + 1
		if ls.linenumber >= self.MAX_INT then
			self:syntaxerror(ls, "chunk has too many lines")
		end
	end
	function luaX:setinput(L, ls, z, source)
		if not ls then
			ls = {}
		end
		if not ls.lookahead then
			ls.lookahead = {}
		end
		if not ls.t then
			ls.t = {}
		end
		ls.decpoint = "."
		ls.L = L
		ls.lookahead.token = "TK_EOS"
		ls.z = z
		ls.fs = nil
		ls.linenumber = 1
		ls.lastline = 1
		ls.source = source
		self:nextc(ls)
	end
	function luaX:check_next(ls, set)
		if not string.find(set, ls.current, 1, 1) then
			return false
		end
		self:save_and_next(ls)
		return true
	end
	function luaX:next(ls)
		ls.lastline = ls.linenumber
		if ls.lookahead.token ~= "TK_EOS" then
			ls.t.seminfo = ls.lookahead.seminfo
			ls.t.token = ls.lookahead.token
			ls.lookahead.token = "TK_EOS"
		else
			ls.t.token = self:llex(ls, ls.t)
		end
	end
	function luaX:lookahead(ls)
		ls.lookahead.token = self:llex(ls, ls.lookahead)
	end
	function luaX:nextc(ls)
		local c = luaZ:zgetc(ls.z)
		ls.current = c
		return c
	end
	function luaX:save(ls, c)
		local buff = ls.buff
		ls.buff = buff .. c
	end
	function luaX:save_and_next(ls)
		self:save(ls, ls.current)
		return self:nextc(ls)
	end
	function luaX:str2d(s)
		local result = tonumber(s)
		if result then
			return result
		end
		if string.lower(string.sub(s, 1, 2)) == "0x" then
			result = tonumber(s, 16)
			if result then
				return result
			end
		end
		return nil
	end
	function luaX:buffreplace(ls, from, to)
		local result, buff = "", ls.buff
		for p = 1, #buff do
			local c = string.sub(buff, p, p)
			if c == from then
				c = to
			end
			result = result .. c
		end
		ls.buff = result
	end
	function luaX:trydecpoint(ls, Token)
		local old = ls.decpoint
		self:buffreplace(ls, old, ls.decpoint)
		local seminfo = self:str2d(ls.buff)
		Token.seminfo = seminfo
		if not seminfo then
			self:buffreplace(ls, ls.decpoint, ".")
			self:lexerror(ls, "malformed number", "TK_NUMBER")
		end
	end
	function luaX:read_numeral(ls, Token)
		repeat
			self:save_and_next(ls)
		until string.find(ls.current, "%D") and ls.current ~= "."
		if self:check_next(ls, "Ee") then
			self:check_next(ls, "+-")
		end
		while string.find(ls.current, "^%w$") or ls.current == "_" do
			self:save_and_next(ls)
		end
		self:buffreplace(ls, ".", ls.decpoint)
		local seminfo = self:str2d(ls.buff)
		Token.seminfo = seminfo
		if not seminfo then
			self:trydecpoint(ls, Token)
		end
	end
	function luaX:skip_sep(ls)
		local count = 0
		local s = ls.current
		self:save_and_next(ls)
		while ls.current == "=" do
			self:save_and_next(ls)
			count = count + 1
		end
		return (ls.current == s) and count or -count - 1
	end
	function luaX:read_long_string(ls, Token, sep)
		local cont = 0
		self:save_and_next(ls)
		if self:currIsNewline(ls) then
			self:inclinenumber(ls)
		end
		while true do
			local c = ls.current
			if c == "EOZ" then
				self:lexerror(ls, Token and "unfinished long string" or "unfinished long comment", "TK_EOS")
			elseif c == "[" then
				if self.LUA_COMPAT_LSTR then
					if self:skip_sep(ls) == sep then
						self:save_and_next(ls)
						cont = cont + 1
						if self.LUA_COMPAT_LSTR == 1 then
							if sep == 0 then
								self:lexerror(ls, "nesting of [[...]] is deprecated", "[")
							end
						end
					end
				end
			elseif c == "]" then
				if self:skip_sep(ls) == sep then
					self:save_and_next(ls)
					if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
						cont = cont - 1
						if sep == 0 and cont >= 0 then
							break
						end
					end
					break
				end
			elseif self:currIsNewline(ls) then
				self:save(ls, "\n")
				self:inclinenumber(ls)
				if not Token then
					ls.buff = ""
				end
			else
				if Token then
					self:save_and_next(ls)
				else
					self:nextc(ls)
				end
			end
		end
		if Token then
			local p = 3 + sep
			Token.seminfo = string.sub(ls.buff, p, -p)
		end
	end
	function luaX:read_string(ls, del, Token)
		self:save_and_next(ls)
		while ls.current ~= del do
			local c = ls.current
			if c == "EOZ" then
				self:lexerror(ls, "unfinished string", "TK_EOS")
			elseif self:currIsNewline(ls) then
				self:lexerror(ls, "unfinished string", "TK_STRING")
			elseif c == "\\" then
				c = self:nextc(ls)
				if self:currIsNewline(ls) then
					self:save(ls, "\n")
					self:inclinenumber(ls)
				elseif c ~= "EOZ" then
					local i = string.find("abfnrtv", c, 1, 1)
					if i then
						self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i))
						self:nextc(ls)
					elseif not string.find(c, "%d") then
						self:save_and_next(ls)
					else
						c, i = 0, 0
						repeat
							c = 10 * c + ls.current
							self:nextc(ls)
							i = i + 1
						until i >= 3 or not string.find(ls.current, "%d")
						if c > 255 then
							self:lexerror(ls, "escape sequence too large", "TK_STRING")
						end
						self:save(ls, string.char(c))
					end
				end
			else
				self:save_and_next(ls)
			end
		end
		self:save_and_next(ls)
		Token.seminfo = string.sub(ls.buff, 2, -2)
	end
	function luaX:llex(ls, Token)
		ls.buff = ""
		while true do
			local c = ls.current
			if self:currIsNewline(ls) then
				self:inclinenumber(ls)
			elseif c == "-" then
				c = self:nextc(ls)
				if c ~= "-" then
					return "-"
				end
				local sep = -1
				if self:nextc(ls) == "[" then
					sep = self:skip_sep(ls)
					ls.buff = ""
				end
				if sep >= 0 then
					self:read_long_string(ls, nil, sep)
					ls.buff = ""
				else
					while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
						self:nextc(ls)
					end
				end
			elseif c == "[" then
				local sep = self:skip_sep(ls)
				if sep >= 0 then
					self:read_long_string(ls, Token, sep)
					return "TK_STRING"
				elseif sep == -1 then
					return "["
				else
					self:lexerror(ls, "invalid long string delimiter", "TK_STRING")
				end
			elseif c == "=" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "="
				else
					self:nextc(ls)
					return "TK_EQ"
				end
			elseif c == "<" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "<"
				else
					self:nextc(ls)
					return "TK_LE"
				end
			elseif c == ">" then
				c = self:nextc(ls)
				if c ~= "=" then
					return ">"
				else
					self:nextc(ls)
					return "TK_GE"
				end
			elseif c == "~" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "~"
				else
					self:nextc(ls)
					return "TK_NE"
				end
			elseif c == '"' or c == "'" then
				self:read_string(ls, c, Token)
				return "TK_STRING"
			elseif c == "." then
				c = self:save_and_next(ls)
				if self:check_next(ls, ".") then
					if self:check_next(ls, ".") then
						return "TK_DOTS"
					else
						return "TK_CONCAT"
					end
				elseif not string.find(c, "%d") then
					return "."
				else
					self:read_numeral(ls, Token)
					return "TK_NUMBER"
				end
			elseif c == "EOZ" then
				return "TK_EOS"
			else
				if string.find(c, "%s") then
					self:nextc(ls)
				elseif string.find(c, "%d") then
					self:read_numeral(ls, Token)
					return "TK_NUMBER"
				elseif string.find(c, "[_%a]") then
					repeat
						c = self:save_and_next(ls)
					until c == "EOZ" or not string.find(c, "[_%w]")
					local ts = ls.buff
					local tok = self.enums[ts]
					if tok then
						return tok
					end
					Token.seminfo = ts
					return "TK_NAME"
				else
					self:nextc(ls)
					return c
				end
			end
		end
	end
	luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 }
	luaP.SIZE_C = 9
	luaP.SIZE_B = 9
	luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B
	luaP.SIZE_A = 8
	luaP.SIZE_OP = 6
	luaP.POS_OP = 0
	luaP.POS_A = luaP.POS_OP + luaP.SIZE_OP
	luaP.POS_C = luaP.POS_A + luaP.SIZE_A
	luaP.POS_B = luaP.POS_C + luaP.SIZE_C
	luaP.POS_Bx = luaP.POS_C
	luaP.MAXARG_Bx = math.ldexp(1, luaP.SIZE_Bx) - 1
	luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)
	luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1
	luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1
	luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1
	function luaP:GET_OPCODE(i)
		return self.ROpCode[i.OP]
	end
	function luaP:SET_OPCODE(i, o)
		i.OP = self.OpCode[o]
	end
	function luaP:GETARG_A(i)
		return i.A
	end
	function luaP:SETARG_A(i, u)
		i.A = u
	end
	function luaP:GETARG_B(i)
		return i.B
	end
	function luaP:SETARG_B(i, b)
		i.B = b
	end
	function luaP:GETARG_C(i)
		return i.C
	end
	function luaP:SETARG_C(i, b)
		i.C = b
	end
	function luaP:GETARG_Bx(i)
		return i.Bx
	end
	function luaP:SETARG_Bx(i, b)
		i.Bx = b
	end
	function luaP:GETARG_sBx(i)
		return i.Bx - self.MAXARG_sBx
	end
	function luaP:SETARG_sBx(i, b)
		i.Bx = b + self.MAXARG_sBx
	end
	function luaP:CREATE_ABC(o, a, b, c)
		return { OP = self.OpCode[o], A = a, B = b, C = c }
	end
	function luaP:CREATE_ABx(o, a, bc)
		return { OP = self.OpCode[o], A = a, Bx = bc }
	end
	function luaP:CREATE_Inst(c)
		local o = c % 64
		c = (c - o) / 64
		local a = c % 256
		c = (c - a) / 256
		return self:CREATE_ABx(o, a, c)
	end
	function luaP:Instruction(i)
		if i.Bx then
			i.C = i.Bx % 512
			i.B = (i.Bx - i.C) / 512
		end
		local I = i.A * 64 + i.OP
		local c0 = I % 256
		I = i.C * 64 + (I - c0) / 256
		local c1 = I % 256
		I = i.B * 128 + (I - c1) / 256
		local c2 = I % 256
		local c3 = (I - c2) / 256
		return string.char(c0, c1, c2, c3)
	end
	function luaP:DecodeInst(x)
		local byte = string.byte
		local i = {}
		local I = byte(x, 1)
		local op = I % 64
		i.OP = op
		I = byte(x, 2) * 4 + (I - op) / 64
		local a = I % 256
		i.A = a
		I = byte(x, 3) * 4 + (I - a) / 256
		local c = I % 512
		i.C = c
		i.B = byte(x, 4) * 2 + (I - c) / 512
		local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))]
		if opmode ~= "iABC" then
			i.Bx = i.B * 512 + i.C
		end
		return i
	end
	luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1)
	function luaP:ISK(x)
		return x >= self.BITRK
	end
	function luaP:INDEXK(r)
		return r - self.BITRK
	end
	luaP.MAXINDEXRK = luaP.BITRK - 1
	function luaP:RKASK(x)
		return x + self.BITRK
	end
	luaP.NO_REG = luaP.MAXARG_A
	luaP.opnames = {}
	luaP.OpCode = {}
	luaP.ROpCode = {}
	local i = 0
	for v in
		string.gmatch(
			[[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],
			"%S+"
		)
	do
		local n = "OP_" .. v
		luaP.opnames[i] = v
		luaP.OpCode[n] = i
		luaP.ROpCode[i] = n
		i = i + 1
	end
	luaP.NUM_OPCODES = i
	luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 }
	function luaP:getOpMode(m)
		return self.opmodes[self.OpCode[m]] % 4
	end
	function luaP:getBMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4
	end
	function luaP:getCMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4
	end
	function luaP:testAMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2
	end
	function luaP:testTMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 128)
	end
	luaP.LFIELDS_PER_FLUSH = 50
	local function opmode(t, a, b, c, m)
		local luaP = luaP
		return t * 128 + a * 64 + luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m]
	end
	luaP.opmodes = {
		opmode(0, 1, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgR", "OpArgK", "iABC"),
		opmode(0, 0, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 0, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgR", "iABC"),
		opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 1, "OpArgR", "OpArgU", "iABC"),
		opmode(1, 1, "OpArgR", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
		opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
		opmode(1, 0, "OpArgN", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgN", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABC"),
	}
	luaP.opmodes[0] = opmode(0, 1, "OpArgR", "OpArgN", "iABC")
	luaU.LUA_SIGNATURE = "\27Lua"
	luaU.LUA_TNUMBER = 3
	luaU.LUA_TSTRING = 4
	luaU.LUA_TNIL = 0
	luaU.LUA_TBOOLEAN = 1
	luaU.LUA_TNONE = -1
	luaU.LUAC_VERSION = 0x51
	luaU.LUAC_FORMAT = 0
	luaU.LUAC_HEADERSIZE = 12
	function luaU:make_setS()
		local buff = {}
		buff.data = ""
		local writer = function(s, buff)
			if not s then
				return 0
			end
			buff.data = buff.data .. s
			return 0
		end
		return writer, buff
	end
	function luaU:make_setF(filename)
		return nil
	end
	function luaU:ttype(o)
		local tt = type(o.value)
		if tt == "number" then
			return self.LUA_TNUMBER
		elseif tt == "string" then
			return self.LUA_TSTRING
		elseif tt == "nil" then
			return self.LUA_TNIL
		elseif tt == "boolean" then
			return self.LUA_TBOOLEAN
		else
			return self.LUA_TNONE
		end
	end
	function luaU:from_double(x)
		local function grab_byte(v)
			local c = v % 256
			return (v - c) / 256, string.char(c)
		end
		local sign = 0
		if x < 0 then
			sign = 1
			x = -x
		end
		local mantissa, exponent = math.frexp(x)
		if x == 0 then
			mantissa, exponent = 0, 0
		elseif x == 1 / 0 then
			mantissa, exponent = 0, 2047
		else
			mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
			exponent = exponent + 1022
		end
		local v, byte = "", nil
		x = math.floor(mantissa)
		for _ = 1, 6 do
			x, byte = grab_byte(x)
			v = v .. byte
		end
		x, byte = grab_byte(exponent * 16 + x)
		v = v .. byte
		x, byte = grab_byte(sign * 128 + x)
		v = v .. byte
		return v
	end
	function luaU:from_int(x)
		local v = ""
		x = math.floor(x)
		if x < 0 then
			x = 4294967296 + x
		end
		for _ = 1, 4 do
			local c = x % 256
			v = v .. string.char(c)
			x = math.floor(x / 256)
		end
		return v
	end
	function luaU:DumpBlock(b, D)
		if D.status == 0 then
			D.status = D.write(b, D.data)
		end
	end
	function luaU:DumpChar(y, D)
		self:DumpBlock(string.char(y), D)
	end
	function luaU:DumpInt(x, D)
		self:DumpBlock(self:from_int(x), D)
	end
	function luaU:DumpSizeT(x, D)
		self:DumpBlock(self:from_int(x), D)
		if size_size_t == 8 then
			self:DumpBlock(self:from_int(0), D)
		end
	end
	function luaU:DumpNumber(x, D)
		self:DumpBlock(self:from_double(x), D)
	end
	function luaU:DumpString(s, D)
		if s == nil then
			self:DumpSizeT(0, D)
		else
			s = s .. "\0"
			self:DumpSizeT(#s, D)
			self:DumpBlock(s, D)
		end
	end
	function luaU:DumpCode(f, D)
		local n = f.sizecode
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpBlock(luaP:Instruction(f.code[i]), D)
		end
	end
	function luaU:DumpConstants(f, D)
		local n = f.sizek
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			local o = f.k[i]
			local tt = self:ttype(o)
			self:DumpChar(tt, D)
			if tt == self.LUA_TNIL then
			elseif tt == self.LUA_TBOOLEAN then
				self:DumpChar(o.value and 1 or 0, D)
			elseif tt == self.LUA_TNUMBER then
				self:DumpNumber(o.value, D)
			elseif tt == self.LUA_TSTRING then
				self:DumpString(o.value, D)
			else
			end
		end
		n = f.sizep
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpFunction(f.p[i], f.source, D)
		end
	end
	function luaU:DumpDebug(f, D)
		local n
		n = D.strip and 0 or f.sizelineinfo
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpInt(f.lineinfo[i], D)
		end
		n = D.strip and 0 or f.sizelocvars
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpString(f.locvars[i].varname, D)
			self:DumpInt(f.locvars[i].startpc, D)
			self:DumpInt(f.locvars[i].endpc, D)
		end
		n = D.strip and 0 or f.sizeupvalues
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpString(f.upvalues[i], D)
		end
	end
	function luaU:DumpFunction(f, p, D)
		local source = f.source
		if source == p or D.strip then
			source = nil
		end
		self:DumpString(source, D)
		self:DumpInt(f.lineDefined, D)
		self:DumpInt(f.lastlinedefined, D)
		self:DumpChar(f.nups, D)
		self:DumpChar(f.numparams, D)
		self:DumpChar(f.is_vararg, D)
		self:DumpChar(f.maxstacksize, D)
		self:DumpCode(f, D)
		self:DumpConstants(f, D)
		self:DumpDebug(f, D)
	end
	function luaU:DumpHeader(D)
		local h = self:header()
		assert(#h == self.LUAC_HEADERSIZE)
		self:DumpBlock(h, D)
	end
	function luaU:header()
		local x = 1
		return self.LUA_SIGNATURE .. string.char(self.LUAC_VERSION, self.LUAC_FORMAT, x, 4, size_size_t, 4, 8, 0)
	end
	function luaU:dump(L, f, w, data, strip)
		local D = {}
		D.L = L
		D.write = w
		D.data = data
		D.strip = strip
		D.status = 0
		self:DumpHeader(D)
		self:DumpFunction(f, nil, D)
		D.write(nil, D.data)
		return D.status
	end
	luaK.MAXSTACK = 250
	function luaK:ttisnumber(o)
		if o then
			return type(o.value) == "number"
		else
			return false
		end
	end
	function luaK:nvalue(o)
		return o.value
	end
	function luaK:setnilvalue(o)
		o.value = nil
	end
	function luaK:setsvalue(o, x)
		o.value = x
	end
	luaK.setnvalue = luaK.setsvalue
	luaK.sethvalue = luaK.setsvalue
	luaK.setbvalue = luaK.setsvalue
	function luaK:numadd(a, b)
		return a + b
	end
	function luaK:numsub(a, b)
		return a - b
	end
	function luaK:nummul(a, b)
		return a * b
	end
	function luaK:numdiv(a, b)
		return a / b
	end
	function luaK:nummod(a, b)
		return a % b
	end
	function luaK:numpow(a, b)
		return a ^ b
	end
	function luaK:numunm(a)
		return -a
	end
	function luaK:numisnan(a)
		return a ~= a
	end
	luaK.NO_JUMP = -1
	luaK.BinOpr = {
		OPR_ADD = 0,
		OPR_SUB = 1,
		OPR_MUL = 2,
		OPR_DIV = 3,
		OPR_MOD = 4,
		OPR_POW = 5,
		OPR_CONCAT = 6,
		OPR_NE = 7,
		OPR_EQ = 8,
		OPR_LT = 9,
		OPR_LE = 10,
		OPR_GT = 11,
		OPR_GE = 12,
		OPR_AND = 13,
		OPR_OR = 14,
		OPR_NOBINOPR = 15,
	}
	luaK.UnOpr = {
		OPR_MINUS = 0,
		OPR_NOT = 1,
		OPR_LEN = 2,
		OPR_NOUNOPR = 3,
	}
	function luaK:getcode(fs, e)
		return fs.f.code[e.info]
	end
	function luaK:codeAsBx(fs, o, A, sBx)
		return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx)
	end
	function luaK:setmultret(fs, e)
		self:setreturns(fs, e, luaY.LUA_MULTRET)
	end
	function luaK:hasjumps(e)
		return e.t ~= e.f
	end
	function luaK:isnumeral(e)
		return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP
	end
	function luaK:_nil(fs, from, n)
		if fs.pc > fs.lasttarget then
			if fs.pc == 0 then
				if from >= fs.nactvar then
					return
				end
			else
				local previous = fs.f.code[fs.pc - 1]
				if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
					local pfrom = luaP:GETARG_A(previous)
					local pto = luaP:GETARG_B(previous)
					if pfrom <= from and from <= pto + 1 then
						if from + n - 1 > pto then
							luaP:SETARG_B(previous, from + n - 1)
						end
						return
					end
				end
			end
		end
		self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)
	end
	function luaK:jump(fs)
		local jpc = fs.jpc
		fs.jpc = self.NO_JUMP
		local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
		j = self:concat(fs, j, jpc)
		return j
	end
	function luaK:ret(fs, first, nret)
		self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
	end
	function luaK:condjump(fs, op, A, B, C)
		self:codeABC(fs, op, A, B, C)
		return self:jump(fs)
	end
	function luaK:fixjump(fs, pc, dest)
		local jmp = fs.f.code[pc]
		local offset = dest - (pc + 1)
		lua_assert(dest ~= self.NO_JUMP)
		if math.abs(offset) > luaP.MAXARG_sBx then
			luaX:syntaxerror(fs.ls, "control structure too long")
		end
		luaP:SETARG_sBx(jmp, offset)
	end
	function luaK:getlabel(fs)
		fs.lasttarget = fs.pc
		return fs.pc
	end
	function luaK:getjump(fs, pc)
		local offset = luaP:GETARG_sBx(fs.f.code[pc])
		if offset == self.NO_JUMP then
			return self.NO_JUMP
		else
			return (pc + 1) + offset
		end
	end
	function luaK:getjumpcontrol(fs, pc)
		local pi = fs.f.code[pc]
		local ppi = fs.f.code[pc - 1]
		if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
			return ppi
		else
			return pi
		end
	end
	function luaK:need_value(fs, list)
		while list ~= self.NO_JUMP do
			local i = self:getjumpcontrol(fs, list)
			if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
				return true
			end
			list = self:getjump(fs, list)
		end
		return false
	end
	function luaK:patchtestreg(fs, node, reg)
		local i = self:getjumpcontrol(fs, node)
		if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
			return false
		end
		if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
			luaP:SETARG_A(i, reg)
		else
			luaP:SET_OPCODE(i, "OP_TEST")
			local b = luaP:GETARG_B(i)
			luaP:SETARG_A(i, b)
			luaP:SETARG_B(i, 0)
		end
		return true
	end
	function luaK:removevalues(fs, list)
		while list ~= self.NO_JUMP do
			self:patchtestreg(fs, list, luaP.NO_REG)
			list = self:getjump(fs, list)
		end
	end
	function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
		while list ~= self.NO_JUMP do
			local _next = self:getjump(fs, list)
			if self:patchtestreg(fs, list, reg) then
				self:fixjump(fs, list, vtarget)
			else
				self:fixjump(fs, list, dtarget)
			end
			list = _next
		end
	end
	function luaK:dischargejpc(fs)
		self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
		fs.jpc = self.NO_JUMP
	end
	function luaK:patchlist(fs, list, target)
		if target == fs.pc then
			self:patchtohere(fs, list)
		else
			lua_assert(target < fs.pc)
			self:patchlistaux(fs, list, target, luaP.NO_REG, target)
		end
	end
	function luaK:patchtohere(fs, list)
		self:getlabel(fs)
		fs.jpc = self:concat(fs, fs.jpc, list)
	end
	function luaK:concat(fs, l1, l2)
		if l2 == self.NO_JUMP then
			return l1
		elseif l1 == self.NO_JUMP then
			return l2
		else
			local list = l1
			local _next = self:getjump(fs, list)
			while _next ~= self.NO_JUMP do
				list = _next
				_next = self:getjump(fs, list)
			end
			self:fixjump(fs, list, l2)
		end
		return l1
	end
	function luaK:checkstack(fs, n)
		local newstack = fs.freereg + n
		if newstack > fs.f.maxstacksize then
			if newstack >= self.MAXSTACK then
				luaX:syntaxerror(fs.ls, "function or expression too complex")
			end
			fs.f.maxstacksize = newstack
		end
	end
	function luaK:reserveregs(fs, n)
		self:checkstack(fs, n)
		fs.freereg = fs.freereg + n
	end
	function luaK:freereg(fs, reg)
		if not luaP:ISK(reg) and reg >= fs.nactvar then
			fs.freereg = fs.freereg - 1
			lua_assert(reg == fs.freereg)
		end
	end
	function luaK:freeexp(fs, e)
		if e.k == "VNONRELOC" then
			self:freereg(fs, e.info)
		end
	end
	function luaK:addk(fs, k, v)
		local L = fs.L
		local idx = fs.h[k.value]
		local f = fs.f
		if self:ttisnumber(idx) then
			return self:nvalue(idx)
		else
			idx = {}
			self:setnvalue(idx, fs.nk)
			fs.h[k.value] = idx
			luaY:growvector(L, f.k, fs.nk, f.sizek, nil, luaP.MAXARG_Bx, "constant table overflow")
			f.k[fs.nk] = v
			local nk = fs.nk
			fs.nk = fs.nk + 1
			return nk
		end
	end
	function luaK:stringK(fs, s)
		local o = {}
		self:setsvalue(o, s)
		return self:addk(fs, o, o)
	end
	function luaK:numberK(fs, r)
		local o = {}
		self:setnvalue(o, r)
		return self:addk(fs, o, o)
	end
	function luaK:boolK(fs, b)
		local o = {}
		self:setbvalue(o, b)
		return self:addk(fs, o, o)
	end
	function luaK:nilK(fs)
		local k, v = {}, {}
		self:setnilvalue(v)
		self:sethvalue(k, fs.h)
		return self:addk(fs, k, v)
	end
	function luaK:setreturns(fs, e, nresults)
		if e.k == "VCALL" then
			luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
		elseif e.k == "VVARARG" then
			luaP:SETARG_B(self:getcode(fs, e), nresults + 1)
			luaP:SETARG_A(self:getcode(fs, e), fs.freereg)
			luaK:reserveregs(fs, 1)
		end
	end
	function luaK:setoneret(fs, e)
		if e.k == "VCALL" then
			e.k = "VNONRELOC"
			e.info = luaP:GETARG_A(self:getcode(fs, e))
		elseif e.k == "VVARARG" then
			luaP:SETARG_B(self:getcode(fs, e), 2)
			e.k = "VRELOCABLE"
		end
	end
	function luaK:dischargevars(fs, e)
		local k = e.k
		if k == "VLOCAL" then
			e.k = "VNONRELOC"
		elseif k == "VUPVAL" then
			e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
			e.k = "VRELOCABLE"
		elseif k == "VGLOBAL" then
			e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
			e.k = "VRELOCABLE"
		elseif k == "VINDEXED" then
			self:freereg(fs, e.aux)
			self:freereg(fs, e.info)
			e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
			e.k = "VRELOCABLE"
		elseif k == "VVARARG" or k == "VCALL" then
			self:setoneret(fs, e)
		else
		end
	end
	function luaK:code_label(fs, A, b, jump)
		self:getlabel(fs)
		return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
	end
	function luaK:discharge2reg(fs, e, reg)
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" then
			self:_nil(fs, reg, 1)
		elseif k == "VFALSE" or k == "VTRUE" then
			self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
		elseif k == "VK" then
			self:codeABx(fs, "OP_LOADK", reg, e.info)
		elseif k == "VKNUM" then
			self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
		elseif k == "VRELOCABLE" then
			local pc = self:getcode(fs, e)
			luaP:SETARG_A(pc, reg)
		elseif k == "VNONRELOC" then
			if reg ~= e.info then
				self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
			end
		else
			lua_assert(e.k == "VVOID" or e.k == "VJMP")
			return
		end
		e.info = reg
		e.k = "VNONRELOC"
	end
	function luaK:discharge2anyreg(fs, e)
		if e.k ~= "VNONRELOC" then
			self:reserveregs(fs, 1)
			self:discharge2reg(fs, e, fs.freereg - 1)
		end
	end
	function luaK:exp2reg(fs, e, reg)
		self:discharge2reg(fs, e, reg)
		if e.k == "VJMP" then
			e.t = self:concat(fs, e.t, e.info)
		end
		if self:hasjumps(e) then
			local final
			local p_f = self.NO_JUMP
			local p_t = self.NO_JUMP
			if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
				local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
				p_f = self:code_label(fs, reg, 0, 1)
				p_t = self:code_label(fs, reg, 1, 0)
				self:patchtohere(fs, fj)
			end
			final = self:getlabel(fs)
			self:patchlistaux(fs, e.f, final, reg, p_f)
			self:patchlistaux(fs, e.t, final, reg, p_t)
		end
		e.f, e.t = self.NO_JUMP, self.NO_JUMP
		e.info = reg
		e.k = "VNONRELOC"
	end
	function luaK:exp2nextreg(fs, e)
		self:dischargevars(fs, e)
		self:freeexp(fs, e)
		self:reserveregs(fs, 1)
		self:exp2reg(fs, e, fs.freereg - 1)
	end
	function luaK:exp2anyreg(fs, e)
		self:dischargevars(fs, e)
		if e.k == "VNONRELOC" then
			if not self:hasjumps(e) then
				return e.info
			end
			if e.info >= fs.nactvar then
				self:exp2reg(fs, e, e.info)
				return e.info
			end
		end
		self:exp2nextreg(fs, e)
		return e.info
	end
	function luaK:exp2val(fs, e)
		if self:hasjumps(e) then
			self:exp2anyreg(fs, e)
		else
			self:dischargevars(fs, e)
		end
	end
	function luaK:exp2RK(fs, e)
		self:exp2val(fs, e)
		local k = e.k
		if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
			if fs.nk <= luaP.MAXINDEXRK then
				if e.k == "VNIL" then
					e.info = self:nilK(fs)
				else
					e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval) or self:boolK(fs, e.k == "VTRUE")
				end
				e.k = "VK"
				return luaP:RKASK(e.info)
			end
		elseif k == "VK" then
			if e.info <= luaP.MAXINDEXRK then
				return luaP:RKASK(e.info)
			end
		else
		end
		return self:exp2anyreg(fs, e)
	end
	function luaK:storevar(fs, var, ex)
		local k = var.k
		if k == "VLOCAL" then
			self:freeexp(fs, ex)
			self:exp2reg(fs, ex, var.info)
			return
		elseif k == "VUPVAL" then
			local e = self:exp2anyreg(fs, ex)
			self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
		elseif k == "VGLOBAL" then
			local e = self:exp2anyreg(fs, ex)
			self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
		elseif k == "VINDEXED" then
			local e = self:exp2RK(fs, ex)
			self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
		else
			lua_assert(0)
		end
		self:freeexp(fs, ex)
	end
	function luaK:_self(fs, e, key)
		self:exp2anyreg(fs, e)
		self:freeexp(fs, e)
		local func = fs.freereg
		self:reserveregs(fs, 2)
		self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
		self:freeexp(fs, key)
		e.info = func
		e.k = "VNONRELOC"
	end
	function luaK:invertjump(fs, e)
		local pc = self:getjumpcontrol(fs, e.info)
		lua_assert(
			luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0
				and luaP:GET_OPCODE(pc) ~= "OP_TESTSET"
				and luaP:GET_OPCODE(pc) ~= "OP_TEST"
		)
		luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
	end
	function luaK:jumponcond(fs, e, cond)
		if e.k == "VRELOCABLE" then
			local ie = self:getcode(fs, e)
			if luaP:GET_OPCODE(ie) == "OP_NOT" then
				fs.pc = fs.pc - 1
				return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
			end
		end
		self:discharge2anyreg(fs, e)
		self:freeexp(fs, e)
		return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
	end
	function luaK:goiftrue(fs, e)
		local pc
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VK" or k == "VKNUM" or k == "VTRUE" then
			pc = self.NO_JUMP
		elseif k == "VFALSE" then
			pc = self:jump(fs)
		elseif k == "VJMP" then
			self:invertjump(fs, e)
			pc = e.info
		else
			pc = self:jumponcond(fs, e, false)
		end
		e.f = self:concat(fs, e.f, pc)
		self:patchtohere(fs, e.t)
		e.t = self.NO_JUMP
	end
	function luaK:goiffalse(fs, e)
		local pc
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" or k == "VFALSE" then
			pc = self.NO_JUMP
		elseif k == "VTRUE" then
			pc = self:jump(fs)
		elseif k == "VJMP" then
			pc = e.info
		else
			pc = self:jumponcond(fs, e, true)
		end
		e.t = self:concat(fs, e.t, pc)
		self:patchtohere(fs, e.f)
		e.f = self.NO_JUMP
	end
	function luaK:codenot(fs, e)
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" or k == "VFALSE" then
			e.k = "VTRUE"
		elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
			e.k = "VFALSE"
		elseif k == "VJMP" then
			self:invertjump(fs, e)
		elseif k == "VRELOCABLE" or k == "VNONRELOC" then
			self:discharge2anyreg(fs, e)
			self:freeexp(fs, e)
			e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
			e.k = "VRELOCABLE"
		else
			lua_assert(0)
		end
		e.f, e.t = e.t, e.f
		self:removevalues(fs, e.f)
		self:removevalues(fs, e.t)
	end
	function luaK:indexed(fs, t, k)
		t.aux = self:exp2RK(fs, k)
		t.k = "VINDEXED"
	end
	function luaK:constfolding(op, e1, e2)
		local r
		if not self:isnumeral(e1) or not self:isnumeral(e2) then
			return false
		end
		local v1 = e1.nval
		local v2 = e2.nval
		if op == "OP_ADD" then
			r = self:numadd(v1, v2)
		elseif op == "OP_SUB" then
			r = self:numsub(v1, v2)
		elseif op == "OP_MUL" then
			r = self:nummul(v1, v2)
		elseif op == "OP_DIV" then
			if v2 == 0 then
				return false
			end
			r = self:numdiv(v1, v2)
		elseif op == "OP_MOD" then
			if v2 == 0 then
				return false
			end
			r = self:nummod(v1, v2)
		elseif op == "OP_POW" then
			r = self:numpow(v1, v2)
		elseif op == "OP_UNM" then
			r = self:numunm(v1)
		elseif op == "OP_LEN" then
			return false
		else
			lua_assert(0)
			r = 0
		end
		if self:numisnan(r) then
			return false
		end
		e1.nval = r
		return true
	end
	function luaK:codearith(fs, op, e1, e2)
		if self:constfolding(op, e1, e2) then
			return
		else
			local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
			local o1 = self:exp2RK(fs, e1)
			if o1 > o2 then
				self:freeexp(fs, e1)
				self:freeexp(fs, e2)
			else
				self:freeexp(fs, e2)
				self:freeexp(fs, e1)
			end
			e1.info = self:codeABC(fs, op, 0, o1, o2)
			e1.k = "VRELOCABLE"
		end
	end
	function luaK:codecomp(fs, op, cond, e1, e2)
		local o1 = self:exp2RK(fs, e1)
		local o2 = self:exp2RK(fs, e2)
		self:freeexp(fs, e2)
		self:freeexp(fs, e1)
		if cond == 0 and op ~= "OP_EQ" then
			o1, o2 = o2, o1
			cond = 1
		end
		e1.info = self:condjump(fs, op, cond, o1, o2)
		e1.k = "VJMP"
	end
	function luaK:prefix(fs, op, e)
		local e2 = {}
		e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
		e2.k = "VKNUM"
		e2.nval = 0
		if op == "OPR_MINUS" then
			if not self:isnumeral(e) then
				self:exp2anyreg(fs, e)
			end
			self:codearith(fs, "OP_UNM", e, e2)
		elseif op == "OPR_NOT" then
			self:codenot(fs, e)
		elseif op == "OPR_LEN" then
			self:exp2anyreg(fs, e)
			self:codearith(fs, "OP_LEN", e, e2)
		else
			lua_assert(0)
		end
	end
	function luaK:infix(fs, op, v)
		if op == "OPR_AND" then
			self:goiftrue(fs, v)
		elseif op == "OPR_OR" then
			self:goiffalse(fs, v)
		elseif op == "OPR_CONCAT" then
			self:exp2nextreg(fs, v)
		elseif
			op == "OPR_ADD"
			or op == "OPR_SUB"
			or op == "OPR_MUL"
			or op == "OPR_DIV"
			or op == "OPR_MOD"
			or op == "OPR_POW"
		then
			if not self:isnumeral(v) then
				self:exp2RK(fs, v)
			end
		else
			self:exp2RK(fs, v)
		end
	end
	luaK.arith_op = {
		OPR_ADD = "OP_ADD",
		OPR_SUB = "OP_SUB",
		OPR_MUL = "OP_MUL",
		OPR_DIV = "OP_DIV",
		OPR_MOD = "OP_MOD",
		OPR_POW = "OP_POW",
	}
	luaK.comp_op = {
		OPR_EQ = "OP_EQ",
		OPR_NE = "OP_EQ",
		OPR_LT = "OP_LT",
		OPR_LE = "OP_LE",
		OPR_GT = "OP_LT",
		OPR_GE = "OP_LE",
	}
	luaK.comp_cond = {
		OPR_EQ = 1,
		OPR_NE = 0,
		OPR_LT = 1,
		OPR_LE = 1,
		OPR_GT = 0,
		OPR_GE = 0,
	}
	function luaK:posfix(fs, op, e1, e2)
		local function copyexp(e1, e2)
			e1.k = e2.k
			e1.info = e2.info
			e1.aux = e2.aux
			e1.nval = e2.nval
			e1.t = e2.t
			e1.f = e2.f
		end
		if op == "OPR_AND" then
			lua_assert(e1.t == self.NO_JUMP)
			self:dischargevars(fs, e2)
			e2.f = self:concat(fs, e2.f, e1.f)
			copyexp(e1, e2)
		elseif op == "OPR_OR" then
			lua_assert(e1.f == self.NO_JUMP)
			self:dischargevars(fs, e2)
			e2.t = self:concat(fs, e2.t, e1.t)
			copyexp(e1, e2)
		elseif op == "OPR_CONCAT" then
			self:exp2val(fs, e2)
			if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
				lua_assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
				self:freeexp(fs, e1)
				luaP:SETARG_B(self:getcode(fs, e2), e1.info)
				e1.k = "VRELOCABLE"
				e1.info = e2.info
			else
				self:exp2nextreg(fs, e2)
				self:codearith(fs, "OP_CONCAT", e1, e2)
			end
		else
			local arith = self.arith_op[op]
			if arith then
				self:codearith(fs, arith, e1, e2)
			else
				local comp = self.comp_op[op]
				if comp then
					self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
				else
					lua_assert(0)
				end
			end
		end
	end
	function luaK:fixline(fs, line)
		fs.f.lineinfo[fs.pc - 1] = line
	end
	function luaK:code(fs, i, line)
		local f = fs.f
		self:dischargejpc(fs)
		luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil, luaY.MAX_INT, "code size overflow")
		f.code[fs.pc] = i
		luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil, luaY.MAX_INT, "code size overflow")
		f.lineinfo[fs.pc] = line
		local pc = fs.pc
		fs.pc = fs.pc + 1
		return pc
	end
	function luaK:codeABC(fs, o, a, b, c)
		lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
		lua_assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
		lua_assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
		return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
	end
	function luaK:codeABx(fs, o, a, bc)
		lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABx or luaP:getOpMode(o) == luaP.OpMode.iAsBx)
		lua_assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
		return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
	end
	function luaK:setlist(fs, base, nelems, tostore)
		local c = math.floor((nelems - 1) / luaP.LFIELDS_PER_FLUSH) + 1
		local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
		lua_assert(tostore ~= 0)
		if c <= luaP.MAXARG_C then
			self:codeABC(fs, "OP_SETLIST", base, b, c)
		else
			self:codeABC(fs, "OP_SETLIST", base, b, 0)
			self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
		end
		fs.freereg = base + 1
	end
	luaY.LUA_QS = luaX.LUA_QS or "'%s'"
	luaY.SHRT_MAX = 32767
	luaY.LUAI_MAXVARS = 200
	luaY.LUAI_MAXUPVALUES = 60
	luaY.MAX_INT = luaX.MAX_INT or 2147483645
	luaY.LUAI_MAXCCALLS = 200
	luaY.VARARG_HASARG = 1
	luaY.HASARG_MASK = 2
	luaY.VARARG_ISVARARG = 2
	luaY.VARARG_NEEDSARG = 4
	luaY.LUA_MULTRET = -1
	function luaY:LUA_QL(x)
		return "'" .. x .. "'"
	end
	function luaY:growvector(_, _, nelems, _, _, limit, e)
		if nelems >= limit then
			error(e)
		end
	end
	function luaY:newproto()
		local f = {}
		f.k = {}
		f.sizek = 0
		f.p = {}
		f.sizep = 0
		f.code = {}
		f.sizecode = 0
		f.sizelineinfo = 0
		f.sizeupvalues = 0
		f.nups = 0
		f.upvalues = {}
		f.numparams = 0
		f.is_vararg = 0
		f.maxstacksize = 0
		f.lineinfo = {}
		f.sizelocvars = 0
		f.locvars = {}
		f.lineDefined = 0
		f.lastlinedefined = 0
		f.source = nil
		return f
	end
	function luaY:int2fb(x)
		local e = 0
		while x >= 16 do
			x = math.floor((x + 1) / 2)
			e = e + 1
		end
		if x < 8 then
			return x
		else
			return ((e + 1) * 8) + (x - 8)
		end
	end
	function luaY:hasmultret(k)
		return k == "VCALL" or k == "VVARARG"
	end
	function luaY:getlocvar(fs, i)
		return fs.f.locvars[fs.actvar[i]]
	end
	function luaY:checklimit(fs, v, l, m)
		if v > l then
			self:errorlimit(fs, l, m)
		end
	end
	function luaY:error_expected(ls, token)
		luaX:syntaxerror(ls, string.format(self.LUA_QS .. " expected", luaX:token2str(ls, token)))
	end
	function luaY:errorlimit(fs, limit, what)
		local msg = (fs.f.linedefined == 0) and string.format("main function has more than %d %s", limit, what)
			or string.format("function at line %d has more than %d %s", fs.f.linedefined, limit, what)
		luaX:lexerror(fs.ls, msg, 0)
	end
	function luaY:testnext(ls, c)
		if ls.t.token == c then
			luaX:next(ls)
			return true
		else
			return false
		end
	end
	function luaY:check(ls, c)
		if ls.t.token ~= c then
			self:error_expected(ls, c)
		end
	end
	function luaY:checknext(ls, c)
		self:check(ls, c)
		luaX:next(ls)
	end
	function luaY:check_condition(ls, c, msg)
		if not c then
			luaX:syntaxerror(ls, msg)
		end
	end
	function luaY:check_match(ls, what, who, where)
		if not self:testnext(ls, what) then
			if where == ls.linenumber then
				self:error_expected(ls, what)
			else
				luaX:syntaxerror(
					ls,
					string.format(
						self.LUA_QS .. " expected (to close " .. self.LUA_QS .. " at line %d)",
						luaX:token2str(ls, what),
						luaX:token2str(ls, who),
						where
					)
				)
			end
		end
	end
	function luaY:str_checkname(ls)
		self:check(ls, "TK_NAME")
		local ts = ls.t.seminfo
		luaX:next(ls)
		return ts
	end
	function luaY:init_exp(e, k, i)
		e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
		e.k = k
		e.info = i
	end
	function luaY:codestring(ls, e, s)
		self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
	end
	function luaY:checkname(ls, e)
		self:codestring(ls, e, self:str_checkname(ls))
	end
	function luaY:registerlocalvar(ls, varname)
		local fs = ls.fs
		local f = fs.f
		self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars, nil, self.SHRT_MAX, "too many local variables")
		f.locvars[fs.nlocvars] = {}
		f.locvars[fs.nlocvars].varname = varname
		local nlocvars = fs.nlocvars
		fs.nlocvars = fs.nlocvars + 1
		return nlocvars
	end
	function luaY:new_localvarliteral(ls, v, n)
		self:new_localvar(ls, v, n)
	end
	function luaY:new_localvar(ls, name, n)
		local fs = ls.fs
		self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
		fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
	end
	function luaY:adjustlocalvars(ls, nvars)
		local fs = ls.fs
		fs.nactvar = fs.nactvar + nvars
		for i = nvars, 1, -1 do
			self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
		end
	end
	function luaY:removevars(ls, tolevel)
		local fs = ls.fs
		while fs.nactvar > tolevel do
			fs.nactvar = fs.nactvar - 1
			self:getlocvar(fs, fs.nactvar).endpc = fs.pc
		end
	end
	function luaY:indexupvalue(fs, name, v)
		local f = fs.f
		for i = 0, f.nups - 1 do
			if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
				lua_assert(f.upvalues[i] == name)
				return i
			end
		end
		self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
		self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues, nil, self.MAX_INT, "")
		f.upvalues[f.nups] = name
		lua_assert(v.k == "VLOCAL" or v.k == "VUPVAL")
		fs.upvalues[f.nups] = { k = v.k, info = v.info }
		local nups = f.nups
		f.nups = f.nups + 1
		return nups
	end
	function luaY:searchvar(fs, n)
		for i = fs.nactvar - 1, 0, -1 do
			if n == self:getlocvar(fs, i).varname then
				return i
			end
		end
		return -1
	end
	function luaY:markupval(fs, level)
		local bl = fs.bl
		while bl and bl.nactvar > level do
			bl = bl.previous
		end
		if bl then
			bl.upval = true
		end
	end
	function luaY:singlevaraux(fs, n, var, base)
		if fs == nil then
			self:init_exp(var, "VGLOBAL", luaP.NO_REG)
			return "VGLOBAL"
		else
			local v = self:searchvar(fs, n)
			if v >= 0 then
				self:init_exp(var, "VLOCAL", v)
				if base == 0 then
					self:markupval(fs, v)
				end
				return "VLOCAL"
			else
				if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
					return "VGLOBAL"
				end
				var.info = self:indexupvalue(fs, n, var)
				var.k = "VUPVAL"
				return "VUPVAL"
			end
		end
	end
	function luaY:singlevar(ls, var)
		local varname = self:str_checkname(ls)
		local fs = ls.fs
		if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
			var.info = luaK:stringK(fs, varname)
		end
	end
	function luaY:adjust_assign(ls, nvars, nexps, e)
		local fs = ls.fs
		local extra = nvars - nexps
		if self:hasmultret(e.k) then
			extra = extra + 1
			if extra <= 0 then
				extra = 0
			end
			luaK:setreturns(fs, e, extra)
			if extra > 1 then
				luaK:reserveregs(fs, extra - 1)
			end
		else
			if e.k ~= "VVOID" then
				luaK:exp2nextreg(fs, e)
			end
			if extra > 0 then
				local reg = fs.freereg
				luaK:reserveregs(fs, extra)
				luaK:_nil(fs, reg, extra)
			end
		end
	end
	function luaY:enterlevel(ls)
		ls.L.nCcalls = ls.L.nCcalls + 1
		if ls.L.nCcalls > self.LUAI_MAXCCALLS then
			luaX:lexerror(ls, "chunk has too many syntax levels", 0)
		end
	end
	function luaY:leavelevel(ls)
		ls.L.nCcalls = ls.L.nCcalls - 1
	end
	function luaY:enterblock(fs, bl, isbreakable)
		bl.breaklist = luaK.NO_JUMP
		bl.isbreakable = isbreakable
		bl.nactvar = fs.nactvar
		bl.upval = false
		bl.previous = fs.bl
		fs.bl = bl
		lua_assert(fs.freereg == fs.nactvar)
	end
	function luaY:leaveblock(fs)
		local bl = fs.bl
		fs.bl = bl.previous
		self:removevars(fs.ls, bl.nactvar)
		if bl.upval then
			luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
		end
		lua_assert(not bl.isbreakable or not bl.upval)
		lua_assert(bl.nactvar == fs.nactvar)
		fs.freereg = fs.nactvar
		luaK:patchtohere(fs, bl.breaklist)
	end
	function luaY:pushclosure(ls, func, v)
		local fs = ls.fs
		local f = fs.f
		self:growvector(ls.L, f.p, fs.np, f.sizep, nil, luaP.MAXARG_Bx, "constant table overflow")
		f.p[fs.np] = func.f
		fs.np = fs.np + 1
		self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
		for i = 0, func.f.nups - 1 do
			local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
			luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
		end
	end
	function luaY:open_func(ls, fs)
		local L = ls.L
		local f = self:newproto()
		fs.f = f
		fs.prev = ls.fs
		fs.ls = ls
		fs.L = L
		ls.fs = fs
		fs.pc = 0
		fs.lasttarget = -1
		fs.jpc = luaK.NO_JUMP
		fs.freereg = 0
		fs.nk = 0
		fs.np = 0
		fs.nlocvars = 0
		fs.nactvar = 0
		fs.bl = nil
		f.source = ls.source
		f.maxstacksize = 2
		fs.h = {}
	end
	function luaY:close_func(ls)
		local fs = ls.fs
		local f = fs.f
		self:removevars(ls, 0)
		luaK:ret(fs, 0, 0)
		f.sizecode = fs.pc
		f.sizelineinfo = fs.pc
		f.sizek = fs.nk
		f.sizep = fs.np
		f.sizelocvars = fs.nlocvars
		f.sizeupvalues = f.nups
		lua_assert(fs.bl == nil)
		ls.fs = fs.prev
	end
	function luaY:parser(L, z, buff, name)
		local lexstate = {}
		lexstate.t = {}
		lexstate.lookahead = {}
		local funcstate = {}
		funcstate.upvalues = {}
		funcstate.actvar = {}
		L.nCcalls = 0
		lexstate.buff = buff
		luaX:setinput(L, lexstate, z, name)
		self:open_func(lexstate, funcstate)
		funcstate.f.is_vararg = self.VARARG_ISVARARG
		luaX:next(lexstate)
		self:chunk(lexstate)
		self:check(lexstate, "TK_EOS")
		self:close_func(lexstate)
		lua_assert(funcstate.prev == nil)
		lua_assert(funcstate.f.nups == 0)
		lua_assert(lexstate.fs == nil)
		return funcstate.f
	end
	function luaY:field(ls, v)
		local fs = ls.fs
		local key = {}
		luaK:exp2anyreg(fs, v)
		luaX:next(ls)
		self:checkname(ls, key)
		luaK:indexed(fs, v, key)
	end
	function luaY:yindex(ls, v)
		luaX:next(ls)
		self:expr(ls, v)
		luaK:exp2val(ls.fs, v)
		self:checknext(ls, "]")
	end
	function luaY:recfield(ls, cc)
		local fs = ls.fs
		local reg = ls.fs.freereg
		local key, val = {}, {}
		if ls.t.token == "TK_NAME" then
			self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
			self:checkname(ls, key)
		else
			self:yindex(ls, key)
		end
		cc.nh = cc.nh + 1
		self:checknext(ls, "=")
		local rkkey = luaK:exp2RK(fs, key)
		self:expr(ls, val)
		luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
		fs.freereg = reg
	end
	function luaY:closelistfield(fs, cc)
		if cc.v.k == "VVOID" then
			return
		end
		luaK:exp2nextreg(fs, cc.v)
		cc.v.k = "VVOID"
		if cc.tostore == luaP.LFIELDS_PER_FLUSH then
			luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
			cc.tostore = 0
		end
	end
	function luaY:lastlistfield(fs, cc)
		if cc.tostore == 0 then
			return
		end
		if self:hasmultret(cc.v.k) then
			luaK:setmultret(fs, cc.v)
			luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
			cc.na = cc.na - 1
		else
			if cc.v.k ~= "VVOID" then
				luaK:exp2nextreg(fs, cc.v)
			end
			luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
		end
	end
	function luaY:listfield(ls, cc)
		self:expr(ls, cc.v)
		self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
		cc.na = cc.na + 1
		cc.tostore = cc.tostore + 1
	end
	function luaY:constructor(ls, t)
		local fs = ls.fs
		local line = ls.linenumber
		local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
		local cc = {}
		cc.v = {}
		cc.na, cc.nh, cc.tostore = 0, 0, 0
		cc.t = t
		self:init_exp(t, "VRELOCABLE", pc)
		self:init_exp(cc.v, "VVOID", 0)
		luaK:exp2nextreg(ls.fs, t)
		self:checknext(ls, "{")
		repeat
			lua_assert(cc.v.k == "VVOID" or cc.tostore > 0)
			if ls.t.token == "}" then
				break
			end
			self:closelistfield(fs, cc)
			local c = ls.t.token
			if c == "TK_NAME" then
				luaX:lookahead(ls)
				if ls.lookahead.token ~= "=" then
					self:listfield(ls, cc)
				else
					self:recfield(ls, cc)
				end
			elseif c == "[" then
				self:recfield(ls, cc)
			else
				self:listfield(ls, cc)
			end
		until not self:testnext(ls, ",") and not self:testnext(ls, ";")
		self:check_match(ls, "}", "{", line)
		self:lastlistfield(fs, cc)
		luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na))
		luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh))
	end
	function luaY:parlist(ls)
		local fs = ls.fs
		local f = fs.f
		local nparams = 0
		f.is_vararg = 0
		if ls.t.token ~= ")" then
			repeat
				local c = ls.t.token
				if c == "TK_NAME" then
					self:new_localvar(ls, self:str_checkname(ls), nparams)
					nparams = nparams + 1
				elseif c == "TK_DOTS" then
					luaX:next(ls)
					self:new_localvarliteral(ls, "arg", nparams)
					nparams = nparams + 1
					f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG
					f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
				else
					luaX:syntaxerror(ls, "<name> or " .. self:LUA_QL("...") .. " expected")
				end
			until f.is_vararg ~= 0 or not self:testnext(ls, ",")
		end
		self:adjustlocalvars(ls, nparams)
		f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
		luaK:reserveregs(fs, fs.nactvar)
	end
	function luaY:body(ls, e, needself, line)
		local new_fs = {}
		new_fs.upvalues = {}
		new_fs.actvar = {}
		self:open_func(ls, new_fs)
		new_fs.f.lineDefined = line
		self:checknext(ls, "(")
		if needself then
			self:new_localvarliteral(ls, "self", 0)
			self:adjustlocalvars(ls, 1)
		end
		self:parlist(ls)
		self:checknext(ls, ")")
		self:chunk(ls)
		new_fs.f.lastlinedefined = ls.linenumber
		self:check_match(ls, "TK_END", "TK_FUNCTION", line)
		self:close_func(ls)
		self:pushclosure(ls, new_fs, e)
	end
	function luaY:explist1(ls, v)
		local n = 1
		self:expr(ls, v)
		while self:testnext(ls, ",") do
			luaK:exp2nextreg(ls.fs, v)
			self:expr(ls, v)
			n = n + 1
		end
		return n
	end
	function luaY:funcargs(ls, f)
		local fs = ls.fs
		local args = {}
		local nparams
		local line = ls.linenumber
		local c = ls.t.token
		if c == "(" then
			if line ~= ls.lastline then
				luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
			end
			luaX:next(ls)
			if ls.t.token == ")" then
				args.k = "VVOID"
			else
				self:explist1(ls, args)
				luaK:setmultret(fs, args)
			end
			self:check_match(ls, ")", "(", line)
		elseif c == "{" then
			self:constructor(ls, args)
		elseif c == "TK_STRING" then
			self:codestring(ls, args, ls.t.seminfo)
			luaX:next(ls)
		else
			luaX:syntaxerror(ls, "function arguments expected")
			return
		end
		lua_assert(f.k == "VNONRELOC")
		local base = f.info
		if self:hasmultret(args.k) then
			nparams = self.LUA_MULTRET
		else
			if args.k ~= "VVOID" then
				luaK:exp2nextreg(fs, args)
			end
			nparams = fs.freereg - (base + 1)
		end
		self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
		luaK:fixline(fs, line)
		fs.freereg = base + 1
	end
	function luaY:prefixexp(ls, v)
		local c = ls.t.token
		if c == "(" then
			local line = ls.linenumber
			luaX:next(ls)
			self:expr(ls, v)
			self:check_match(ls, ")", "(", line)
			luaK:dischargevars(ls.fs, v)
		elseif c == "TK_NAME" then
			self:singlevar(ls, v)
		else
			luaX:syntaxerror(ls, "unexpected symbol")
		end
		return
	end
	function luaY:primaryexp(ls, v)
		local fs = ls.fs
		self:prefixexp(ls, v)
		while true do
			local c = ls.t.token
			if c == "." then
				self:field(ls, v)
			elseif c == "[" then
				local key = {}
				luaK:exp2anyreg(fs, v)
				self:yindex(ls, key)
				luaK:indexed(fs, v, key)
			elseif c == ":" then
				local key = {}
				luaX:next(ls)
				self:checkname(ls, key)
				luaK:_self(fs, v, key)
				self:funcargs(ls, v)
			elseif c == "(" or c == "TK_STRING" or c == "{" then
				luaK:exp2nextreg(fs, v)
				self:funcargs(ls, v)
			else
				return
			end
		end
	end
	function luaY:simpleexp(ls, v)
		local c = ls.t.token
		if c == "TK_NUMBER" then
			self:init_exp(v, "VKNUM", 0)
			v.nval = ls.t.seminfo
		elseif c == "TK_STRING" then
			self:codestring(ls, v, ls.t.seminfo)
		elseif c == "TK_NIL" then
			self:init_exp(v, "VNIL", 0)
		elseif c == "TK_TRUE" then
			self:init_exp(v, "VTRUE", 0)
		elseif c == "TK_FALSE" then
			self:init_exp(v, "VFALSE", 0)
		elseif c == "TK_DOTS" then
			local fs = ls.fs
			self:check_condition(
				ls,
				fs.f.is_vararg ~= 0,
				"cannot use " .. self:LUA_QL("...") .. " outside a vararg function"
			)
			local is_vararg = fs.f.is_vararg
			if is_vararg >= self.VARARG_NEEDSARG then
				fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG
			end
			self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
		elseif c == "{" then
			self:constructor(ls, v)
			return
		elseif c == "TK_FUNCTION" then
			luaX:next(ls)
			self:body(ls, v, false, ls.linenumber)
			return
		else
			self:primaryexp(ls, v)
			return
		end
		luaX:next(ls)
	end
	function luaY:getunopr(op)
		if op == "TK_NOT" then
			return "OPR_NOT"
		elseif op == "-" then
			return "OPR_MINUS"
		elseif op == "#" then
			return "OPR_LEN"
		else
			return "OPR_NOUNOPR"
		end
	end
	luaY.getbinopr_table = {
		["+"] = "OPR_ADD",
		["-"] = "OPR_SUB",
		["*"] = "OPR_MUL",
		["/"] = "OPR_DIV",
		["%"] = "OPR_MOD",
		["^"] = "OPR_POW",
		["TK_CONCAT"] = "OPR_CONCAT",
		["TK_NE"] = "OPR_NE",
		["TK_EQ"] = "OPR_EQ",
		["<"] = "OPR_LT",
		["TK_LE"] = "OPR_LE",
		[">"] = "OPR_GT",
		["TK_GE"] = "OPR_GE",
		["TK_AND"] = "OPR_AND",
		["TK_OR"] = "OPR_OR",
	}
	function luaY:getbinopr(op)
		local opr = self.getbinopr_table[op]
		if opr then
			return opr
		else
			return "OPR_NOBINOPR"
		end
	end
	luaY.priority = {
		{ 6, 6 },
		{ 6, 6 },
		{ 7, 7 },
		{ 7, 7 },
		{ 7, 7 },
		{ 10, 9 },
		{ 5, 4 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 2, 2 },
		{ 1, 1 },
	}
	luaY.UNARY_PRIORITY = 8
	function luaY:subexpr(ls, v, limit)
		self:enterlevel(ls)
		local uop = self:getunopr(ls.t.token)
		if uop ~= "OPR_NOUNOPR" then
			luaX:next(ls)
			self:subexpr(ls, v, self.UNARY_PRIORITY)
			luaK:prefix(ls.fs, uop, v)
		else
			self:simpleexp(ls, v)
		end
		local op = self:getbinopr(ls.t.token)
		while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
			local v2 = {}
			luaX:next(ls)
			luaK:infix(ls.fs, op, v)
			local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
			luaK:posfix(ls.fs, op, v, v2)
			op = nextop
		end
		self:leavelevel(ls)
		return op
	end
	function luaY:expr(ls, v)
		self:subexpr(ls, v, 0)
	end
	function luaY:block_follow(token)
		if
			token == "TK_ELSE"
			or token == "TK_ELSEIF"
			or token == "TK_END"
			or token == "TK_UNTIL"
			or token == "TK_EOS"
		then
			return true
		else
			return false
		end
	end
	function luaY:block(ls)
		local fs = ls.fs
		local bl = {}
		self:enterblock(fs, bl, false)
		self:chunk(ls)
		lua_assert(bl.breaklist == luaK.NO_JUMP)
		self:leaveblock(fs)
	end
	function luaY:check_conflict(ls, lh, v)
		local fs = ls.fs
		local extra = fs.freereg
		local conflict = false
		while lh do
			if lh.v.k == "VINDEXED" then
				if lh.v.info == v.info then
					conflict = true
					lh.v.info = extra
				end
				if lh.v.aux == v.info then
					conflict = true
					lh.v.aux = extra
				end
			end
			lh = lh.prev
		end
		if conflict then
			luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)
			luaK:reserveregs(fs, 1)
		end
	end
	function luaY:assignment(ls, lh, nvars)
		local e = {}
		local c = lh.v.k
		self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL" or c == "VINDEXED", "syntax error")
		if self:testnext(ls, ",") then
			local nv = {}
			nv.v = {}
			nv.prev = lh
			self:primaryexp(ls, nv.v)
			if nv.v.k == "VLOCAL" then
				self:check_conflict(ls, lh, nv.v)
			end
			self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls, "variables in assignment")
			self:assignment(ls, nv, nvars + 1)
		else
			self:checknext(ls, "=")
			local nexps = self:explist1(ls, e)
			if nexps ~= nvars then
				self:adjust_assign(ls, nvars, nexps, e)
				if nexps > nvars then
					ls.fs.freereg = ls.fs.freereg - (nexps - nvars)
				end
			else
				luaK:setoneret(ls.fs, e)
				luaK:storevar(ls.fs, lh.v, e)
				return
			end
		end
		self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)
		luaK:storevar(ls.fs, lh.v, e)
	end
	function luaY:cond(ls)
		local v = {}
		self:expr(ls, v)
		if v.k == "VNIL" then
			v.k = "VFALSE"
		end
		luaK:goiftrue(ls.fs, v)
		return v.f
	end
	function luaY:breakstat(ls)
		local fs = ls.fs
		local bl = fs.bl
		local upval = false
		while bl and not bl.isbreakable do
			if bl.upval then
				upval = true
			end
			bl = bl.previous
		end
		if not bl then
			luaX:syntaxerror(ls, "no loop to break")
		end
		if upval then
			luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
		end
		bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
	end
	function luaY:whilestat(ls, line)
		local fs = ls.fs
		local bl = {}
		luaX:next(ls)
		local whileinit = luaK:getlabel(fs)
		local condexit = self:cond(ls)
		self:enterblock(fs, bl, true)
		self:checknext(ls, "TK_DO")
		self:block(ls)
		luaK:patchlist(fs, luaK:jump(fs), whileinit)
		self:check_match(ls, "TK_END", "TK_WHILE", line)
		self:leaveblock(fs)
		luaK:patchtohere(fs, condexit)
	end
	function luaY:repeatstat(ls, line)
		local fs = ls.fs
		local repeat_init = luaK:getlabel(fs)
		local bl1, bl2 = {}, {}
		self:enterblock(fs, bl1, true)
		self:enterblock(fs, bl2, false)
		luaX:next(ls)
		self:chunk(ls)
		self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
		local condexit = self:cond(ls)
		if not bl2.upval then
			self:leaveblock(fs)
			luaK:patchlist(ls.fs, condexit, repeat_init)
		else
			self:breakstat(ls)
			luaK:patchtohere(ls.fs, condexit)
			self:leaveblock(fs)
			luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)
		end
		self:leaveblock(fs)
	end
	function luaY:exp1(ls)
		local e = {}
		self:expr(ls, e)
		local k = e.k
		luaK:exp2nextreg(ls.fs, e)
		return k
	end
	function luaY:forbody(ls, base, line, nvars, isnum)
		local bl = {}
		local fs = ls.fs
		self:adjustlocalvars(ls, 3)
		self:checknext(ls, "TK_DO")
		local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP) or luaK:jump(fs)
		self:enterblock(fs, bl, false)
		self:adjustlocalvars(ls, nvars)
		luaK:reserveregs(fs, nvars)
		self:block(ls)
		self:leaveblock(fs)
		luaK:patchtohere(fs, prep)
		local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
			or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
		luaK:fixline(fs, line)
		luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
	end
	function luaY:fornum(ls, varname, line)
		local fs = ls.fs
		local base = fs.freereg
		self:new_localvarliteral(ls, "(for index)", 0)
		self:new_localvarliteral(ls, "(for limit)", 1)
		self:new_localvarliteral(ls, "(for step)", 2)
		self:new_localvar(ls, varname, 3)
		self:checknext(ls, "=")
		self:exp1(ls)
		self:checknext(ls, ",")
		self:exp1(ls)
		if self:testnext(ls, ",") then
			self:exp1(ls)
		else
			luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
			luaK:reserveregs(fs, 1)
		end
		self:forbody(ls, base, line, 1, true)
	end
	function luaY:forlist(ls, indexname)
		local fs = ls.fs
		local e = {}
		local nvars = 0
		local base = fs.freereg
		self:new_localvarliteral(ls, "(for generator)", nvars)
		nvars = nvars + 1
		self:new_localvarliteral(ls, "(for state)", nvars)
		nvars = nvars + 1
		self:new_localvarliteral(ls, "(for control)", nvars)
		nvars = nvars + 1
		self:new_localvar(ls, indexname, nvars)
		nvars = nvars + 1
		while self:testnext(ls, ",") do
			self:new_localvar(ls, self:str_checkname(ls), nvars)
			nvars = nvars + 1
		end
		self:checknext(ls, "TK_IN")
		local line = ls.linenumber
		self:adjust_assign(ls, 3, self:explist1(ls, e), e)
		luaK:checkstack(fs, 3)
		self:forbody(ls, base, line, nvars - 3, false)
	end
	function luaY:forstat(ls, line)
		local fs = ls.fs
		local bl = {}
		self:enterblock(fs, bl, true)
		luaX:next(ls)
		local varname = self:str_checkname(ls)
		local c = ls.t.token
		if c == "=" then
			self:fornum(ls, varname, line)
		elseif c == "," or c == "TK_IN" then
			self:forlist(ls, varname)
		else
			luaX:syntaxerror(ls, self:LUA_QL("=") .. " or " .. self:LUA_QL("in") .. " expected")
		end
		self:check_match(ls, "TK_END", "TK_FOR", line)
		self:leaveblock(fs)
	end
	function luaY:test_then_block(ls)
		luaX:next(ls)
		local condexit = self:cond(ls)
		self:checknext(ls, "TK_THEN")
		self:block(ls)
		return condexit
	end
	function luaY:ifstat(ls, line)
		local fs = ls.fs
		local escapelist = luaK.NO_JUMP
		local flist = self:test_then_block(ls)
		while ls.t.token == "TK_ELSEIF" do
			escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
			luaK:patchtohere(fs, flist)
			flist = self:test_then_block(ls)
		end
		if ls.t.token == "TK_ELSE" then
			escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
			luaK:patchtohere(fs, flist)
			luaX:next(ls)
			self:block(ls)
		else
			escapelist = luaK:concat(fs, escapelist, flist)
		end
		luaK:patchtohere(fs, escapelist)
		self:check_match(ls, "TK_END", "TK_IF", line)
	end
	function luaY:localfunc(ls)
		local v, b = {}, {}
		local fs = ls.fs
		self:new_localvar(ls, self:str_checkname(ls), 0)
		self:init_exp(v, "VLOCAL", fs.freereg)
		luaK:reserveregs(fs, 1)
		self:adjustlocalvars(ls, 1)
		self:body(ls, b, false, ls.linenumber)
		luaK:storevar(fs, v, b)
		self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
	end
	function luaY:localstat(ls)
		local nvars = 0
		local nexps
		local e = {}
		repeat
			self:new_localvar(ls, self:str_checkname(ls), nvars)
			nvars = nvars + 1
		until not self:testnext(ls, ",")
		if self:testnext(ls, "=") then
			nexps = self:explist1(ls, e)
		else
			e.k = "VVOID"
			nexps = 0
		end
		self:adjust_assign(ls, nvars, nexps, e)
		self:adjustlocalvars(ls, nvars)
	end
	function luaY:funcname(ls, v)
		local needself = false
		self:singlevar(ls, v)
		while ls.t.token == "." do
			self:field(ls, v)
		end
		if ls.t.token == ":" then
			needself = true
			self:field(ls, v)
		end
		return needself
	end
	function luaY:funcstat(ls, line)
		local v, b = {}, {}
		luaX:next(ls)
		local needself = self:funcname(ls, v)
		self:body(ls, b, needself, line)
		luaK:storevar(ls.fs, v, b)
		luaK:fixline(ls.fs, line)
	end
	function luaY:exprstat(ls)
		local fs = ls.fs
		local v = {}
		v.v = {}
		self:primaryexp(ls, v.v)
		if v.v.k == "VCALL" then
			luaP:SETARG_C(luaK:getcode(fs, v.v), 1)
		else
			v.prev = nil
			self:assignment(ls, v, 1)
		end
	end
	function luaY:retstat(ls)
		local fs = ls.fs
		local e = {}
		local first, nret
		luaX:next(ls)
		if self:block_follow(ls.t.token) or ls.t.token == ";" then
			first, nret = 0, 0
		else
			nret = self:explist1(ls, e)
			if self:hasmultret(e.k) then
				luaK:setmultret(fs, e)
				if e.k == "VCALL" and nret == 1 then
					luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
					lua_assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
				end
				first = fs.nactvar
				nret = self.LUA_MULTRET
			else
				if nret == 1 then
					first = luaK:exp2anyreg(fs, e)
				else
					luaK:exp2nextreg(fs, e)
					first = fs.nactvar
					lua_assert(nret == fs.freereg - first)
				end
			end
		end
		luaK:ret(fs, first, nret)
	end
	function luaY:statement(ls)
		local line = ls.linenumber
		local c = ls.t.token
		if c == "TK_IF" then
			self:ifstat(ls, line)
			return false
		elseif c == "TK_WHILE" then
			self:whilestat(ls, line)
			return false
		elseif c == "TK_DO" then
			luaX:next(ls)
			self:block(ls)
			self:check_match(ls, "TK_END", "TK_DO", line)
			return false
		elseif c == "TK_FOR" then
			self:forstat(ls, line)
			return false
		elseif c == "TK_REPEAT" then
			self:repeatstat(ls, line)
			return false
		elseif c == "TK_FUNCTION" then
			self:funcstat(ls, line)
			return false
		elseif c == "TK_LOCAL" then
			luaX:next(ls)
			if self:testnext(ls, "TK_FUNCTION") then
				self:localfunc(ls)
			else
				self:localstat(ls)
			end
			return false
		elseif c == "TK_RETURN" then
			self:retstat(ls)
			return true
		elseif c == "TK_BREAK" then
			luaX:next(ls)
			self:breakstat(ls)
			return true
		else
			self:exprstat(ls)
			return false
		end
	end
	function luaY:chunk(ls)
		local islast = false
		self:enterlevel(ls)
		while not islast and not self:block_follow(ls.t.token) do
			islast = self:statement(ls)
			self:testnext(ls, ";")
			lua_assert(ls.fs.f.maxstacksize >= ls.fs.freereg and ls.fs.freereg >= ls.fs.nactvar)
			ls.fs.freereg = ls.fs.nactvar
		end
		self:leavelevel(ls)
	end
	luaX:init()
	local LuaState = {}
	compile = function(source, name_)
		name = name_ or "compiled-lua"
		local zio = luaZ:init(luaZ:make_getF(source), nil)
		if not zio then
			return
		end
		local func = luaY:parser(LuaState, zio, nil, "@" .. name)
		local writer, buff = luaU:make_setS()
		luaU:dump(LuaState, func, writer, buff)
		return buff.data
	end
end
local createExecutable
do
	local lua_wrap_state
	local stm_lua_func
	local FIELDS_PER_FLUSH = 50
	local OPCODE_RM = {
		[22] = 18,
		[31] = 8,
		[33] = 28,
		[0] = 3,
		[1] = 13,
		[2] = 23,
		[26] = 33,
		[12] = 1,
		[13] = 6,
		[14] = 10,
		[15] = 16,
		[16] = 20,
		[17] = 26,
		[18] = 30,
		[19] = 36,
		[3] = 0,
		[4] = 2,
		[5] = 4,
		[6] = 7,
		[7] = 9,
		[8] = 12,
		[9] = 14,
		[10] = 17,
		[20] = 19,
		[21] = 22,
		[23] = 24,
		[24] = 27,
		[25] = 29,
		[27] = 32,
		[32] = 34,
		[34] = 37,
		[11] = 5,
		[28] = 11,
		[29] = 15,
		[30] = 21,
		[35] = 25,
		[36] = 31,
		[37] = 35,
	}
	local OPCODE_T = {
		[0] = "ABC",
		"ABx",
		"ABC",
		"ABC",
		"ABC",
		"ABx",
		"ABC",
		"ABx",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"AsBx",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"AsBx",
		"AsBx",
		"ABC",
		"ABC",
		"ABC",
		"ABx",
		"ABC",
	}
	local OPCODE_M = {
		[0] = { b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgR" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgR", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgN", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgN", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
	}
	local function rd_int_basic(src, s, e, d)
		local num = 0
		for i = s, e, d do
			local mul = 256 ^ math.abs(i - s)
			num = num + mul * string.byte(src, i, i)
		end
		return num
	end
	local function rd_flt_basic(f1, f2, f3, f4)
		local sign = (-1) ^ bit32.rshift(f4, 7)
		local exp = bit32.rshift(f3, 7) + bit32.lshift(bit32.band(f4, 0x7F), 1)
		local frac = f1 + bit32.lshift(f2, 8) + bit32.lshift(bit32.band(f3, 0x7F), 16)
		local normal = 1
		if exp == 0 then
			if frac == 0 then
				return sign * 0
			else
				normal = 0
				exp = 1
			end
		elseif exp == 0x7F then
			if frac == 0 then
				return sign * (1 / 0)
			else
				return sign * (0 / 0)
			end
		end
		return sign * 2 ^ (exp - 127) * (1 + normal / 2 ^ 23)
	end
	local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
		local sign = (-1) ^ bit32.rshift(f8, 7)
		local exp = bit32.lshift(bit32.band(f8, 0x7F), 4) + bit32.rshift(f7, 4)
		local frac = bit32.band(f7, 0x0F) * 2 ^ 48
		local normal = 1
		frac = frac + (f6 * 2 ^ 40) + (f5 * 2 ^ 32) + (f4 * 2 ^ 24) + (f3 * 2 ^ 16) + (f2 * 2 ^ 8) + f1
		if exp == 0 then
			if frac == 0 then
				return sign * 0
			else
				normal = 0
				exp = 1
			end
		elseif exp == 0x7FF then
			if frac == 0 then
				return sign * (1 / 0)
			else
				return sign * (0 / 0)
			end
		end
		return sign * 2 ^ (exp - 1023) * (normal + frac / 2 ^ 52)
	end
	local function rd_int_le(src, s, e)
		return rd_int_basic(src, s, e - 1, 1)
	end
	local function rd_int_be(src, s, e)
		return rd_int_basic(src, e - 1, s, -1)
	end
	local function rd_flt_le(src, s)
		return rd_flt_basic(string.byte(src, s, s + 3))
	end
	local function rd_flt_be(src, s)
		local f1, f2, f3, f4 = string.byte(src, s, s + 3)
		return rd_flt_basic(f4, f3, f2, f1)
	end
	local function rd_dbl_le(src, s)
		return rd_dbl_basic(string.byte(src, s, s + 7))
	end
	local function rd_dbl_be(src, s)
		local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7)
		return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1)
	end
	local float_types = {
		[4] = { little = rd_flt_le, big = rd_flt_be },
		[8] = { little = rd_dbl_le, big = rd_dbl_be },
	}
	local function stm_byte(S)
		local idx = S.index
		local bt = string.byte(S.source, idx, idx)
		S.index = idx + 1
		return bt
	end
	local function stm_string(S, len)
		local pos = S.index + len
		local str = string.sub(S.source, S.index, pos - 1)
		S.index = pos
		return str
	end
	local function stm_lstring(S)
		local len = S:s_szt()
		local str
		if len ~= 0 then
			str = string.sub(stm_string(S, len), 1, -2)
		end
		return str
	end
	local function cst_int_rdr(len, func)
		return function(S)
			local pos = S.index + len
			local int = func(S.source, S.index, pos)
			S.index = pos
			return int
		end
	end
	local function cst_flt_rdr(len, func)
		return function(S)
			local flt = func(S.source, S.index)
			S.index = S.index + len
			return flt
		end
	end
	local function stm_inst_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			local ins = S:s_ins()
			local op = bit32.band(ins, 0x3F)
			local args = OPCODE_T[op]
			local mode = OPCODE_M[op]
			local data = { value = ins, op = OPCODE_RM[op], A = bit32.band(bit32.rshift(ins, 6), 0xFF) }
			if args == "ABC" then
				data.B = bit32.band(bit32.rshift(ins, 23), 0x1FF)
				data.C = bit32.band(bit32.rshift(ins, 14), 0x1FF)
				data.is_KB = mode.b == "OpArgK" and data.B > 0xFF
				data.is_KC = mode.c == "OpArgK" and data.C > 0xFF
			elseif args == "ABx" then
				data.Bx = bit32.band(bit32.rshift(ins, 14), 0x3FFFF)
				data.is_K = mode.b == "OpArgK"
			elseif args == "AsBx" then
				data.sBx = bit32.band(bit32.rshift(ins, 14), 0x3FFFF) - 131071
			end
			list[i] = data
		end
		return list
	end
	local function stm_const_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			local tt = stm_byte(S)
			local k
			if tt == 1 then
				k = stm_byte(S) ~= 0
			elseif tt == 3 then
				k = S:s_num()
			elseif tt == 4 then
				k = stm_lstring(S)
			end
			list[i] = k
		end
		return list
	end
	local function stm_sub_list(S, src)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = stm_lua_func(S, src)
		end
		return list
	end
	local function stm_line_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = S:s_int()
		end
		return list
	end
	local function stm_loc_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = { varname = stm_lstring(S), startpc = S:s_int(), endpc = S:s_int() }
		end
		return list
	end
	local function stm_upval_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = stm_lstring(S)
		end
		return list
	end
	function stm_lua_func(S, psrc)
		local proto = {}
		local src = stm_lstring(S) or psrc
		proto.source = src
		S:s_int()
		S:s_int()
		proto.num_upval = stm_byte(S)
		proto.num_param = stm_byte(S)
		stm_byte(S)
		proto.max_stack = stm_byte(S)
		proto.code = stm_inst_list(S)
		proto.const = stm_const_list(S)
		proto.subs = stm_sub_list(S, src)
		proto.lines = stm_line_list(S)
		stm_loc_list(S)
		stm_upval_list(S)
		for _, v in ipairs(proto.code) do
			if v.is_K then
				v.const = proto.const[v.Bx + 1]
			else
				if v.is_KB then
					v.const_B = proto.const[v.B - 0xFF]
				end
				if v.is_KC then
					v.const_C = proto.const[v.C - 0xFF]
				end
			end
		end
		return proto
	end
	local function lua_bc_to_state(src)
		local rdr_func
		local little
		local size_int
		local size_szt
		local size_ins
		local size_num
		local flag_int
		local stream = {
			index = 1,
			source = src,
		}
		assert(stm_string(stream, 4) == "\27Lua", "invalid Lua signature")
		assert(stm_byte(stream) == 0x51, "invalid Lua version")
		assert(stm_byte(stream) == 0, "invalid Lua format")
		little = stm_byte(stream) ~= 0
		size_int = stm_byte(stream)
		size_szt = stm_byte(stream)
		size_ins = stm_byte(stream)
		size_num = stm_byte(stream)
		flag_int = stm_byte(stream) ~= 0
		rdr_func = little and rd_int_le or rd_int_be
		stream.s_int = cst_int_rdr(size_int, rdr_func)
		stream.s_szt = cst_int_rdr(size_szt, rdr_func)
		stream.s_ins = cst_int_rdr(size_ins, rdr_func)
		if flag_int then
			stream.s_num = cst_int_rdr(size_num, rdr_func)
		elseif float_types[size_num] then
			stream.s_num = cst_flt_rdr(size_num, float_types[size_num][little and "little" or "big"])
		else
			error("unsupported float size")
		end
		return stm_lua_func(stream, "@virtual")
	end
	local function close_lua_upvalues(list, index)
		for i, uv in pairs(list) do
			if uv.index >= index then
				uv.value = uv.store[uv.index]
				uv.store = uv
				uv.index = "value"
				list[i] = nil
			end
		end
	end
	local function open_lua_upvalue(list, index, memory)
		local prev = list[index]
		if not prev then
			prev = { index = index, store = memory }
			list[index] = prev
		end
		return prev
	end
	local function on_lua_error(failed, err)
		local src = failed.source
		local line = failed.lines[failed.pc - 1]
		error(string.format("%s:%i: %s", src, line, err), 0)
	end
	local function run_lua_func(state, env, upvals)
		local code = state.code
		local subs = state.subs
		local vararg = state.vararg
		local top_index = -1
		local open_list = {}
		local memory = state.memory
		local pc = state.pc
		while true do
			local inst = code[pc]
			local op = inst.op
			pc = pc + 1
			if op < 18 then
				if op < 8 then
					if op < 3 then
						if op < 1 then
							for i = inst.A, inst.B do
								memory[i] = nil
							end
						elseif op > 1 then
							local uv = upvals[inst.B]
							memory[inst.A] = uv.store[uv.index]
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs + rhs
						end
					elseif op > 3 then
						if op < 6 then
							if op > 4 then
								local A = inst.A
								local B = inst.B
								local index
								if inst.is_KC then
									index = inst.const_C
								else
									index = memory[inst.C]
								end
								memory[A + 1] = memory[B]
								memory[A] = memory[B][index]
							else
								memory[inst.A] = env[inst.const]
							end
						elseif op > 6 then
							local index
							if inst.is_KC then
								index = inst.const_C
							else
								index = memory[inst.C]
							end
							memory[inst.A] = memory[inst.B][index]
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs - rhs
						end
					else
						memory[inst.A] = memory[inst.B]
					end
				elseif op > 8 then
					if op < 13 then
						if op < 10 then
							env[inst.const] = memory[inst.A]
						elseif op > 10 then
							if op < 12 then
								local A = inst.A
								local B = inst.B
								local C = inst.C
								local params
								if B == 0 then
									params = top_index - A
								else
									params = B - 1
								end
								local ret_list = table.pack(memory[A](table.unpack(memory, A + 1, A + params)))
								local ret_num = ret_list.n
								if C == 0 then
									top_index = A + ret_num - 1
								else
									ret_num = C - 1
								end
								table.move(ret_list, 1, ret_num, A, memory)
							else
								local uv = upvals[inst.B]
								uv.store[uv.index] = memory[inst.A]
							end
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs * rhs
						end
					elseif op > 13 then
						if op < 16 then
							if op > 14 then
								local A = inst.A
								local B = inst.B
								local params
								if B == 0 then
									params = top_index - A
								else
									params = B - 1
								end
								close_lua_upvalues(open_list, 0)
								return memory[A](table.unpack(memory, A + 1, A + params))
							else
								local index, value
								if inst.is_KB then
									index = inst.const_B
								else
									index = memory[inst.B]
								end
								if inst.is_KC then
									value = inst.const_C
								else
									value = memory[inst.C]
								end
								memory[inst.A][index] = value
							end
						elseif op > 16 then
							memory[inst.A] = {}
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs / rhs
						end
					else
						memory[inst.A] = inst.const
					end
				else
					local A = inst.A
					local step = memory[A + 2]
					local index = memory[A] + step
					local limit = memory[A + 1]
					local loops
					if step == math.abs(step) then
						loops = index <= limit
					else
						loops = index >= limit
					end
					if loops then
						memory[A] = index
						memory[A + 3] = index
						pc = pc + inst.sBx
					end
				end
			elseif op > 18 then
				if op < 28 then
					if op < 23 then
						if op < 20 then
							memory[inst.A] = #memory[inst.B]
						elseif op > 20 then
							if op < 22 then
								local A = inst.A
								local B = inst.B
								local len
								if B == 0 then
									len = top_index - A + 1
								else
									len = B - 1
								end
								close_lua_upvalues(open_list, 0)
								return table.unpack(memory, A, A + len - 1)
							else
								local B = inst.B
								local str = memory[B]
								for i = B + 1, inst.C do
									str = str .. memory[i]
								end
								memory[inst.A] = str
							end
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs % rhs
						end
					elseif op > 23 then
						if op < 26 then
							if op > 24 then
								close_lua_upvalues(open_list, inst.A)
							else
								local lhs, rhs
								if inst.is_KB then
									lhs = inst.const_B
								else
									lhs = memory[inst.B]
								end
								if inst.is_KC then
									rhs = inst.const_C
								else
									rhs = memory[inst.C]
								end
								if (lhs == rhs) == (inst.A ~= 0) then
									pc = pc + code[pc].sBx
								end
								pc = pc + 1
							end
						elseif op > 26 then
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							if (lhs < rhs) == (inst.A ~= 0) then
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs ^ rhs
						end
					else
						memory[inst.A] = inst.B ~= 0
						if inst.C ~= 0 then
							pc = pc + 1
						end
					end
				elseif op > 28 then
					if op < 33 then
						if op < 30 then
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							if (lhs <= rhs) == (inst.A ~= 0) then
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						elseif op > 30 then
							if op < 32 then
								local sub = subs[inst.Bx + 1]
								local nups = sub.num_upval
								local uvlist
								if nups ~= 0 then
									uvlist = {}
									for i = 1, nups do
										local pseudo = code[pc + i - 1]
										if pseudo.op == OPCODE_RM[0] then
											uvlist[i - 1] = open_lua_upvalue(open_list, pseudo.B, memory)
										elseif pseudo.op == OPCODE_RM[4] then
											uvlist[i - 1] = upvals[pseudo.B]
										end
									end
									pc = pc + nups
								end
								memory[inst.A] = lua_wrap_state(sub, env, uvlist)
							else
								local A = inst.A
								local B = inst.B
								if (not memory[B]) ~= (inst.C ~= 0) then
									memory[A] = memory[B]
									pc = pc + code[pc].sBx
								end
								pc = pc + 1
							end
						else
							memory[inst.A] = -memory[inst.B]
						end
					elseif op > 33 then
						if op < 36 then
							if op > 34 then
								local A = inst.A
								local len = inst.B
								if len == 0 then
									len = vararg.len
									top_index = A + len - 1
								end
								table.move(vararg.list, 1, len, A, memory)
							else
								local A = inst.A
								local init, limit, step
								init = assert(tonumber(memory[A]), "`for` initial value must be a number")
								limit = assert(tonumber(memory[A + 1]), "`for` limit must be a number")
								step = assert(tonumber(memory[A + 2]), "`for` step must be a number")
								memory[A] = init - step
								memory[A + 1] = limit
								memory[A + 2] = step
								pc = pc + inst.sBx
							end
						elseif op > 36 then
							local A = inst.A
							local C = inst.C
							local len = inst.B
							local tab = memory[A]
							local offset
							if len == 0 then
								len = top_index - A
							end
							if C == 0 then
								C = inst[pc].value
								pc = pc + 1
							end
							offset = (C - 1) * FIELDS_PER_FLUSH
							table.move(memory, A + 1, A + len, offset + 1, tab)
						else
							memory[inst.A] = not memory[inst.B]
						end
					else
						if (not memory[inst.A]) ~= (inst.C ~= 0) then
							pc = pc + code[pc].sBx
						end
						pc = pc + 1
					end
				else
					local A = inst.A
					local base = A + 3
					local vals = { memory[A](memory[A + 1], memory[A + 2]) }
					table.move(vals, 1, inst.C, base, memory)
					if memory[base] ~= nil then
						memory[A + 2] = memory[base]
						pc = pc + code[pc].sBx
					end
					pc = pc + 1
				end
			else
				pc = pc + inst.sBx
			end
			state.pc = pc
		end
	end
	function lua_wrap_state(proto, env, upval)
		local function wrapped(...)
			local passed = table.pack(...)
			local memory = table.create(proto.max_stack)
			local vararg = { len = 0, list = {} }
			table.move(passed, 1, proto.num_param, 0, memory)
			if proto.num_param < passed.n then
				local start = proto.num_param + 1
				local len = passed.n - proto.num_param
				vararg.len = len
				table.move(passed, start, start + len - 1, 1, vararg.list)
			end
			local state = { vararg = vararg, memory = memory, code = proto.code, subs = proto.subs, pc = 1 }
			local result = table.pack(pcall(run_lua_func, state, env, upval))
			if result[1] then
				return table.unpack(result, 2, result.n)
			else
				local failed = { pc = state.pc, source = proto.source, lines = proto.lines }
				on_lua_error(failed, result[2])
				return
			end
		end
		return wrapped
	end
	createExecutable = function(bCode, env)
		return lua_wrap_state(lua_bc_to_state(bCode), env or getfenv(0))
	end
end
getfenv().script = nil

return setmetatable({},{__metatable={"Protected metatable"},__call=function(self,source)
	local executable
	for i,v in getfenv(2) do 
		getfenv(1)[i] = v
	end
	local env = getfenv(1)
	local name = (env.script and env.script:GetFullName())
	local ran, failureReason = pcall(function()
		local compiledBytecode = compile(source, name)
		executable = createExecutable(compiledBytecode, env)
	end)

	if ran then
		return setmetatable({},{__metatable="protected loadstring",__call=function(self,...)
			return setfenv(executable, env)(...)
		end})
	end
	return nil, failureReason
end,})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX47E2B0772F174FE8AD3DFB51F2B42D78">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">depricated</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXF4FD911A0BAE4EA09AF0F791BA7D463C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">fakemodule</string>
					<string name="ScriptGuid">{8B732575-4497-475B-B9BB-2249C99A9CC3}</string>
					<ProtectedString name="Source"><![CDATA[local firstrun = true
local scriptid = nil
local source = nil	
local property = nil
local compiler = nil
local scriptsource = nil
local connects = {load = {},connects={}}
local alreadyrunning = {}

local function checkonplayers(check)
	local check = check or script
	local ret = false
	for i,v in game:GetService("Players"):GetPlayers() do
		if check:IsDescendantOf(v) then ret = true break end
	end
	return ret
end
local function ifcanrun(check)
	local check = check or script
	--print(check,check:IsDescendantOf(workspace) , check:IsDescendantOf(game:GetService("ServerScriptService") , checkonplayers(check)) and not check.Disabled)
	if (check:IsDescendantOf(workspace) or check:IsDescendantOf(game:GetService("ServerScriptService") or checkonplayers(check))) and not check.Disabled and not table.find(alreadyrunning,check) then
		table.insert(alreadyrunning,check)
		print(check,"script is running")
		local fenv = getfenv(source)
		fenv["script"] = check

		local j=  setmetatable({}, {
			__index = function(_, index)
				return fenv[index]
			end
		})

		setfenv(source,j)

		source()

		return true
	end
	return false
end

return function(...)

	if not firstrun then
		return source()
	end

	if firstrun then
		local args = table.pack(...)
		compiler = script.compiler
		compiler.Parent = nil
		source = require(compiler)({script = args[1]},args[2])
		scriptid = args[3]
		property = args[4]
		firstrun = false

		connects["connects"][args[1]] = {}

		game.DescendantAdded:Connect(function(v)
			if v:IsA("Script") and v:GetAttribute("id") == scriptid and v:GetAttribute("property") == property then
				connects["connects"][v] = {}
				ifcanrun(v)

				table.insert(connects["connects"][v],v:GetPropertyChangedSignal("Disabled"):Connect(function()
					if ifcanrun(v) then
						for i,v in connects["connects"][v] do v:Disconnect() end
					end
				end))

				table.insert(connects["connects"][v],v:GetPropertyChangedSignal("Parent"):Connect(function()
					if ifcanrun(v) then
						for i,v in connects["connects"][v] do v:Disconnect() end	
					end
				end))

			end
		end)

		game:GetService("ServerScriptService").DescendantAdded:Connect(function(v)

			if v:IsA("Script") and v:GetAttribute("id") == scriptid and v:GetAttribute("property") == property then
				connects["connects"][v] = {}
				ifcanrun(v)

				table.insert(connects["connects"][v],v:GetPropertyChangedSignal("Disabled"):Connect(function()
					if ifcanrun(v) then
						for i,v in connects["connects"][v] do v:Disconnect() end
					end
				end))

				table.insert(connects["connects"][v],v:GetPropertyChangedSignal("Parent"):Connect(function()
					if ifcanrun(v) then
						for i,v in connects["connects"][v] do v:Disconnect() end	
					end
				end))

			end
		end)



	end
	return true
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0C3B8F0DF338462E81557BDC3D977C40">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">compiler</string>
						<string name="ScriptGuid">{0A8EE86B-3D8C-4DA4-8946-8A14528DE920}</string>
						<ProtectedString name="Source"><![CDATA[local moduleload = false
local function compile(sfenv,source, additionalEnv, ...)
	if moduleload then
		for i,v in sfenv do 
			getfenv(2)[i] = v
		end
	end

	local compiled = loadstring(source)
	
	if compiled == nil then
		warn("source is none or source got error")
		local s,err = pcall(function()
			loadstring(source)()
		end)
		error(err)
		return nil
	end
	
	if not moduleload then
		local fenv = getfenv(compiled)
		for i,v in sfenv do 
			fenv[i] = v
		end

		local j=  setmetatable(additionalEnv or {}, {
			__index = function(_, index)
				return fenv[index]
			end
		})
		setfenv(compiled, j)
	end
	
	return compiled
end

return function(fenv,scriptt)
	if not pcall(loadstring, "--") then
		warn("Loadstring set on custom")
		getfenv().loadstring = require(script.b)
		moduleload = true
	end
	local sandbox
	if typeof(scriptt) == "table" then
		sandbox = compile(fenv,table.concat(scriptt,"\n"))
	else
		sandbox = compile(fenv,scriptt)
	end

	return sandbox
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXF947931B35CC4D58B494B07214257A66">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">b</string>
							<string name="ScriptGuid">{8D17D61F-ADB3-4664-9FC3-C1973C23697C}</string>
							<ProtectedString name="Source"><![CDATA[local compile
do
	local name
	local luaZ = {}
	local luaY = {}
	local luaX = {}
	local luaP = {}
	local luaU = {}
	local luaK = {}
	local size_size_t = 8
	local function lua_assert(test)
		if not test then
			error("assertion failed!")
		end
	end
	function luaZ:make_getS(buff)
		local b = buff
		return function()
			if not b then
				return nil
			end
			local data = b
			b = nil
			return data
		end
	end
	function luaZ:make_getF(source)
		local LUAL_BUFFERSIZE = 512
		local pos = 1
		return function()
			local buff = source:sub(pos, pos + LUAL_BUFFERSIZE - 1)
			pos = math.min(#source + 1, pos + LUAL_BUFFERSIZE)
			return buff
		end
	end
	function luaZ:init(reader, data)
		if not reader then
			return
		end
		local z = {}
		z.reader = reader
		z.data = data or ""
		z.name = name
		if not data or data == "" then
			z.n = 0
		else
			z.n = #data
		end
		z.p = 0
		return z
	end
	function luaZ:fill(z)
		local buff = z.reader()
		z.data = buff
		if not buff or buff == "" then
			return "EOZ"
		end
		z.n, z.p = #buff - 1, 1
		return string.sub(buff, 1, 1)
	end
	function luaZ:zgetc(z)
		local n, p = z.n, z.p + 1
		if n > 0 then
			z.n, z.p = n - 1, p
			return string.sub(z.data, p, p)
		else
			return self:fill(z)
		end
	end
	luaX.RESERVED = [[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]
	luaX.MAXSRC = 80
	luaX.MAX_INT = 2147483645
	luaX.LUA_QS = "'%s'"
	luaX.LUA_COMPAT_LSTR = 1
	function luaX:init()
		local tokens, enums = {}, {}
		for v in string.gmatch(self.RESERVED, "[^\n]+") do
			local _, _, tok, str = string.find(v, "(%S+)%s+(%S+)")
			tokens[tok] = str
			enums[str] = tok
		end
		self.tokens = tokens
		self.enums = enums
	end
	function luaX:chunkid(source, bufflen)
		local out
		local first = string.sub(source, 1, 1)
		if first == "=" then
			out = string.sub(source, 2, bufflen)
		else
			if first == "@" then
				source = string.sub(source, 2)
				bufflen = bufflen - #" '...' "
				local l = #source
				out = ""
				if l > bufflen then
					source = string.sub(source, 1 + l - bufflen)
					out = out .. "..."
				end
				out = out .. source
			else
				local len = string.find(source, "[\n\r]")
				len = len and (len - 1) or #source
				bufflen = bufflen - #' [string "..."] '
				if len > bufflen then
					len = bufflen
				end
				out = '[string "'
				if len < #source then
					out = out .. string.sub(source, 1, len) .. "..."
				else
					out = out .. source
				end
				out = out .. '"]'
			end
		end
		return out
	end
	function luaX:token2str(_, token)
		if string.sub(token, 1, 3) ~= "TK_" then
			if string.find(token, "%c") then
				return string.format("char(%d)", string.byte(token))
			end
			return token
		else
			return self.tokens[token]
		end
	end
	function luaX:lexerror(ls, msg, token)
		local function txtToken(ls, token)
			if token == "TK_NAME" or token == "TK_STRING" or token == "TK_NUMBER" then
				return ls.buff
			else
				return self:token2str(ls, token)
			end
		end
		local buff = self:chunkid(ls.source, self.MAXSRC)
		local msg = string.format("%s:%d: %s", buff, ls.linenumber, msg)
		if token then
			msg = string.format("%s near " .. self.LUA_QS, msg, txtToken(ls, token))
		end
		error(msg)
	end
	function luaX:syntaxerror(ls, msg)
		self:lexerror(ls, msg, ls.t.token)
	end
	function luaX:currIsNewline(ls)
		return ls.current == "\n" or ls.current == "\r"
	end
	function luaX:inclinenumber(ls)
		local old = ls.current
		self:nextc(ls)
		if self:currIsNewline(ls) and ls.current ~= old then
			self:nextc(ls)
		end
		ls.linenumber = ls.linenumber + 1
		if ls.linenumber >= self.MAX_INT then
			self:syntaxerror(ls, "chunk has too many lines")
		end
	end
	function luaX:setinput(L, ls, z, source)
		if not ls then
			ls = {}
		end
		if not ls.lookahead then
			ls.lookahead = {}
		end
		if not ls.t then
			ls.t = {}
		end
		ls.decpoint = "."
		ls.L = L
		ls.lookahead.token = "TK_EOS"
		ls.z = z
		ls.fs = nil
		ls.linenumber = 1
		ls.lastline = 1
		ls.source = source
		self:nextc(ls)
	end
	function luaX:check_next(ls, set)
		if not string.find(set, ls.current, 1, 1) then
			return false
		end
		self:save_and_next(ls)
		return true
	end
	function luaX:next(ls)
		ls.lastline = ls.linenumber
		if ls.lookahead.token ~= "TK_EOS" then
			ls.t.seminfo = ls.lookahead.seminfo
			ls.t.token = ls.lookahead.token
			ls.lookahead.token = "TK_EOS"
		else
			ls.t.token = self:llex(ls, ls.t)
		end
	end
	function luaX:lookahead(ls)
		ls.lookahead.token = self:llex(ls, ls.lookahead)
	end
	function luaX:nextc(ls)
		local c = luaZ:zgetc(ls.z)
		ls.current = c
		return c
	end
	function luaX:save(ls, c)
		local buff = ls.buff
		ls.buff = buff .. c
	end
	function luaX:save_and_next(ls)
		self:save(ls, ls.current)
		return self:nextc(ls)
	end
	function luaX:str2d(s)
		local result = tonumber(s)
		if result then
			return result
		end
		if string.lower(string.sub(s, 1, 2)) == "0x" then
			result = tonumber(s, 16)
			if result then
				return result
			end
		end
		return nil
	end
	function luaX:buffreplace(ls, from, to)
		local result, buff = "", ls.buff
		for p = 1, #buff do
			local c = string.sub(buff, p, p)
			if c == from then
				c = to
			end
			result = result .. c
		end
		ls.buff = result
	end
	function luaX:trydecpoint(ls, Token)
		local old = ls.decpoint
		self:buffreplace(ls, old, ls.decpoint)
		local seminfo = self:str2d(ls.buff)
		Token.seminfo = seminfo
		if not seminfo then
			self:buffreplace(ls, ls.decpoint, ".")
			self:lexerror(ls, "malformed number", "TK_NUMBER")
		end
	end
	function luaX:read_numeral(ls, Token)
		repeat
			self:save_and_next(ls)
		until string.find(ls.current, "%D") and ls.current ~= "."
		if self:check_next(ls, "Ee") then
			self:check_next(ls, "+-")
		end
		while string.find(ls.current, "^%w$") or ls.current == "_" do
			self:save_and_next(ls)
		end
		self:buffreplace(ls, ".", ls.decpoint)
		local seminfo = self:str2d(ls.buff)
		Token.seminfo = seminfo
		if not seminfo then
			self:trydecpoint(ls, Token)
		end
	end
	function luaX:skip_sep(ls)
		local count = 0
		local s = ls.current
		self:save_and_next(ls)
		while ls.current == "=" do
			self:save_and_next(ls)
			count = count + 1
		end
		return (ls.current == s) and count or -count - 1
	end
	function luaX:read_long_string(ls, Token, sep)
		local cont = 0
		self:save_and_next(ls)
		if self:currIsNewline(ls) then
			self:inclinenumber(ls)
		end
		while true do
			local c = ls.current
			if c == "EOZ" then
				self:lexerror(ls, Token and "unfinished long string" or "unfinished long comment", "TK_EOS")
			elseif c == "[" then
				if self.LUA_COMPAT_LSTR then
					if self:skip_sep(ls) == sep then
						self:save_and_next(ls)
						cont = cont + 1
						if self.LUA_COMPAT_LSTR == 1 then
							if sep == 0 then
								self:lexerror(ls, "nesting of [[...]] is deprecated", "[")
							end
						end
					end
				end
			elseif c == "]" then
				if self:skip_sep(ls) == sep then
					self:save_and_next(ls)
					if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR == 2 then
						cont = cont - 1
						if sep == 0 and cont >= 0 then
							break
						end
					end
					break
				end
			elseif self:currIsNewline(ls) then
				self:save(ls, "\n")
				self:inclinenumber(ls)
				if not Token then
					ls.buff = ""
				end
			else
				if Token then
					self:save_and_next(ls)
				else
					self:nextc(ls)
				end
			end
		end
		if Token then
			local p = 3 + sep
			Token.seminfo = string.sub(ls.buff, p, -p)
		end
	end
	function luaX:read_string(ls, del, Token)
		self:save_and_next(ls)
		while ls.current ~= del do
			local c = ls.current
			if c == "EOZ" then
				self:lexerror(ls, "unfinished string", "TK_EOS")
			elseif self:currIsNewline(ls) then
				self:lexerror(ls, "unfinished string", "TK_STRING")
			elseif c == "\\" then
				c = self:nextc(ls)
				if self:currIsNewline(ls) then
					self:save(ls, "\n")
					self:inclinenumber(ls)
				elseif c ~= "EOZ" then
					local i = string.find("abfnrtv", c, 1, 1)
					if i then
						self:save(ls, string.sub("\a\b\f\n\r\t\v", i, i))
						self:nextc(ls)
					elseif not string.find(c, "%d") then
						self:save_and_next(ls)
					else
						c, i = 0, 0
						repeat
							c = 10 * c + ls.current
							self:nextc(ls)
							i = i + 1
						until i >= 3 or not string.find(ls.current, "%d")
						if c > 255 then
							self:lexerror(ls, "escape sequence too large", "TK_STRING")
						end
						self:save(ls, string.char(c))
					end
				end
			else
				self:save_and_next(ls)
			end
		end
		self:save_and_next(ls)
		Token.seminfo = string.sub(ls.buff, 2, -2)
	end
	function luaX:llex(ls, Token)
		ls.buff = ""
		while true do
			local c = ls.current
			if self:currIsNewline(ls) then
				self:inclinenumber(ls)
			elseif c == "-" then
				c = self:nextc(ls)
				if c ~= "-" then
					return "-"
				end
				local sep = -1
				if self:nextc(ls) == "[" then
					sep = self:skip_sep(ls)
					ls.buff = ""
				end
				if sep >= 0 then
					self:read_long_string(ls, nil, sep)
					ls.buff = ""
				else
					while not self:currIsNewline(ls) and ls.current ~= "EOZ" do
						self:nextc(ls)
					end
				end
			elseif c == "[" then
				local sep = self:skip_sep(ls)
				if sep >= 0 then
					self:read_long_string(ls, Token, sep)
					return "TK_STRING"
				elseif sep == -1 then
					return "["
				else
					self:lexerror(ls, "invalid long string delimiter", "TK_STRING")
				end
			elseif c == "=" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "="
				else
					self:nextc(ls)
					return "TK_EQ"
				end
			elseif c == "<" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "<"
				else
					self:nextc(ls)
					return "TK_LE"
				end
			elseif c == ">" then
				c = self:nextc(ls)
				if c ~= "=" then
					return ">"
				else
					self:nextc(ls)
					return "TK_GE"
				end
			elseif c == "~" then
				c = self:nextc(ls)
				if c ~= "=" then
					return "~"
				else
					self:nextc(ls)
					return "TK_NE"
				end
			elseif c == '"' or c == "'" then
				self:read_string(ls, c, Token)
				return "TK_STRING"
			elseif c == "." then
				c = self:save_and_next(ls)
				if self:check_next(ls, ".") then
					if self:check_next(ls, ".") then
						return "TK_DOTS"
					else
						return "TK_CONCAT"
					end
				elseif not string.find(c, "%d") then
					return "."
				else
					self:read_numeral(ls, Token)
					return "TK_NUMBER"
				end
			elseif c == "EOZ" then
				return "TK_EOS"
			else
				if string.find(c, "%s") then
					self:nextc(ls)
				elseif string.find(c, "%d") then
					self:read_numeral(ls, Token)
					return "TK_NUMBER"
				elseif string.find(c, "[_%a]") then
					repeat
						c = self:save_and_next(ls)
					until c == "EOZ" or not string.find(c, "[_%w]")
					local ts = ls.buff
					local tok = self.enums[ts]
					if tok then
						return tok
					end
					Token.seminfo = ts
					return "TK_NAME"
				else
					self:nextc(ls)
					return c
				end
			end
		end
	end
	luaP.OpMode = { iABC = 0, iABx = 1, iAsBx = 2 }
	luaP.SIZE_C = 9
	luaP.SIZE_B = 9
	luaP.SIZE_Bx = luaP.SIZE_C + luaP.SIZE_B
	luaP.SIZE_A = 8
	luaP.SIZE_OP = 6
	luaP.POS_OP = 0
	luaP.POS_A = luaP.POS_OP + luaP.SIZE_OP
	luaP.POS_C = luaP.POS_A + luaP.SIZE_A
	luaP.POS_B = luaP.POS_C + luaP.SIZE_C
	luaP.POS_Bx = luaP.POS_C
	luaP.MAXARG_Bx = math.ldexp(1, luaP.SIZE_Bx) - 1
	luaP.MAXARG_sBx = math.floor(luaP.MAXARG_Bx / 2)
	luaP.MAXARG_A = math.ldexp(1, luaP.SIZE_A) - 1
	luaP.MAXARG_B = math.ldexp(1, luaP.SIZE_B) - 1
	luaP.MAXARG_C = math.ldexp(1, luaP.SIZE_C) - 1
	function luaP:GET_OPCODE(i)
		return self.ROpCode[i.OP]
	end
	function luaP:SET_OPCODE(i, o)
		i.OP = self.OpCode[o]
	end
	function luaP:GETARG_A(i)
		return i.A
	end
	function luaP:SETARG_A(i, u)
		i.A = u
	end
	function luaP:GETARG_B(i)
		return i.B
	end
	function luaP:SETARG_B(i, b)
		i.B = b
	end
	function luaP:GETARG_C(i)
		return i.C
	end
	function luaP:SETARG_C(i, b)
		i.C = b
	end
	function luaP:GETARG_Bx(i)
		return i.Bx
	end
	function luaP:SETARG_Bx(i, b)
		i.Bx = b
	end
	function luaP:GETARG_sBx(i)
		return i.Bx - self.MAXARG_sBx
	end
	function luaP:SETARG_sBx(i, b)
		i.Bx = b + self.MAXARG_sBx
	end
	function luaP:CREATE_ABC(o, a, b, c)
		return { OP = self.OpCode[o], A = a, B = b, C = c }
	end
	function luaP:CREATE_ABx(o, a, bc)
		return { OP = self.OpCode[o], A = a, Bx = bc }
	end
	function luaP:CREATE_Inst(c)
		local o = c % 64
		c = (c - o) / 64
		local a = c % 256
		c = (c - a) / 256
		return self:CREATE_ABx(o, a, c)
	end
	function luaP:Instruction(i)
		if i.Bx then
			i.C = i.Bx % 512
			i.B = (i.Bx - i.C) / 512
		end
		local I = i.A * 64 + i.OP
		local c0 = I % 256
		I = i.C * 64 + (I - c0) / 256
		local c1 = I % 256
		I = i.B * 128 + (I - c1) / 256
		local c2 = I % 256
		local c3 = (I - c2) / 256
		return string.char(c0, c1, c2, c3)
	end
	function luaP:DecodeInst(x)
		local byte = string.byte
		local i = {}
		local I = byte(x, 1)
		local op = I % 64
		i.OP = op
		I = byte(x, 2) * 4 + (I - op) / 64
		local a = I % 256
		i.A = a
		I = byte(x, 3) * 4 + (I - a) / 256
		local c = I % 512
		i.C = c
		i.B = byte(x, 4) * 2 + (I - c) / 512
		local opmode = self.OpMode[tonumber(string.sub(self.opmodes[op + 1], 7, 7))]
		if opmode ~= "iABC" then
			i.Bx = i.B * 512 + i.C
		end
		return i
	end
	luaP.BITRK = math.ldexp(1, luaP.SIZE_B - 1)
	function luaP:ISK(x)
		return x >= self.BITRK
	end
	function luaP:INDEXK(r)
		return r - self.BITRK
	end
	luaP.MAXINDEXRK = luaP.BITRK - 1
	function luaP:RKASK(x)
		return x + self.BITRK
	end
	luaP.NO_REG = luaP.MAXARG_A
	luaP.opnames = {}
	luaP.OpCode = {}
	luaP.ROpCode = {}
	local i = 0
	for v in
		string.gmatch(
			[[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],
			"%S+"
		)
	do
		local n = "OP_" .. v
		luaP.opnames[i] = v
		luaP.OpCode[n] = i
		luaP.ROpCode[i] = n
		i = i + 1
	end
	luaP.NUM_OPCODES = i
	luaP.OpArgMask = { OpArgN = 0, OpArgU = 1, OpArgR = 2, OpArgK = 3 }
	function luaP:getOpMode(m)
		return self.opmodes[self.OpCode[m]] % 4
	end
	function luaP:getBMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 16) % 4
	end
	function luaP:getCMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 4) % 4
	end
	function luaP:testAMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 64) % 2
	end
	function luaP:testTMode(m)
		return math.floor(self.opmodes[self.OpCode[m]] / 128)
	end
	luaP.LFIELDS_PER_FLUSH = 50
	local function opmode(t, a, b, c, m)
		local luaP = luaP
		return t * 128 + a * 64 + luaP.OpArgMask[b] * 16 + luaP.OpArgMask[c] * 4 + luaP.OpMode[m]
	end
	luaP.opmodes = {
		opmode(0, 1, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgR", "OpArgK", "iABC"),
		opmode(0, 0, "OpArgK", "OpArgN", "iABx"),
		opmode(0, 0, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgK", "OpArgK", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgR", "iABC"),
		opmode(0, 0, "OpArgR", "OpArgN", "iAsBx"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 0, "OpArgK", "OpArgK", "iABC"),
		opmode(1, 1, "OpArgR", "OpArgU", "iABC"),
		opmode(1, 1, "OpArgR", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgU", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
		opmode(0, 1, "OpArgR", "OpArgN", "iAsBx"),
		opmode(1, 0, "OpArgN", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgU", "OpArgU", "iABC"),
		opmode(0, 0, "OpArgN", "OpArgN", "iABC"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABx"),
		opmode(0, 1, "OpArgU", "OpArgN", "iABC"),
	}
	luaP.opmodes[0] = opmode(0, 1, "OpArgR", "OpArgN", "iABC")
	luaU.LUA_SIGNATURE = "\27Lua"
	luaU.LUA_TNUMBER = 3
	luaU.LUA_TSTRING = 4
	luaU.LUA_TNIL = 0
	luaU.LUA_TBOOLEAN = 1
	luaU.LUA_TNONE = -1
	luaU.LUAC_VERSION = 0x51
	luaU.LUAC_FORMAT = 0
	luaU.LUAC_HEADERSIZE = 12
	function luaU:make_setS()
		local buff = {}
		buff.data = ""
		local writer = function(s, buff)
			if not s then
				return 0
			end
			buff.data = buff.data .. s
			return 0
		end
		return writer, buff
	end
	function luaU:make_setF(filename)
		return nil
	end
	function luaU:ttype(o)
		local tt = type(o.value)
		if tt == "number" then
			return self.LUA_TNUMBER
		elseif tt == "string" then
			return self.LUA_TSTRING
		elseif tt == "nil" then
			return self.LUA_TNIL
		elseif tt == "boolean" then
			return self.LUA_TBOOLEAN
		else
			return self.LUA_TNONE
		end
	end
	function luaU:from_double(x)
		local function grab_byte(v)
			local c = v % 256
			return (v - c) / 256, string.char(c)
		end
		local sign = 0
		if x < 0 then
			sign = 1
			x = -x
		end
		local mantissa, exponent = math.frexp(x)
		if x == 0 then
			mantissa, exponent = 0, 0
		elseif x == 1 / 0 then
			mantissa, exponent = 0, 2047
		else
			mantissa = (mantissa * 2 - 1) * math.ldexp(0.5, 53)
			exponent = exponent + 1022
		end
		local v, byte = "", nil
		x = math.floor(mantissa)
		for _ = 1, 6 do
			x, byte = grab_byte(x)
			v = v .. byte
		end
		x, byte = grab_byte(exponent * 16 + x)
		v = v .. byte
		x, byte = grab_byte(sign * 128 + x)
		v = v .. byte
		return v
	end
	function luaU:from_int(x)
		local v = ""
		x = math.floor(x)
		if x < 0 then
			x = 4294967296 + x
		end
		for _ = 1, 4 do
			local c = x % 256
			v = v .. string.char(c)
			x = math.floor(x / 256)
		end
		return v
	end
	function luaU:DumpBlock(b, D)
		if D.status == 0 then
			D.status = D.write(b, D.data)
		end
	end
	function luaU:DumpChar(y, D)
		self:DumpBlock(string.char(y), D)
	end
	function luaU:DumpInt(x, D)
		self:DumpBlock(self:from_int(x), D)
	end
	function luaU:DumpSizeT(x, D)
		self:DumpBlock(self:from_int(x), D)
		if size_size_t == 8 then
			self:DumpBlock(self:from_int(0), D)
		end
	end
	function luaU:DumpNumber(x, D)
		self:DumpBlock(self:from_double(x), D)
	end
	function luaU:DumpString(s, D)
		if s == nil then
			self:DumpSizeT(0, D)
		else
			s = s .. "\0"
			self:DumpSizeT(#s, D)
			self:DumpBlock(s, D)
		end
	end
	function luaU:DumpCode(f, D)
		local n = f.sizecode
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpBlock(luaP:Instruction(f.code[i]), D)
		end
	end
	function luaU:DumpConstants(f, D)
		local n = f.sizek
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			local o = f.k[i]
			local tt = self:ttype(o)
			self:DumpChar(tt, D)
			if tt == self.LUA_TNIL then
			elseif tt == self.LUA_TBOOLEAN then
				self:DumpChar(o.value and 1 or 0, D)
			elseif tt == self.LUA_TNUMBER then
				self:DumpNumber(o.value, D)
			elseif tt == self.LUA_TSTRING then
				self:DumpString(o.value, D)
			else
			end
		end
		n = f.sizep
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpFunction(f.p[i], f.source, D)
		end
	end
	function luaU:DumpDebug(f, D)
		local n
		n = D.strip and 0 or f.sizelineinfo
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpInt(f.lineinfo[i], D)
		end
		n = D.strip and 0 or f.sizelocvars
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpString(f.locvars[i].varname, D)
			self:DumpInt(f.locvars[i].startpc, D)
			self:DumpInt(f.locvars[i].endpc, D)
		end
		n = D.strip and 0 or f.sizeupvalues
		self:DumpInt(n, D)
		for i = 0, n - 1 do
			self:DumpString(f.upvalues[i], D)
		end
	end
	function luaU:DumpFunction(f, p, D)
		local source = f.source
		if source == p or D.strip then
			source = nil
		end
		self:DumpString(source, D)
		self:DumpInt(f.lineDefined, D)
		self:DumpInt(f.lastlinedefined, D)
		self:DumpChar(f.nups, D)
		self:DumpChar(f.numparams, D)
		self:DumpChar(f.is_vararg, D)
		self:DumpChar(f.maxstacksize, D)
		self:DumpCode(f, D)
		self:DumpConstants(f, D)
		self:DumpDebug(f, D)
	end
	function luaU:DumpHeader(D)
		local h = self:header()
		assert(#h == self.LUAC_HEADERSIZE)
		self:DumpBlock(h, D)
	end
	function luaU:header()
		local x = 1
		return self.LUA_SIGNATURE .. string.char(self.LUAC_VERSION, self.LUAC_FORMAT, x, 4, size_size_t, 4, 8, 0)
	end
	function luaU:dump(L, f, w, data, strip)
		local D = {}
		D.L = L
		D.write = w
		D.data = data
		D.strip = strip
		D.status = 0
		self:DumpHeader(D)
		self:DumpFunction(f, nil, D)
		D.write(nil, D.data)
		return D.status
	end
	luaK.MAXSTACK = 250
	function luaK:ttisnumber(o)
		if o then
			return type(o.value) == "number"
		else
			return false
		end
	end
	function luaK:nvalue(o)
		return o.value
	end
	function luaK:setnilvalue(o)
		o.value = nil
	end
	function luaK:setsvalue(o, x)
		o.value = x
	end
	luaK.setnvalue = luaK.setsvalue
	luaK.sethvalue = luaK.setsvalue
	luaK.setbvalue = luaK.setsvalue
	function luaK:numadd(a, b)
		return a + b
	end
	function luaK:numsub(a, b)
		return a - b
	end
	function luaK:nummul(a, b)
		return a * b
	end
	function luaK:numdiv(a, b)
		return a / b
	end
	function luaK:nummod(a, b)
		return a % b
	end
	function luaK:numpow(a, b)
		return a ^ b
	end
	function luaK:numunm(a)
		return -a
	end
	function luaK:numisnan(a)
		return a ~= a
	end
	luaK.NO_JUMP = -1
	luaK.BinOpr = {
		OPR_ADD = 0,
		OPR_SUB = 1,
		OPR_MUL = 2,
		OPR_DIV = 3,
		OPR_MOD = 4,
		OPR_POW = 5,
		OPR_CONCAT = 6,
		OPR_NE = 7,
		OPR_EQ = 8,
		OPR_LT = 9,
		OPR_LE = 10,
		OPR_GT = 11,
		OPR_GE = 12,
		OPR_AND = 13,
		OPR_OR = 14,
		OPR_NOBINOPR = 15,
	}
	luaK.UnOpr = {
		OPR_MINUS = 0,
		OPR_NOT = 1,
		OPR_LEN = 2,
		OPR_NOUNOPR = 3,
	}
	function luaK:getcode(fs, e)
		return fs.f.code[e.info]
	end
	function luaK:codeAsBx(fs, o, A, sBx)
		return self:codeABx(fs, o, A, sBx + luaP.MAXARG_sBx)
	end
	function luaK:setmultret(fs, e)
		self:setreturns(fs, e, luaY.LUA_MULTRET)
	end
	function luaK:hasjumps(e)
		return e.t ~= e.f
	end
	function luaK:isnumeral(e)
		return e.k == "VKNUM" and e.t == self.NO_JUMP and e.f == self.NO_JUMP
	end
	function luaK:_nil(fs, from, n)
		if fs.pc > fs.lasttarget then
			if fs.pc == 0 then
				if from >= fs.nactvar then
					return
				end
			else
				local previous = fs.f.code[fs.pc - 1]
				if luaP:GET_OPCODE(previous) == "OP_LOADNIL" then
					local pfrom = luaP:GETARG_A(previous)
					local pto = luaP:GETARG_B(previous)
					if pfrom <= from and from <= pto + 1 then
						if from + n - 1 > pto then
							luaP:SETARG_B(previous, from + n - 1)
						end
						return
					end
				end
			end
		end
		self:codeABC(fs, "OP_LOADNIL", from, from + n - 1, 0)
	end
	function luaK:jump(fs)
		local jpc = fs.jpc
		fs.jpc = self.NO_JUMP
		local j = self:codeAsBx(fs, "OP_JMP", 0, self.NO_JUMP)
		j = self:concat(fs, j, jpc)
		return j
	end
	function luaK:ret(fs, first, nret)
		self:codeABC(fs, "OP_RETURN", first, nret + 1, 0)
	end
	function luaK:condjump(fs, op, A, B, C)
		self:codeABC(fs, op, A, B, C)
		return self:jump(fs)
	end
	function luaK:fixjump(fs, pc, dest)
		local jmp = fs.f.code[pc]
		local offset = dest - (pc + 1)
		lua_assert(dest ~= self.NO_JUMP)
		if math.abs(offset) > luaP.MAXARG_sBx then
			luaX:syntaxerror(fs.ls, "control structure too long")
		end
		luaP:SETARG_sBx(jmp, offset)
	end
	function luaK:getlabel(fs)
		fs.lasttarget = fs.pc
		return fs.pc
	end
	function luaK:getjump(fs, pc)
		local offset = luaP:GETARG_sBx(fs.f.code[pc])
		if offset == self.NO_JUMP then
			return self.NO_JUMP
		else
			return (pc + 1) + offset
		end
	end
	function luaK:getjumpcontrol(fs, pc)
		local pi = fs.f.code[pc]
		local ppi = fs.f.code[pc - 1]
		if pc >= 1 and luaP:testTMode(luaP:GET_OPCODE(ppi)) ~= 0 then
			return ppi
		else
			return pi
		end
	end
	function luaK:need_value(fs, list)
		while list ~= self.NO_JUMP do
			local i = self:getjumpcontrol(fs, list)
			if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
				return true
			end
			list = self:getjump(fs, list)
		end
		return false
	end
	function luaK:patchtestreg(fs, node, reg)
		local i = self:getjumpcontrol(fs, node)
		if luaP:GET_OPCODE(i) ~= "OP_TESTSET" then
			return false
		end
		if reg ~= luaP.NO_REG and reg ~= luaP:GETARG_B(i) then
			luaP:SETARG_A(i, reg)
		else
			luaP:SET_OPCODE(i, "OP_TEST")
			local b = luaP:GETARG_B(i)
			luaP:SETARG_A(i, b)
			luaP:SETARG_B(i, 0)
		end
		return true
	end
	function luaK:removevalues(fs, list)
		while list ~= self.NO_JUMP do
			self:patchtestreg(fs, list, luaP.NO_REG)
			list = self:getjump(fs, list)
		end
	end
	function luaK:patchlistaux(fs, list, vtarget, reg, dtarget)
		while list ~= self.NO_JUMP do
			local _next = self:getjump(fs, list)
			if self:patchtestreg(fs, list, reg) then
				self:fixjump(fs, list, vtarget)
			else
				self:fixjump(fs, list, dtarget)
			end
			list = _next
		end
	end
	function luaK:dischargejpc(fs)
		self:patchlistaux(fs, fs.jpc, fs.pc, luaP.NO_REG, fs.pc)
		fs.jpc = self.NO_JUMP
	end
	function luaK:patchlist(fs, list, target)
		if target == fs.pc then
			self:patchtohere(fs, list)
		else
			lua_assert(target < fs.pc)
			self:patchlistaux(fs, list, target, luaP.NO_REG, target)
		end
	end
	function luaK:patchtohere(fs, list)
		self:getlabel(fs)
		fs.jpc = self:concat(fs, fs.jpc, list)
	end
	function luaK:concat(fs, l1, l2)
		if l2 == self.NO_JUMP then
			return l1
		elseif l1 == self.NO_JUMP then
			return l2
		else
			local list = l1
			local _next = self:getjump(fs, list)
			while _next ~= self.NO_JUMP do
				list = _next
				_next = self:getjump(fs, list)
			end
			self:fixjump(fs, list, l2)
		end
		return l1
	end
	function luaK:checkstack(fs, n)
		local newstack = fs.freereg + n
		if newstack > fs.f.maxstacksize then
			if newstack >= self.MAXSTACK then
				luaX:syntaxerror(fs.ls, "function or expression too complex")
			end
			fs.f.maxstacksize = newstack
		end
	end
	function luaK:reserveregs(fs, n)
		self:checkstack(fs, n)
		fs.freereg = fs.freereg + n
	end
	function luaK:freereg(fs, reg)
		if not luaP:ISK(reg) and reg >= fs.nactvar then
			fs.freereg = fs.freereg - 1
			lua_assert(reg == fs.freereg)
		end
	end
	function luaK:freeexp(fs, e)
		if e.k == "VNONRELOC" then
			self:freereg(fs, e.info)
		end
	end
	function luaK:addk(fs, k, v)
		local L = fs.L
		local idx = fs.h[k.value]
		local f = fs.f
		if self:ttisnumber(idx) then
			return self:nvalue(idx)
		else
			idx = {}
			self:setnvalue(idx, fs.nk)
			fs.h[k.value] = idx
			luaY:growvector(L, f.k, fs.nk, f.sizek, nil, luaP.MAXARG_Bx, "constant table overflow")
			f.k[fs.nk] = v
			local nk = fs.nk
			fs.nk = fs.nk + 1
			return nk
		end
	end
	function luaK:stringK(fs, s)
		local o = {}
		self:setsvalue(o, s)
		return self:addk(fs, o, o)
	end
	function luaK:numberK(fs, r)
		local o = {}
		self:setnvalue(o, r)
		return self:addk(fs, o, o)
	end
	function luaK:boolK(fs, b)
		local o = {}
		self:setbvalue(o, b)
		return self:addk(fs, o, o)
	end
	function luaK:nilK(fs)
		local k, v = {}, {}
		self:setnilvalue(v)
		self:sethvalue(k, fs.h)
		return self:addk(fs, k, v)
	end
	function luaK:setreturns(fs, e, nresults)
		if e.k == "VCALL" then
			luaP:SETARG_C(self:getcode(fs, e), nresults + 1)
		elseif e.k == "VVARARG" then
			luaP:SETARG_B(self:getcode(fs, e), nresults + 1)
			luaP:SETARG_A(self:getcode(fs, e), fs.freereg)
			luaK:reserveregs(fs, 1)
		end
	end
	function luaK:setoneret(fs, e)
		if e.k == "VCALL" then
			e.k = "VNONRELOC"
			e.info = luaP:GETARG_A(self:getcode(fs, e))
		elseif e.k == "VVARARG" then
			luaP:SETARG_B(self:getcode(fs, e), 2)
			e.k = "VRELOCABLE"
		end
	end
	function luaK:dischargevars(fs, e)
		local k = e.k
		if k == "VLOCAL" then
			e.k = "VNONRELOC"
		elseif k == "VUPVAL" then
			e.info = self:codeABC(fs, "OP_GETUPVAL", 0, e.info, 0)
			e.k = "VRELOCABLE"
		elseif k == "VGLOBAL" then
			e.info = self:codeABx(fs, "OP_GETGLOBAL", 0, e.info)
			e.k = "VRELOCABLE"
		elseif k == "VINDEXED" then
			self:freereg(fs, e.aux)
			self:freereg(fs, e.info)
			e.info = self:codeABC(fs, "OP_GETTABLE", 0, e.info, e.aux)
			e.k = "VRELOCABLE"
		elseif k == "VVARARG" or k == "VCALL" then
			self:setoneret(fs, e)
		else
		end
	end
	function luaK:code_label(fs, A, b, jump)
		self:getlabel(fs)
		return self:codeABC(fs, "OP_LOADBOOL", A, b, jump)
	end
	function luaK:discharge2reg(fs, e, reg)
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" then
			self:_nil(fs, reg, 1)
		elseif k == "VFALSE" or k == "VTRUE" then
			self:codeABC(fs, "OP_LOADBOOL", reg, (e.k == "VTRUE") and 1 or 0, 0)
		elseif k == "VK" then
			self:codeABx(fs, "OP_LOADK", reg, e.info)
		elseif k == "VKNUM" then
			self:codeABx(fs, "OP_LOADK", reg, self:numberK(fs, e.nval))
		elseif k == "VRELOCABLE" then
			local pc = self:getcode(fs, e)
			luaP:SETARG_A(pc, reg)
		elseif k == "VNONRELOC" then
			if reg ~= e.info then
				self:codeABC(fs, "OP_MOVE", reg, e.info, 0)
			end
		else
			lua_assert(e.k == "VVOID" or e.k == "VJMP")
			return
		end
		e.info = reg
		e.k = "VNONRELOC"
	end
	function luaK:discharge2anyreg(fs, e)
		if e.k ~= "VNONRELOC" then
			self:reserveregs(fs, 1)
			self:discharge2reg(fs, e, fs.freereg - 1)
		end
	end
	function luaK:exp2reg(fs, e, reg)
		self:discharge2reg(fs, e, reg)
		if e.k == "VJMP" then
			e.t = self:concat(fs, e.t, e.info)
		end
		if self:hasjumps(e) then
			local final
			local p_f = self.NO_JUMP
			local p_t = self.NO_JUMP
			if self:need_value(fs, e.t) or self:need_value(fs, e.f) then
				local fj = (e.k == "VJMP") and self.NO_JUMP or self:jump(fs)
				p_f = self:code_label(fs, reg, 0, 1)
				p_t = self:code_label(fs, reg, 1, 0)
				self:patchtohere(fs, fj)
			end
			final = self:getlabel(fs)
			self:patchlistaux(fs, e.f, final, reg, p_f)
			self:patchlistaux(fs, e.t, final, reg, p_t)
		end
		e.f, e.t = self.NO_JUMP, self.NO_JUMP
		e.info = reg
		e.k = "VNONRELOC"
	end
	function luaK:exp2nextreg(fs, e)
		self:dischargevars(fs, e)
		self:freeexp(fs, e)
		self:reserveregs(fs, 1)
		self:exp2reg(fs, e, fs.freereg - 1)
	end
	function luaK:exp2anyreg(fs, e)
		self:dischargevars(fs, e)
		if e.k == "VNONRELOC" then
			if not self:hasjumps(e) then
				return e.info
			end
			if e.info >= fs.nactvar then
				self:exp2reg(fs, e, e.info)
				return e.info
			end
		end
		self:exp2nextreg(fs, e)
		return e.info
	end
	function luaK:exp2val(fs, e)
		if self:hasjumps(e) then
			self:exp2anyreg(fs, e)
		else
			self:dischargevars(fs, e)
		end
	end
	function luaK:exp2RK(fs, e)
		self:exp2val(fs, e)
		local k = e.k
		if k == "VKNUM" or k == "VTRUE" or k == "VFALSE" or k == "VNIL" then
			if fs.nk <= luaP.MAXINDEXRK then
				if e.k == "VNIL" then
					e.info = self:nilK(fs)
				else
					e.info = (e.k == "VKNUM") and self:numberK(fs, e.nval) or self:boolK(fs, e.k == "VTRUE")
				end
				e.k = "VK"
				return luaP:RKASK(e.info)
			end
		elseif k == "VK" then
			if e.info <= luaP.MAXINDEXRK then
				return luaP:RKASK(e.info)
			end
		else
		end
		return self:exp2anyreg(fs, e)
	end
	function luaK:storevar(fs, var, ex)
		local k = var.k
		if k == "VLOCAL" then
			self:freeexp(fs, ex)
			self:exp2reg(fs, ex, var.info)
			return
		elseif k == "VUPVAL" then
			local e = self:exp2anyreg(fs, ex)
			self:codeABC(fs, "OP_SETUPVAL", e, var.info, 0)
		elseif k == "VGLOBAL" then
			local e = self:exp2anyreg(fs, ex)
			self:codeABx(fs, "OP_SETGLOBAL", e, var.info)
		elseif k == "VINDEXED" then
			local e = self:exp2RK(fs, ex)
			self:codeABC(fs, "OP_SETTABLE", var.info, var.aux, e)
		else
			lua_assert(0)
		end
		self:freeexp(fs, ex)
	end
	function luaK:_self(fs, e, key)
		self:exp2anyreg(fs, e)
		self:freeexp(fs, e)
		local func = fs.freereg
		self:reserveregs(fs, 2)
		self:codeABC(fs, "OP_SELF", func, e.info, self:exp2RK(fs, key))
		self:freeexp(fs, key)
		e.info = func
		e.k = "VNONRELOC"
	end
	function luaK:invertjump(fs, e)
		local pc = self:getjumpcontrol(fs, e.info)
		lua_assert(
			luaP:testTMode(luaP:GET_OPCODE(pc)) ~= 0
				and luaP:GET_OPCODE(pc) ~= "OP_TESTSET"
				and luaP:GET_OPCODE(pc) ~= "OP_TEST"
		)
		luaP:SETARG_A(pc, (luaP:GETARG_A(pc) == 0) and 1 or 0)
	end
	function luaK:jumponcond(fs, e, cond)
		if e.k == "VRELOCABLE" then
			local ie = self:getcode(fs, e)
			if luaP:GET_OPCODE(ie) == "OP_NOT" then
				fs.pc = fs.pc - 1
				return self:condjump(fs, "OP_TEST", luaP:GETARG_B(ie), 0, cond and 0 or 1)
			end
		end
		self:discharge2anyreg(fs, e)
		self:freeexp(fs, e)
		return self:condjump(fs, "OP_TESTSET", luaP.NO_REG, e.info, cond and 1 or 0)
	end
	function luaK:goiftrue(fs, e)
		local pc
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VK" or k == "VKNUM" or k == "VTRUE" then
			pc = self.NO_JUMP
		elseif k == "VFALSE" then
			pc = self:jump(fs)
		elseif k == "VJMP" then
			self:invertjump(fs, e)
			pc = e.info
		else
			pc = self:jumponcond(fs, e, false)
		end
		e.f = self:concat(fs, e.f, pc)
		self:patchtohere(fs, e.t)
		e.t = self.NO_JUMP
	end
	function luaK:goiffalse(fs, e)
		local pc
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" or k == "VFALSE" then
			pc = self.NO_JUMP
		elseif k == "VTRUE" then
			pc = self:jump(fs)
		elseif k == "VJMP" then
			pc = e.info
		else
			pc = self:jumponcond(fs, e, true)
		end
		e.t = self:concat(fs, e.t, pc)
		self:patchtohere(fs, e.f)
		e.f = self.NO_JUMP
	end
	function luaK:codenot(fs, e)
		self:dischargevars(fs, e)
		local k = e.k
		if k == "VNIL" or k == "VFALSE" then
			e.k = "VTRUE"
		elseif k == "VK" or k == "VKNUM" or k == "VTRUE" then
			e.k = "VFALSE"
		elseif k == "VJMP" then
			self:invertjump(fs, e)
		elseif k == "VRELOCABLE" or k == "VNONRELOC" then
			self:discharge2anyreg(fs, e)
			self:freeexp(fs, e)
			e.info = self:codeABC(fs, "OP_NOT", 0, e.info, 0)
			e.k = "VRELOCABLE"
		else
			lua_assert(0)
		end
		e.f, e.t = e.t, e.f
		self:removevalues(fs, e.f)
		self:removevalues(fs, e.t)
	end
	function luaK:indexed(fs, t, k)
		t.aux = self:exp2RK(fs, k)
		t.k = "VINDEXED"
	end
	function luaK:constfolding(op, e1, e2)
		local r
		if not self:isnumeral(e1) or not self:isnumeral(e2) then
			return false
		end
		local v1 = e1.nval
		local v2 = e2.nval
		if op == "OP_ADD" then
			r = self:numadd(v1, v2)
		elseif op == "OP_SUB" then
			r = self:numsub(v1, v2)
		elseif op == "OP_MUL" then
			r = self:nummul(v1, v2)
		elseif op == "OP_DIV" then
			if v2 == 0 then
				return false
			end
			r = self:numdiv(v1, v2)
		elseif op == "OP_MOD" then
			if v2 == 0 then
				return false
			end
			r = self:nummod(v1, v2)
		elseif op == "OP_POW" then
			r = self:numpow(v1, v2)
		elseif op == "OP_UNM" then
			r = self:numunm(v1)
		elseif op == "OP_LEN" then
			return false
		else
			lua_assert(0)
			r = 0
		end
		if self:numisnan(r) then
			return false
		end
		e1.nval = r
		return true
	end
	function luaK:codearith(fs, op, e1, e2)
		if self:constfolding(op, e1, e2) then
			return
		else
			local o2 = (op ~= "OP_UNM" and op ~= "OP_LEN") and self:exp2RK(fs, e2) or 0
			local o1 = self:exp2RK(fs, e1)
			if o1 > o2 then
				self:freeexp(fs, e1)
				self:freeexp(fs, e2)
			else
				self:freeexp(fs, e2)
				self:freeexp(fs, e1)
			end
			e1.info = self:codeABC(fs, op, 0, o1, o2)
			e1.k = "VRELOCABLE"
		end
	end
	function luaK:codecomp(fs, op, cond, e1, e2)
		local o1 = self:exp2RK(fs, e1)
		local o2 = self:exp2RK(fs, e2)
		self:freeexp(fs, e2)
		self:freeexp(fs, e1)
		if cond == 0 and op ~= "OP_EQ" then
			o1, o2 = o2, o1
			cond = 1
		end
		e1.info = self:condjump(fs, op, cond, o1, o2)
		e1.k = "VJMP"
	end
	function luaK:prefix(fs, op, e)
		local e2 = {}
		e2.t, e2.f = self.NO_JUMP, self.NO_JUMP
		e2.k = "VKNUM"
		e2.nval = 0
		if op == "OPR_MINUS" then
			if not self:isnumeral(e) then
				self:exp2anyreg(fs, e)
			end
			self:codearith(fs, "OP_UNM", e, e2)
		elseif op == "OPR_NOT" then
			self:codenot(fs, e)
		elseif op == "OPR_LEN" then
			self:exp2anyreg(fs, e)
			self:codearith(fs, "OP_LEN", e, e2)
		else
			lua_assert(0)
		end
	end
	function luaK:infix(fs, op, v)
		if op == "OPR_AND" then
			self:goiftrue(fs, v)
		elseif op == "OPR_OR" then
			self:goiffalse(fs, v)
		elseif op == "OPR_CONCAT" then
			self:exp2nextreg(fs, v)
		elseif
			op == "OPR_ADD"
			or op == "OPR_SUB"
			or op == "OPR_MUL"
			or op == "OPR_DIV"
			or op == "OPR_MOD"
			or op == "OPR_POW"
		then
			if not self:isnumeral(v) then
				self:exp2RK(fs, v)
			end
		else
			self:exp2RK(fs, v)
		end
	end
	luaK.arith_op = {
		OPR_ADD = "OP_ADD",
		OPR_SUB = "OP_SUB",
		OPR_MUL = "OP_MUL",
		OPR_DIV = "OP_DIV",
		OPR_MOD = "OP_MOD",
		OPR_POW = "OP_POW",
	}
	luaK.comp_op = {
		OPR_EQ = "OP_EQ",
		OPR_NE = "OP_EQ",
		OPR_LT = "OP_LT",
		OPR_LE = "OP_LE",
		OPR_GT = "OP_LT",
		OPR_GE = "OP_LE",
	}
	luaK.comp_cond = {
		OPR_EQ = 1,
		OPR_NE = 0,
		OPR_LT = 1,
		OPR_LE = 1,
		OPR_GT = 0,
		OPR_GE = 0,
	}
	function luaK:posfix(fs, op, e1, e2)
		local function copyexp(e1, e2)
			e1.k = e2.k
			e1.info = e2.info
			e1.aux = e2.aux
			e1.nval = e2.nval
			e1.t = e2.t
			e1.f = e2.f
		end
		if op == "OPR_AND" then
			lua_assert(e1.t == self.NO_JUMP)
			self:dischargevars(fs, e2)
			e2.f = self:concat(fs, e2.f, e1.f)
			copyexp(e1, e2)
		elseif op == "OPR_OR" then
			lua_assert(e1.f == self.NO_JUMP)
			self:dischargevars(fs, e2)
			e2.t = self:concat(fs, e2.t, e1.t)
			copyexp(e1, e2)
		elseif op == "OPR_CONCAT" then
			self:exp2val(fs, e2)
			if e2.k == "VRELOCABLE" and luaP:GET_OPCODE(self:getcode(fs, e2)) == "OP_CONCAT" then
				lua_assert(e1.info == luaP:GETARG_B(self:getcode(fs, e2)) - 1)
				self:freeexp(fs, e1)
				luaP:SETARG_B(self:getcode(fs, e2), e1.info)
				e1.k = "VRELOCABLE"
				e1.info = e2.info
			else
				self:exp2nextreg(fs, e2)
				self:codearith(fs, "OP_CONCAT", e1, e2)
			end
		else
			local arith = self.arith_op[op]
			if arith then
				self:codearith(fs, arith, e1, e2)
			else
				local comp = self.comp_op[op]
				if comp then
					self:codecomp(fs, comp, self.comp_cond[op], e1, e2)
				else
					lua_assert(0)
				end
			end
		end
	end
	function luaK:fixline(fs, line)
		fs.f.lineinfo[fs.pc - 1] = line
	end
	function luaK:code(fs, i, line)
		local f = fs.f
		self:dischargejpc(fs)
		luaY:growvector(fs.L, f.code, fs.pc, f.sizecode, nil, luaY.MAX_INT, "code size overflow")
		f.code[fs.pc] = i
		luaY:growvector(fs.L, f.lineinfo, fs.pc, f.sizelineinfo, nil, luaY.MAX_INT, "code size overflow")
		f.lineinfo[fs.pc] = line
		local pc = fs.pc
		fs.pc = fs.pc + 1
		return pc
	end
	function luaK:codeABC(fs, o, a, b, c)
		lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABC)
		lua_assert(luaP:getBMode(o) ~= luaP.OpArgMask.OpArgN or b == 0)
		lua_assert(luaP:getCMode(o) ~= luaP.OpArgMask.OpArgN or c == 0)
		return self:code(fs, luaP:CREATE_ABC(o, a, b, c), fs.ls.lastline)
	end
	function luaK:codeABx(fs, o, a, bc)
		lua_assert(luaP:getOpMode(o) == luaP.OpMode.iABx or luaP:getOpMode(o) == luaP.OpMode.iAsBx)
		lua_assert(luaP:getCMode(o) == luaP.OpArgMask.OpArgN)
		return self:code(fs, luaP:CREATE_ABx(o, a, bc), fs.ls.lastline)
	end
	function luaK:setlist(fs, base, nelems, tostore)
		local c = math.floor((nelems - 1) / luaP.LFIELDS_PER_FLUSH) + 1
		local b = (tostore == luaY.LUA_MULTRET) and 0 or tostore
		lua_assert(tostore ~= 0)
		if c <= luaP.MAXARG_C then
			self:codeABC(fs, "OP_SETLIST", base, b, c)
		else
			self:codeABC(fs, "OP_SETLIST", base, b, 0)
			self:code(fs, luaP:CREATE_Inst(c), fs.ls.lastline)
		end
		fs.freereg = base + 1
	end
	luaY.LUA_QS = luaX.LUA_QS or "'%s'"
	luaY.SHRT_MAX = 32767
	luaY.LUAI_MAXVARS = 200
	luaY.LUAI_MAXUPVALUES = 60
	luaY.MAX_INT = luaX.MAX_INT or 2147483645
	luaY.LUAI_MAXCCALLS = 200
	luaY.VARARG_HASARG = 1
	luaY.HASARG_MASK = 2
	luaY.VARARG_ISVARARG = 2
	luaY.VARARG_NEEDSARG = 4
	luaY.LUA_MULTRET = -1
	function luaY:LUA_QL(x)
		return "'" .. x .. "'"
	end
	function luaY:growvector(_, _, nelems, _, _, limit, e)
		if nelems >= limit then
			error(e)
		end
	end
	function luaY:newproto()
		local f = {}
		f.k = {}
		f.sizek = 0
		f.p = {}
		f.sizep = 0
		f.code = {}
		f.sizecode = 0
		f.sizelineinfo = 0
		f.sizeupvalues = 0
		f.nups = 0
		f.upvalues = {}
		f.numparams = 0
		f.is_vararg = 0
		f.maxstacksize = 0
		f.lineinfo = {}
		f.sizelocvars = 0
		f.locvars = {}
		f.lineDefined = 0
		f.lastlinedefined = 0
		f.source = nil
		return f
	end
	function luaY:int2fb(x)
		local e = 0
		while x >= 16 do
			x = math.floor((x + 1) / 2)
			e = e + 1
		end
		if x < 8 then
			return x
		else
			return ((e + 1) * 8) + (x - 8)
		end
	end
	function luaY:hasmultret(k)
		return k == "VCALL" or k == "VVARARG"
	end
	function luaY:getlocvar(fs, i)
		return fs.f.locvars[fs.actvar[i]]
	end
	function luaY:checklimit(fs, v, l, m)
		if v > l then
			self:errorlimit(fs, l, m)
		end
	end
	function luaY:error_expected(ls, token)
		luaX:syntaxerror(ls, string.format(self.LUA_QS .. " expected", luaX:token2str(ls, token)))
	end
	function luaY:errorlimit(fs, limit, what)
		local msg = (fs.f.linedefined == 0) and string.format("main function has more than %d %s", limit, what)
			or string.format("function at line %d has more than %d %s", fs.f.linedefined, limit, what)
		luaX:lexerror(fs.ls, msg, 0)
	end
	function luaY:testnext(ls, c)
		if ls.t.token == c then
			luaX:next(ls)
			return true
		else
			return false
		end
	end
	function luaY:check(ls, c)
		if ls.t.token ~= c then
			self:error_expected(ls, c)
		end
	end
	function luaY:checknext(ls, c)
		self:check(ls, c)
		luaX:next(ls)
	end
	function luaY:check_condition(ls, c, msg)
		if not c then
			luaX:syntaxerror(ls, msg)
		end
	end
	function luaY:check_match(ls, what, who, where)
		if not self:testnext(ls, what) then
			if where == ls.linenumber then
				self:error_expected(ls, what)
			else
				luaX:syntaxerror(
					ls,
					string.format(
						self.LUA_QS .. " expected (to close " .. self.LUA_QS .. " at line %d)",
						luaX:token2str(ls, what),
						luaX:token2str(ls, who),
						where
					)
				)
			end
		end
	end
	function luaY:str_checkname(ls)
		self:check(ls, "TK_NAME")
		local ts = ls.t.seminfo
		luaX:next(ls)
		return ts
	end
	function luaY:init_exp(e, k, i)
		e.f, e.t = luaK.NO_JUMP, luaK.NO_JUMP
		e.k = k
		e.info = i
	end
	function luaY:codestring(ls, e, s)
		self:init_exp(e, "VK", luaK:stringK(ls.fs, s))
	end
	function luaY:checkname(ls, e)
		self:codestring(ls, e, self:str_checkname(ls))
	end
	function luaY:registerlocalvar(ls, varname)
		local fs = ls.fs
		local f = fs.f
		self:growvector(ls.L, f.locvars, fs.nlocvars, f.sizelocvars, nil, self.SHRT_MAX, "too many local variables")
		f.locvars[fs.nlocvars] = {}
		f.locvars[fs.nlocvars].varname = varname
		local nlocvars = fs.nlocvars
		fs.nlocvars = fs.nlocvars + 1
		return nlocvars
	end
	function luaY:new_localvarliteral(ls, v, n)
		self:new_localvar(ls, v, n)
	end
	function luaY:new_localvar(ls, name, n)
		local fs = ls.fs
		self:checklimit(fs, fs.nactvar + n + 1, self.LUAI_MAXVARS, "local variables")
		fs.actvar[fs.nactvar + n] = self:registerlocalvar(ls, name)
	end
	function luaY:adjustlocalvars(ls, nvars)
		local fs = ls.fs
		fs.nactvar = fs.nactvar + nvars
		for i = nvars, 1, -1 do
			self:getlocvar(fs, fs.nactvar - i).startpc = fs.pc
		end
	end
	function luaY:removevars(ls, tolevel)
		local fs = ls.fs
		while fs.nactvar > tolevel do
			fs.nactvar = fs.nactvar - 1
			self:getlocvar(fs, fs.nactvar).endpc = fs.pc
		end
	end
	function luaY:indexupvalue(fs, name, v)
		local f = fs.f
		for i = 0, f.nups - 1 do
			if fs.upvalues[i].k == v.k and fs.upvalues[i].info == v.info then
				lua_assert(f.upvalues[i] == name)
				return i
			end
		end
		self:checklimit(fs, f.nups + 1, self.LUAI_MAXUPVALUES, "upvalues")
		self:growvector(fs.L, f.upvalues, f.nups, f.sizeupvalues, nil, self.MAX_INT, "")
		f.upvalues[f.nups] = name
		lua_assert(v.k == "VLOCAL" or v.k == "VUPVAL")
		fs.upvalues[f.nups] = { k = v.k, info = v.info }
		local nups = f.nups
		f.nups = f.nups + 1
		return nups
	end
	function luaY:searchvar(fs, n)
		for i = fs.nactvar - 1, 0, -1 do
			if n == self:getlocvar(fs, i).varname then
				return i
			end
		end
		return -1
	end
	function luaY:markupval(fs, level)
		local bl = fs.bl
		while bl and bl.nactvar > level do
			bl = bl.previous
		end
		if bl then
			bl.upval = true
		end
	end
	function luaY:singlevaraux(fs, n, var, base)
		if fs == nil then
			self:init_exp(var, "VGLOBAL", luaP.NO_REG)
			return "VGLOBAL"
		else
			local v = self:searchvar(fs, n)
			if v >= 0 then
				self:init_exp(var, "VLOCAL", v)
				if base == 0 then
					self:markupval(fs, v)
				end
				return "VLOCAL"
			else
				if self:singlevaraux(fs.prev, n, var, 0) == "VGLOBAL" then
					return "VGLOBAL"
				end
				var.info = self:indexupvalue(fs, n, var)
				var.k = "VUPVAL"
				return "VUPVAL"
			end
		end
	end
	function luaY:singlevar(ls, var)
		local varname = self:str_checkname(ls)
		local fs = ls.fs
		if self:singlevaraux(fs, varname, var, 1) == "VGLOBAL" then
			var.info = luaK:stringK(fs, varname)
		end
	end
	function luaY:adjust_assign(ls, nvars, nexps, e)
		local fs = ls.fs
		local extra = nvars - nexps
		if self:hasmultret(e.k) then
			extra = extra + 1
			if extra <= 0 then
				extra = 0
			end
			luaK:setreturns(fs, e, extra)
			if extra > 1 then
				luaK:reserveregs(fs, extra - 1)
			end
		else
			if e.k ~= "VVOID" then
				luaK:exp2nextreg(fs, e)
			end
			if extra > 0 then
				local reg = fs.freereg
				luaK:reserveregs(fs, extra)
				luaK:_nil(fs, reg, extra)
			end
		end
	end
	function luaY:enterlevel(ls)
		ls.L.nCcalls = ls.L.nCcalls + 1
		if ls.L.nCcalls > self.LUAI_MAXCCALLS then
			luaX:lexerror(ls, "chunk has too many syntax levels", 0)
		end
	end
	function luaY:leavelevel(ls)
		ls.L.nCcalls = ls.L.nCcalls - 1
	end
	function luaY:enterblock(fs, bl, isbreakable)
		bl.breaklist = luaK.NO_JUMP
		bl.isbreakable = isbreakable
		bl.nactvar = fs.nactvar
		bl.upval = false
		bl.previous = fs.bl
		fs.bl = bl
		lua_assert(fs.freereg == fs.nactvar)
	end
	function luaY:leaveblock(fs)
		local bl = fs.bl
		fs.bl = bl.previous
		self:removevars(fs.ls, bl.nactvar)
		if bl.upval then
			luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
		end
		lua_assert(not bl.isbreakable or not bl.upval)
		lua_assert(bl.nactvar == fs.nactvar)
		fs.freereg = fs.nactvar
		luaK:patchtohere(fs, bl.breaklist)
	end
	function luaY:pushclosure(ls, func, v)
		local fs = ls.fs
		local f = fs.f
		self:growvector(ls.L, f.p, fs.np, f.sizep, nil, luaP.MAXARG_Bx, "constant table overflow")
		f.p[fs.np] = func.f
		fs.np = fs.np + 1
		self:init_exp(v, "VRELOCABLE", luaK:codeABx(fs, "OP_CLOSURE", 0, fs.np - 1))
		for i = 0, func.f.nups - 1 do
			local o = (func.upvalues[i].k == "VLOCAL") and "OP_MOVE" or "OP_GETUPVAL"
			luaK:codeABC(fs, o, 0, func.upvalues[i].info, 0)
		end
	end
	function luaY:open_func(ls, fs)
		local L = ls.L
		local f = self:newproto()
		fs.f = f
		fs.prev = ls.fs
		fs.ls = ls
		fs.L = L
		ls.fs = fs
		fs.pc = 0
		fs.lasttarget = -1
		fs.jpc = luaK.NO_JUMP
		fs.freereg = 0
		fs.nk = 0
		fs.np = 0
		fs.nlocvars = 0
		fs.nactvar = 0
		fs.bl = nil
		f.source = ls.source
		f.maxstacksize = 2
		fs.h = {}
	end
	function luaY:close_func(ls)
		local fs = ls.fs
		local f = fs.f
		self:removevars(ls, 0)
		luaK:ret(fs, 0, 0)
		f.sizecode = fs.pc
		f.sizelineinfo = fs.pc
		f.sizek = fs.nk
		f.sizep = fs.np
		f.sizelocvars = fs.nlocvars
		f.sizeupvalues = f.nups
		lua_assert(fs.bl == nil)
		ls.fs = fs.prev
	end
	function luaY:parser(L, z, buff, name)
		local lexstate = {}
		lexstate.t = {}
		lexstate.lookahead = {}
		local funcstate = {}
		funcstate.upvalues = {}
		funcstate.actvar = {}
		L.nCcalls = 0
		lexstate.buff = buff
		luaX:setinput(L, lexstate, z, name)
		self:open_func(lexstate, funcstate)
		funcstate.f.is_vararg = self.VARARG_ISVARARG
		luaX:next(lexstate)
		self:chunk(lexstate)
		self:check(lexstate, "TK_EOS")
		self:close_func(lexstate)
		lua_assert(funcstate.prev == nil)
		lua_assert(funcstate.f.nups == 0)
		lua_assert(lexstate.fs == nil)
		return funcstate.f
	end
	function luaY:field(ls, v)
		local fs = ls.fs
		local key = {}
		luaK:exp2anyreg(fs, v)
		luaX:next(ls)
		self:checkname(ls, key)
		luaK:indexed(fs, v, key)
	end
	function luaY:yindex(ls, v)
		luaX:next(ls)
		self:expr(ls, v)
		luaK:exp2val(ls.fs, v)
		self:checknext(ls, "]")
	end
	function luaY:recfield(ls, cc)
		local fs = ls.fs
		local reg = ls.fs.freereg
		local key, val = {}, {}
		if ls.t.token == "TK_NAME" then
			self:checklimit(fs, cc.nh, self.MAX_INT, "items in a constructor")
			self:checkname(ls, key)
		else
			self:yindex(ls, key)
		end
		cc.nh = cc.nh + 1
		self:checknext(ls, "=")
		local rkkey = luaK:exp2RK(fs, key)
		self:expr(ls, val)
		luaK:codeABC(fs, "OP_SETTABLE", cc.t.info, rkkey, luaK:exp2RK(fs, val))
		fs.freereg = reg
	end
	function luaY:closelistfield(fs, cc)
		if cc.v.k == "VVOID" then
			return
		end
		luaK:exp2nextreg(fs, cc.v)
		cc.v.k = "VVOID"
		if cc.tostore == luaP.LFIELDS_PER_FLUSH then
			luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
			cc.tostore = 0
		end
	end
	function luaY:lastlistfield(fs, cc)
		if cc.tostore == 0 then
			return
		end
		if self:hasmultret(cc.v.k) then
			luaK:setmultret(fs, cc.v)
			luaK:setlist(fs, cc.t.info, cc.na, self.LUA_MULTRET)
			cc.na = cc.na - 1
		else
			if cc.v.k ~= "VVOID" then
				luaK:exp2nextreg(fs, cc.v)
			end
			luaK:setlist(fs, cc.t.info, cc.na, cc.tostore)
		end
	end
	function luaY:listfield(ls, cc)
		self:expr(ls, cc.v)
		self:checklimit(ls.fs, cc.na, self.MAX_INT, "items in a constructor")
		cc.na = cc.na + 1
		cc.tostore = cc.tostore + 1
	end
	function luaY:constructor(ls, t)
		local fs = ls.fs
		local line = ls.linenumber
		local pc = luaK:codeABC(fs, "OP_NEWTABLE", 0, 0, 0)
		local cc = {}
		cc.v = {}
		cc.na, cc.nh, cc.tostore = 0, 0, 0
		cc.t = t
		self:init_exp(t, "VRELOCABLE", pc)
		self:init_exp(cc.v, "VVOID", 0)
		luaK:exp2nextreg(ls.fs, t)
		self:checknext(ls, "{")
		repeat
			lua_assert(cc.v.k == "VVOID" or cc.tostore > 0)
			if ls.t.token == "}" then
				break
			end
			self:closelistfield(fs, cc)
			local c = ls.t.token
			if c == "TK_NAME" then
				luaX:lookahead(ls)
				if ls.lookahead.token ~= "=" then
					self:listfield(ls, cc)
				else
					self:recfield(ls, cc)
				end
			elseif c == "[" then
				self:recfield(ls, cc)
			else
				self:listfield(ls, cc)
			end
		until not self:testnext(ls, ",") and not self:testnext(ls, ";")
		self:check_match(ls, "}", "{", line)
		self:lastlistfield(fs, cc)
		luaP:SETARG_B(fs.f.code[pc], self:int2fb(cc.na))
		luaP:SETARG_C(fs.f.code[pc], self:int2fb(cc.nh))
	end
	function luaY:parlist(ls)
		local fs = ls.fs
		local f = fs.f
		local nparams = 0
		f.is_vararg = 0
		if ls.t.token ~= ")" then
			repeat
				local c = ls.t.token
				if c == "TK_NAME" then
					self:new_localvar(ls, self:str_checkname(ls), nparams)
					nparams = nparams + 1
				elseif c == "TK_DOTS" then
					luaX:next(ls)
					self:new_localvarliteral(ls, "arg", nparams)
					nparams = nparams + 1
					f.is_vararg = self.VARARG_HASARG + self.VARARG_NEEDSARG
					f.is_vararg = f.is_vararg + self.VARARG_ISVARARG
				else
					luaX:syntaxerror(ls, "<name> or " .. self:LUA_QL("...") .. " expected")
				end
			until f.is_vararg ~= 0 or not self:testnext(ls, ",")
		end
		self:adjustlocalvars(ls, nparams)
		f.numparams = fs.nactvar - (f.is_vararg % self.HASARG_MASK)
		luaK:reserveregs(fs, fs.nactvar)
	end
	function luaY:body(ls, e, needself, line)
		local new_fs = {}
		new_fs.upvalues = {}
		new_fs.actvar = {}
		self:open_func(ls, new_fs)
		new_fs.f.lineDefined = line
		self:checknext(ls, "(")
		if needself then
			self:new_localvarliteral(ls, "self", 0)
			self:adjustlocalvars(ls, 1)
		end
		self:parlist(ls)
		self:checknext(ls, ")")
		self:chunk(ls)
		new_fs.f.lastlinedefined = ls.linenumber
		self:check_match(ls, "TK_END", "TK_FUNCTION", line)
		self:close_func(ls)
		self:pushclosure(ls, new_fs, e)
	end
	function luaY:explist1(ls, v)
		local n = 1
		self:expr(ls, v)
		while self:testnext(ls, ",") do
			luaK:exp2nextreg(ls.fs, v)
			self:expr(ls, v)
			n = n + 1
		end
		return n
	end
	function luaY:funcargs(ls, f)
		local fs = ls.fs
		local args = {}
		local nparams
		local line = ls.linenumber
		local c = ls.t.token
		if c == "(" then
			if line ~= ls.lastline then
				luaX:syntaxerror(ls, "ambiguous syntax (function call x new statement)")
			end
			luaX:next(ls)
			if ls.t.token == ")" then
				args.k = "VVOID"
			else
				self:explist1(ls, args)
				luaK:setmultret(fs, args)
			end
			self:check_match(ls, ")", "(", line)
		elseif c == "{" then
			self:constructor(ls, args)
		elseif c == "TK_STRING" then
			self:codestring(ls, args, ls.t.seminfo)
			luaX:next(ls)
		else
			luaX:syntaxerror(ls, "function arguments expected")
			return
		end
		lua_assert(f.k == "VNONRELOC")
		local base = f.info
		if self:hasmultret(args.k) then
			nparams = self.LUA_MULTRET
		else
			if args.k ~= "VVOID" then
				luaK:exp2nextreg(fs, args)
			end
			nparams = fs.freereg - (base + 1)
		end
		self:init_exp(f, "VCALL", luaK:codeABC(fs, "OP_CALL", base, nparams + 1, 2))
		luaK:fixline(fs, line)
		fs.freereg = base + 1
	end
	function luaY:prefixexp(ls, v)
		local c = ls.t.token
		if c == "(" then
			local line = ls.linenumber
			luaX:next(ls)
			self:expr(ls, v)
			self:check_match(ls, ")", "(", line)
			luaK:dischargevars(ls.fs, v)
		elseif c == "TK_NAME" then
			self:singlevar(ls, v)
		else
			luaX:syntaxerror(ls, "unexpected symbol")
		end
		return
	end
	function luaY:primaryexp(ls, v)
		local fs = ls.fs
		self:prefixexp(ls, v)
		while true do
			local c = ls.t.token
			if c == "." then
				self:field(ls, v)
			elseif c == "[" then
				local key = {}
				luaK:exp2anyreg(fs, v)
				self:yindex(ls, key)
				luaK:indexed(fs, v, key)
			elseif c == ":" then
				local key = {}
				luaX:next(ls)
				self:checkname(ls, key)
				luaK:_self(fs, v, key)
				self:funcargs(ls, v)
			elseif c == "(" or c == "TK_STRING" or c == "{" then
				luaK:exp2nextreg(fs, v)
				self:funcargs(ls, v)
			else
				return
			end
		end
	end
	function luaY:simpleexp(ls, v)
		local c = ls.t.token
		if c == "TK_NUMBER" then
			self:init_exp(v, "VKNUM", 0)
			v.nval = ls.t.seminfo
		elseif c == "TK_STRING" then
			self:codestring(ls, v, ls.t.seminfo)
		elseif c == "TK_NIL" then
			self:init_exp(v, "VNIL", 0)
		elseif c == "TK_TRUE" then
			self:init_exp(v, "VTRUE", 0)
		elseif c == "TK_FALSE" then
			self:init_exp(v, "VFALSE", 0)
		elseif c == "TK_DOTS" then
			local fs = ls.fs
			self:check_condition(
				ls,
				fs.f.is_vararg ~= 0,
				"cannot use " .. self:LUA_QL("...") .. " outside a vararg function"
			)
			local is_vararg = fs.f.is_vararg
			if is_vararg >= self.VARARG_NEEDSARG then
				fs.f.is_vararg = is_vararg - self.VARARG_NEEDSARG
			end
			self:init_exp(v, "VVARARG", luaK:codeABC(fs, "OP_VARARG", 0, 1, 0))
		elseif c == "{" then
			self:constructor(ls, v)
			return
		elseif c == "TK_FUNCTION" then
			luaX:next(ls)
			self:body(ls, v, false, ls.linenumber)
			return
		else
			self:primaryexp(ls, v)
			return
		end
		luaX:next(ls)
	end
	function luaY:getunopr(op)
		if op == "TK_NOT" then
			return "OPR_NOT"
		elseif op == "-" then
			return "OPR_MINUS"
		elseif op == "#" then
			return "OPR_LEN"
		else
			return "OPR_NOUNOPR"
		end
	end
	luaY.getbinopr_table = {
		["+"] = "OPR_ADD",
		["-"] = "OPR_SUB",
		["*"] = "OPR_MUL",
		["/"] = "OPR_DIV",
		["%"] = "OPR_MOD",
		["^"] = "OPR_POW",
		["TK_CONCAT"] = "OPR_CONCAT",
		["TK_NE"] = "OPR_NE",
		["TK_EQ"] = "OPR_EQ",
		["<"] = "OPR_LT",
		["TK_LE"] = "OPR_LE",
		[">"] = "OPR_GT",
		["TK_GE"] = "OPR_GE",
		["TK_AND"] = "OPR_AND",
		["TK_OR"] = "OPR_OR",
	}
	function luaY:getbinopr(op)
		local opr = self.getbinopr_table[op]
		if opr then
			return opr
		else
			return "OPR_NOBINOPR"
		end
	end
	luaY.priority = {
		{ 6, 6 },
		{ 6, 6 },
		{ 7, 7 },
		{ 7, 7 },
		{ 7, 7 },
		{ 10, 9 },
		{ 5, 4 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 3, 3 },
		{ 2, 2 },
		{ 1, 1 },
	}
	luaY.UNARY_PRIORITY = 8
	function luaY:subexpr(ls, v, limit)
		self:enterlevel(ls)
		local uop = self:getunopr(ls.t.token)
		if uop ~= "OPR_NOUNOPR" then
			luaX:next(ls)
			self:subexpr(ls, v, self.UNARY_PRIORITY)
			luaK:prefix(ls.fs, uop, v)
		else
			self:simpleexp(ls, v)
		end
		local op = self:getbinopr(ls.t.token)
		while op ~= "OPR_NOBINOPR" and self.priority[luaK.BinOpr[op] + 1][1] > limit do
			local v2 = {}
			luaX:next(ls)
			luaK:infix(ls.fs, op, v)
			local nextop = self:subexpr(ls, v2, self.priority[luaK.BinOpr[op] + 1][2])
			luaK:posfix(ls.fs, op, v, v2)
			op = nextop
		end
		self:leavelevel(ls)
		return op
	end
	function luaY:expr(ls, v)
		self:subexpr(ls, v, 0)
	end
	function luaY:block_follow(token)
		if
			token == "TK_ELSE"
			or token == "TK_ELSEIF"
			or token == "TK_END"
			or token == "TK_UNTIL"
			or token == "TK_EOS"
		then
			return true
		else
			return false
		end
	end
	function luaY:block(ls)
		local fs = ls.fs
		local bl = {}
		self:enterblock(fs, bl, false)
		self:chunk(ls)
		lua_assert(bl.breaklist == luaK.NO_JUMP)
		self:leaveblock(fs)
	end
	function luaY:check_conflict(ls, lh, v)
		local fs = ls.fs
		local extra = fs.freereg
		local conflict = false
		while lh do
			if lh.v.k == "VINDEXED" then
				if lh.v.info == v.info then
					conflict = true
					lh.v.info = extra
				end
				if lh.v.aux == v.info then
					conflict = true
					lh.v.aux = extra
				end
			end
			lh = lh.prev
		end
		if conflict then
			luaK:codeABC(fs, "OP_MOVE", fs.freereg, v.info, 0)
			luaK:reserveregs(fs, 1)
		end
	end
	function luaY:assignment(ls, lh, nvars)
		local e = {}
		local c = lh.v.k
		self:check_condition(ls, c == "VLOCAL" or c == "VUPVAL" or c == "VGLOBAL" or c == "VINDEXED", "syntax error")
		if self:testnext(ls, ",") then
			local nv = {}
			nv.v = {}
			nv.prev = lh
			self:primaryexp(ls, nv.v)
			if nv.v.k == "VLOCAL" then
				self:check_conflict(ls, lh, nv.v)
			end
			self:checklimit(ls.fs, nvars, self.LUAI_MAXCCALLS - ls.L.nCcalls, "variables in assignment")
			self:assignment(ls, nv, nvars + 1)
		else
			self:checknext(ls, "=")
			local nexps = self:explist1(ls, e)
			if nexps ~= nvars then
				self:adjust_assign(ls, nvars, nexps, e)
				if nexps > nvars then
					ls.fs.freereg = ls.fs.freereg - (nexps - nvars)
				end
			else
				luaK:setoneret(ls.fs, e)
				luaK:storevar(ls.fs, lh.v, e)
				return
			end
		end
		self:init_exp(e, "VNONRELOC", ls.fs.freereg - 1)
		luaK:storevar(ls.fs, lh.v, e)
	end
	function luaY:cond(ls)
		local v = {}
		self:expr(ls, v)
		if v.k == "VNIL" then
			v.k = "VFALSE"
		end
		luaK:goiftrue(ls.fs, v)
		return v.f
	end
	function luaY:breakstat(ls)
		local fs = ls.fs
		local bl = fs.bl
		local upval = false
		while bl and not bl.isbreakable do
			if bl.upval then
				upval = true
			end
			bl = bl.previous
		end
		if not bl then
			luaX:syntaxerror(ls, "no loop to break")
		end
		if upval then
			luaK:codeABC(fs, "OP_CLOSE", bl.nactvar, 0, 0)
		end
		bl.breaklist = luaK:concat(fs, bl.breaklist, luaK:jump(fs))
	end
	function luaY:whilestat(ls, line)
		local fs = ls.fs
		local bl = {}
		luaX:next(ls)
		local whileinit = luaK:getlabel(fs)
		local condexit = self:cond(ls)
		self:enterblock(fs, bl, true)
		self:checknext(ls, "TK_DO")
		self:block(ls)
		luaK:patchlist(fs, luaK:jump(fs), whileinit)
		self:check_match(ls, "TK_END", "TK_WHILE", line)
		self:leaveblock(fs)
		luaK:patchtohere(fs, condexit)
	end
	function luaY:repeatstat(ls, line)
		local fs = ls.fs
		local repeat_init = luaK:getlabel(fs)
		local bl1, bl2 = {}, {}
		self:enterblock(fs, bl1, true)
		self:enterblock(fs, bl2, false)
		luaX:next(ls)
		self:chunk(ls)
		self:check_match(ls, "TK_UNTIL", "TK_REPEAT", line)
		local condexit = self:cond(ls)
		if not bl2.upval then
			self:leaveblock(fs)
			luaK:patchlist(ls.fs, condexit, repeat_init)
		else
			self:breakstat(ls)
			luaK:patchtohere(ls.fs, condexit)
			self:leaveblock(fs)
			luaK:patchlist(ls.fs, luaK:jump(fs), repeat_init)
		end
		self:leaveblock(fs)
	end
	function luaY:exp1(ls)
		local e = {}
		self:expr(ls, e)
		local k = e.k
		luaK:exp2nextreg(ls.fs, e)
		return k
	end
	function luaY:forbody(ls, base, line, nvars, isnum)
		local bl = {}
		local fs = ls.fs
		self:adjustlocalvars(ls, 3)
		self:checknext(ls, "TK_DO")
		local prep = isnum and luaK:codeAsBx(fs, "OP_FORPREP", base, luaK.NO_JUMP) or luaK:jump(fs)
		self:enterblock(fs, bl, false)
		self:adjustlocalvars(ls, nvars)
		luaK:reserveregs(fs, nvars)
		self:block(ls)
		self:leaveblock(fs)
		luaK:patchtohere(fs, prep)
		local endfor = isnum and luaK:codeAsBx(fs, "OP_FORLOOP", base, luaK.NO_JUMP)
			or luaK:codeABC(fs, "OP_TFORLOOP", base, 0, nvars)
		luaK:fixline(fs, line)
		luaK:patchlist(fs, isnum and endfor or luaK:jump(fs), prep + 1)
	end
	function luaY:fornum(ls, varname, line)
		local fs = ls.fs
		local base = fs.freereg
		self:new_localvarliteral(ls, "(for index)", 0)
		self:new_localvarliteral(ls, "(for limit)", 1)
		self:new_localvarliteral(ls, "(for step)", 2)
		self:new_localvar(ls, varname, 3)
		self:checknext(ls, "=")
		self:exp1(ls)
		self:checknext(ls, ",")
		self:exp1(ls)
		if self:testnext(ls, ",") then
			self:exp1(ls)
		else
			luaK:codeABx(fs, "OP_LOADK", fs.freereg, luaK:numberK(fs, 1))
			luaK:reserveregs(fs, 1)
		end
		self:forbody(ls, base, line, 1, true)
	end
	function luaY:forlist(ls, indexname)
		local fs = ls.fs
		local e = {}
		local nvars = 0
		local base = fs.freereg
		self:new_localvarliteral(ls, "(for generator)", nvars)
		nvars = nvars + 1
		self:new_localvarliteral(ls, "(for state)", nvars)
		nvars = nvars + 1
		self:new_localvarliteral(ls, "(for control)", nvars)
		nvars = nvars + 1
		self:new_localvar(ls, indexname, nvars)
		nvars = nvars + 1
		while self:testnext(ls, ",") do
			self:new_localvar(ls, self:str_checkname(ls), nvars)
			nvars = nvars + 1
		end
		self:checknext(ls, "TK_IN")
		local line = ls.linenumber
		self:adjust_assign(ls, 3, self:explist1(ls, e), e)
		luaK:checkstack(fs, 3)
		self:forbody(ls, base, line, nvars - 3, false)
	end
	function luaY:forstat(ls, line)
		local fs = ls.fs
		local bl = {}
		self:enterblock(fs, bl, true)
		luaX:next(ls)
		local varname = self:str_checkname(ls)
		local c = ls.t.token
		if c == "=" then
			self:fornum(ls, varname, line)
		elseif c == "," or c == "TK_IN" then
			self:forlist(ls, varname)
		else
			luaX:syntaxerror(ls, self:LUA_QL("=") .. " or " .. self:LUA_QL("in") .. " expected")
		end
		self:check_match(ls, "TK_END", "TK_FOR", line)
		self:leaveblock(fs)
	end
	function luaY:test_then_block(ls)
		luaX:next(ls)
		local condexit = self:cond(ls)
		self:checknext(ls, "TK_THEN")
		self:block(ls)
		return condexit
	end
	function luaY:ifstat(ls, line)
		local fs = ls.fs
		local escapelist = luaK.NO_JUMP
		local flist = self:test_then_block(ls)
		while ls.t.token == "TK_ELSEIF" do
			escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
			luaK:patchtohere(fs, flist)
			flist = self:test_then_block(ls)
		end
		if ls.t.token == "TK_ELSE" then
			escapelist = luaK:concat(fs, escapelist, luaK:jump(fs))
			luaK:patchtohere(fs, flist)
			luaX:next(ls)
			self:block(ls)
		else
			escapelist = luaK:concat(fs, escapelist, flist)
		end
		luaK:patchtohere(fs, escapelist)
		self:check_match(ls, "TK_END", "TK_IF", line)
	end
	function luaY:localfunc(ls)
		local v, b = {}, {}
		local fs = ls.fs
		self:new_localvar(ls, self:str_checkname(ls), 0)
		self:init_exp(v, "VLOCAL", fs.freereg)
		luaK:reserveregs(fs, 1)
		self:adjustlocalvars(ls, 1)
		self:body(ls, b, false, ls.linenumber)
		luaK:storevar(fs, v, b)
		self:getlocvar(fs, fs.nactvar - 1).startpc = fs.pc
	end
	function luaY:localstat(ls)
		local nvars = 0
		local nexps
		local e = {}
		repeat
			self:new_localvar(ls, self:str_checkname(ls), nvars)
			nvars = nvars + 1
		until not self:testnext(ls, ",")
		if self:testnext(ls, "=") then
			nexps = self:explist1(ls, e)
		else
			e.k = "VVOID"
			nexps = 0
		end
		self:adjust_assign(ls, nvars, nexps, e)
		self:adjustlocalvars(ls, nvars)
	end
	function luaY:funcname(ls, v)
		local needself = false
		self:singlevar(ls, v)
		while ls.t.token == "." do
			self:field(ls, v)
		end
		if ls.t.token == ":" then
			needself = true
			self:field(ls, v)
		end
		return needself
	end
	function luaY:funcstat(ls, line)
		local v, b = {}, {}
		luaX:next(ls)
		local needself = self:funcname(ls, v)
		self:body(ls, b, needself, line)
		luaK:storevar(ls.fs, v, b)
		luaK:fixline(ls.fs, line)
	end
	function luaY:exprstat(ls)
		local fs = ls.fs
		local v = {}
		v.v = {}
		self:primaryexp(ls, v.v)
		if v.v.k == "VCALL" then
			luaP:SETARG_C(luaK:getcode(fs, v.v), 1)
		else
			v.prev = nil
			self:assignment(ls, v, 1)
		end
	end
	function luaY:retstat(ls)
		local fs = ls.fs
		local e = {}
		local first, nret
		luaX:next(ls)
		if self:block_follow(ls.t.token) or ls.t.token == ";" then
			first, nret = 0, 0
		else
			nret = self:explist1(ls, e)
			if self:hasmultret(e.k) then
				luaK:setmultret(fs, e)
				if e.k == "VCALL" and nret == 1 then
					luaP:SET_OPCODE(luaK:getcode(fs, e), "OP_TAILCALL")
					lua_assert(luaP:GETARG_A(luaK:getcode(fs, e)) == fs.nactvar)
				end
				first = fs.nactvar
				nret = self.LUA_MULTRET
			else
				if nret == 1 then
					first = luaK:exp2anyreg(fs, e)
				else
					luaK:exp2nextreg(fs, e)
					first = fs.nactvar
					lua_assert(nret == fs.freereg - first)
				end
			end
		end
		luaK:ret(fs, first, nret)
	end
	function luaY:statement(ls)
		local line = ls.linenumber
		local c = ls.t.token
		if c == "TK_IF" then
			self:ifstat(ls, line)
			return false
		elseif c == "TK_WHILE" then
			self:whilestat(ls, line)
			return false
		elseif c == "TK_DO" then
			luaX:next(ls)
			self:block(ls)
			self:check_match(ls, "TK_END", "TK_DO", line)
			return false
		elseif c == "TK_FOR" then
			self:forstat(ls, line)
			return false
		elseif c == "TK_REPEAT" then
			self:repeatstat(ls, line)
			return false
		elseif c == "TK_FUNCTION" then
			self:funcstat(ls, line)
			return false
		elseif c == "TK_LOCAL" then
			luaX:next(ls)
			if self:testnext(ls, "TK_FUNCTION") then
				self:localfunc(ls)
			else
				self:localstat(ls)
			end
			return false
		elseif c == "TK_RETURN" then
			self:retstat(ls)
			return true
		elseif c == "TK_BREAK" then
			luaX:next(ls)
			self:breakstat(ls)
			return true
		else
			self:exprstat(ls)
			return false
		end
	end
	function luaY:chunk(ls)
		local islast = false
		self:enterlevel(ls)
		while not islast and not self:block_follow(ls.t.token) do
			islast = self:statement(ls)
			self:testnext(ls, ";")
			lua_assert(ls.fs.f.maxstacksize >= ls.fs.freereg and ls.fs.freereg >= ls.fs.nactvar)
			ls.fs.freereg = ls.fs.nactvar
		end
		self:leavelevel(ls)
	end
	luaX:init()
	local LuaState = {}
	compile = function(source, name_)
		name = name_ or "compiled-lua"
		local zio = luaZ:init(luaZ:make_getF(source), nil)
		if not zio then
			return
		end
		local func = luaY:parser(LuaState, zio, nil, "@" .. name)
		local writer, buff = luaU:make_setS()
		luaU:dump(LuaState, func, writer, buff)
		return buff.data
	end
end
local createExecutable
do
	local lua_wrap_state
	local stm_lua_func
	local FIELDS_PER_FLUSH = 50
	local OPCODE_RM = {
		[22] = 18,
		[31] = 8,
		[33] = 28,
		[0] = 3,
		[1] = 13,
		[2] = 23,
		[26] = 33,
		[12] = 1,
		[13] = 6,
		[14] = 10,
		[15] = 16,
		[16] = 20,
		[17] = 26,
		[18] = 30,
		[19] = 36,
		[3] = 0,
		[4] = 2,
		[5] = 4,
		[6] = 7,
		[7] = 9,
		[8] = 12,
		[9] = 14,
		[10] = 17,
		[20] = 19,
		[21] = 22,
		[23] = 24,
		[24] = 27,
		[25] = 29,
		[27] = 32,
		[32] = 34,
		[34] = 37,
		[11] = 5,
		[28] = 11,
		[29] = 15,
		[30] = 21,
		[35] = 25,
		[36] = 31,
		[37] = 35,
	}
	local OPCODE_T = {
		[0] = "ABC",
		"ABx",
		"ABC",
		"ABC",
		"ABC",
		"ABx",
		"ABC",
		"ABx",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"AsBx",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"ABC",
		"AsBx",
		"AsBx",
		"ABC",
		"ABC",
		"ABC",
		"ABx",
		"ABC",
	}
	local OPCODE_M = {
		[0] = { b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgR" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgK", c = "OpArgK" },
		{ b = "OpArgR", c = "OpArgU" },
		{ b = "OpArgR", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgR", c = "OpArgN" },
		{ b = "OpArgN", c = "OpArgU" },
		{ b = "OpArgU", c = "OpArgU" },
		{ b = "OpArgN", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
		{ b = "OpArgU", c = "OpArgN" },
	}
	local function rd_int_basic(src, s, e, d)
		local num = 0
		for i = s, e, d do
			local mul = 256 ^ math.abs(i - s)
			num = num + mul * string.byte(src, i, i)
		end
		return num
	end
	local function rd_flt_basic(f1, f2, f3, f4)
		local sign = (-1) ^ bit32.rshift(f4, 7)
		local exp = bit32.rshift(f3, 7) + bit32.lshift(bit32.band(f4, 0x7F), 1)
		local frac = f1 + bit32.lshift(f2, 8) + bit32.lshift(bit32.band(f3, 0x7F), 16)
		local normal = 1
		if exp == 0 then
			if frac == 0 then
				return sign * 0
			else
				normal = 0
				exp = 1
			end
		elseif exp == 0x7F then
			if frac == 0 then
				return sign * (1 / 0)
			else
				return sign * (0 / 0)
			end
		end
		return sign * 2 ^ (exp - 127) * (1 + normal / 2 ^ 23)
	end
	local function rd_dbl_basic(f1, f2, f3, f4, f5, f6, f7, f8)
		local sign = (-1) ^ bit32.rshift(f8, 7)
		local exp = bit32.lshift(bit32.band(f8, 0x7F), 4) + bit32.rshift(f7, 4)
		local frac = bit32.band(f7, 0x0F) * 2 ^ 48
		local normal = 1
		frac = frac + (f6 * 2 ^ 40) + (f5 * 2 ^ 32) + (f4 * 2 ^ 24) + (f3 * 2 ^ 16) + (f2 * 2 ^ 8) + f1
		if exp == 0 then
			if frac == 0 then
				return sign * 0
			else
				normal = 0
				exp = 1
			end
		elseif exp == 0x7FF then
			if frac == 0 then
				return sign * (1 / 0)
			else
				return sign * (0 / 0)
			end
		end
		return sign * 2 ^ (exp - 1023) * (normal + frac / 2 ^ 52)
	end
	local function rd_int_le(src, s, e)
		return rd_int_basic(src, s, e - 1, 1)
	end
	local function rd_int_be(src, s, e)
		return rd_int_basic(src, e - 1, s, -1)
	end
	local function rd_flt_le(src, s)
		return rd_flt_basic(string.byte(src, s, s + 3))
	end
	local function rd_flt_be(src, s)
		local f1, f2, f3, f4 = string.byte(src, s, s + 3)
		return rd_flt_basic(f4, f3, f2, f1)
	end
	local function rd_dbl_le(src, s)
		return rd_dbl_basic(string.byte(src, s, s + 7))
	end
	local function rd_dbl_be(src, s)
		local f1, f2, f3, f4, f5, f6, f7, f8 = string.byte(src, s, s + 7)
		return rd_dbl_basic(f8, f7, f6, f5, f4, f3, f2, f1)
	end
	local float_types = {
		[4] = { little = rd_flt_le, big = rd_flt_be },
		[8] = { little = rd_dbl_le, big = rd_dbl_be },
	}
	local function stm_byte(S)
		local idx = S.index
		local bt = string.byte(S.source, idx, idx)
		S.index = idx + 1
		return bt
	end
	local function stm_string(S, len)
		local pos = S.index + len
		local str = string.sub(S.source, S.index, pos - 1)
		S.index = pos
		return str
	end
	local function stm_lstring(S)
		local len = S:s_szt()
		local str
		if len ~= 0 then
			str = string.sub(stm_string(S, len), 1, -2)
		end
		return str
	end
	local function cst_int_rdr(len, func)
		return function(S)
			local pos = S.index + len
			local int = func(S.source, S.index, pos)
			S.index = pos
			return int
		end
	end
	local function cst_flt_rdr(len, func)
		return function(S)
			local flt = func(S.source, S.index)
			S.index = S.index + len
			return flt
		end
	end
	local function stm_inst_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			local ins = S:s_ins()
			local op = bit32.band(ins, 0x3F)
			local args = OPCODE_T[op]
			local mode = OPCODE_M[op]
			local data = { value = ins, op = OPCODE_RM[op], A = bit32.band(bit32.rshift(ins, 6), 0xFF) }
			if args == "ABC" then
				data.B = bit32.band(bit32.rshift(ins, 23), 0x1FF)
				data.C = bit32.band(bit32.rshift(ins, 14), 0x1FF)
				data.is_KB = mode.b == "OpArgK" and data.B > 0xFF
				data.is_KC = mode.c == "OpArgK" and data.C > 0xFF
			elseif args == "ABx" then
				data.Bx = bit32.band(bit32.rshift(ins, 14), 0x3FFFF)
				data.is_K = mode.b == "OpArgK"
			elseif args == "AsBx" then
				data.sBx = bit32.band(bit32.rshift(ins, 14), 0x3FFFF) - 131071
			end
			list[i] = data
		end
		return list
	end
	local function stm_const_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			local tt = stm_byte(S)
			local k
			if tt == 1 then
				k = stm_byte(S) ~= 0
			elseif tt == 3 then
				k = S:s_num()
			elseif tt == 4 then
				k = stm_lstring(S)
			end
			list[i] = k
		end
		return list
	end
	local function stm_sub_list(S, src)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = stm_lua_func(S, src)
		end
		return list
	end
	local function stm_line_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = S:s_int()
		end
		return list
	end
	local function stm_loc_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = { varname = stm_lstring(S), startpc = S:s_int(), endpc = S:s_int() }
		end
		return list
	end
	local function stm_upval_list(S)
		local len = S:s_int()
		local list = table.create(len)
		for i = 1, len do
			list[i] = stm_lstring(S)
		end
		return list
	end
	function stm_lua_func(S, psrc)
		local proto = {}
		local src = stm_lstring(S) or psrc
		proto.source = src
		S:s_int()
		S:s_int()
		proto.num_upval = stm_byte(S)
		proto.num_param = stm_byte(S)
		stm_byte(S)
		proto.max_stack = stm_byte(S)
		proto.code = stm_inst_list(S)
		proto.const = stm_const_list(S)
		proto.subs = stm_sub_list(S, src)
		proto.lines = stm_line_list(S)
		stm_loc_list(S)
		stm_upval_list(S)
		for _, v in ipairs(proto.code) do
			if v.is_K then
				v.const = proto.const[v.Bx + 1]
			else
				if v.is_KB then
					v.const_B = proto.const[v.B - 0xFF]
				end
				if v.is_KC then
					v.const_C = proto.const[v.C - 0xFF]
				end
			end
		end
		return proto
	end
	local function lua_bc_to_state(src)
		local rdr_func
		local little
		local size_int
		local size_szt
		local size_ins
		local size_num
		local flag_int
		local stream = {
			index = 1,
			source = src,
		}
		assert(stm_string(stream, 4) == "\27Lua", "invalid Lua signature")
		assert(stm_byte(stream) == 0x51, "invalid Lua version")
		assert(stm_byte(stream) == 0, "invalid Lua format")
		little = stm_byte(stream) ~= 0
		size_int = stm_byte(stream)
		size_szt = stm_byte(stream)
		size_ins = stm_byte(stream)
		size_num = stm_byte(stream)
		flag_int = stm_byte(stream) ~= 0
		rdr_func = little and rd_int_le or rd_int_be
		stream.s_int = cst_int_rdr(size_int, rdr_func)
		stream.s_szt = cst_int_rdr(size_szt, rdr_func)
		stream.s_ins = cst_int_rdr(size_ins, rdr_func)
		if flag_int then
			stream.s_num = cst_int_rdr(size_num, rdr_func)
		elseif float_types[size_num] then
			stream.s_num = cst_flt_rdr(size_num, float_types[size_num][little and "little" or "big"])
		else
			error("unsupported float size")
		end
		return stm_lua_func(stream, "@virtual")
	end
	local function close_lua_upvalues(list, index)
		for i, uv in pairs(list) do
			if uv.index >= index then
				uv.value = uv.store[uv.index]
				uv.store = uv
				uv.index = "value"
				list[i] = nil
			end
		end
	end
	local function open_lua_upvalue(list, index, memory)
		local prev = list[index]
		if not prev then
			prev = { index = index, store = memory }
			list[index] = prev
		end
		return prev
	end
	local function on_lua_error(failed, err)
		local src = failed.source
		local line = failed.lines[failed.pc - 1]
		error(string.format("%s:%i: %s", src, line, err), 0)
	end
	local function run_lua_func(state, env, upvals)
		local code = state.code
		local subs = state.subs
		local vararg = state.vararg
		local top_index = -1
		local open_list = {}
		local memory = state.memory
		local pc = state.pc
		while true do
			local inst = code[pc]
			local op = inst.op
			pc = pc + 1
			if op < 18 then
				if op < 8 then
					if op < 3 then
						if op < 1 then
							for i = inst.A, inst.B do
								memory[i] = nil
							end
						elseif op > 1 then
							local uv = upvals[inst.B]
							memory[inst.A] = uv.store[uv.index]
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs + rhs
						end
					elseif op > 3 then
						if op < 6 then
							if op > 4 then
								local A = inst.A
								local B = inst.B
								local index
								if inst.is_KC then
									index = inst.const_C
								else
									index = memory[inst.C]
								end
								memory[A + 1] = memory[B]
								memory[A] = memory[B][index]
							else
								memory[inst.A] = env[inst.const]
							end
						elseif op > 6 then
							local index
							if inst.is_KC then
								index = inst.const_C
							else
								index = memory[inst.C]
							end
							memory[inst.A] = memory[inst.B][index]
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs - rhs
						end
					else
						memory[inst.A] = memory[inst.B]
					end
				elseif op > 8 then
					if op < 13 then
						if op < 10 then
							env[inst.const] = memory[inst.A]
						elseif op > 10 then
							if op < 12 then
								local A = inst.A
								local B = inst.B
								local C = inst.C
								local params
								if B == 0 then
									params = top_index - A
								else
									params = B - 1
								end
								local ret_list = table.pack(memory[A](table.unpack(memory, A + 1, A + params)))
								local ret_num = ret_list.n
								if C == 0 then
									top_index = A + ret_num - 1
								else
									ret_num = C - 1
								end
								table.move(ret_list, 1, ret_num, A, memory)
							else
								local uv = upvals[inst.B]
								uv.store[uv.index] = memory[inst.A]
							end
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs * rhs
						end
					elseif op > 13 then
						if op < 16 then
							if op > 14 then
								local A = inst.A
								local B = inst.B
								local params
								if B == 0 then
									params = top_index - A
								else
									params = B - 1
								end
								close_lua_upvalues(open_list, 0)
								return memory[A](table.unpack(memory, A + 1, A + params))
							else
								local index, value
								if inst.is_KB then
									index = inst.const_B
								else
									index = memory[inst.B]
								end
								if inst.is_KC then
									value = inst.const_C
								else
									value = memory[inst.C]
								end
								memory[inst.A][index] = value
							end
						elseif op > 16 then
							memory[inst.A] = {}
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs / rhs
						end
					else
						memory[inst.A] = inst.const
					end
				else
					local A = inst.A
					local step = memory[A + 2]
					local index = memory[A] + step
					local limit = memory[A + 1]
					local loops
					if step == math.abs(step) then
						loops = index <= limit
					else
						loops = index >= limit
					end
					if loops then
						memory[A] = index
						memory[A + 3] = index
						pc = pc + inst.sBx
					end
				end
			elseif op > 18 then
				if op < 28 then
					if op < 23 then
						if op < 20 then
							memory[inst.A] = #memory[inst.B]
						elseif op > 20 then
							if op < 22 then
								local A = inst.A
								local B = inst.B
								local len
								if B == 0 then
									len = top_index - A + 1
								else
									len = B - 1
								end
								close_lua_upvalues(open_list, 0)
								return table.unpack(memory, A, A + len - 1)
							else
								local B = inst.B
								local str = memory[B]
								for i = B + 1, inst.C do
									str = str .. memory[i]
								end
								memory[inst.A] = str
							end
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs % rhs
						end
					elseif op > 23 then
						if op < 26 then
							if op > 24 then
								close_lua_upvalues(open_list, inst.A)
							else
								local lhs, rhs
								if inst.is_KB then
									lhs = inst.const_B
								else
									lhs = memory[inst.B]
								end
								if inst.is_KC then
									rhs = inst.const_C
								else
									rhs = memory[inst.C]
								end
								if (lhs == rhs) == (inst.A ~= 0) then
									pc = pc + code[pc].sBx
								end
								pc = pc + 1
							end
						elseif op > 26 then
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							if (lhs < rhs) == (inst.A ~= 0) then
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						else
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							memory[inst.A] = lhs ^ rhs
						end
					else
						memory[inst.A] = inst.B ~= 0
						if inst.C ~= 0 then
							pc = pc + 1
						end
					end
				elseif op > 28 then
					if op < 33 then
						if op < 30 then
							local lhs, rhs
							if inst.is_KB then
								lhs = inst.const_B
							else
								lhs = memory[inst.B]
							end
							if inst.is_KC then
								rhs = inst.const_C
							else
								rhs = memory[inst.C]
							end
							if (lhs <= rhs) == (inst.A ~= 0) then
								pc = pc + code[pc].sBx
							end
							pc = pc + 1
						elseif op > 30 then
							if op < 32 then
								local sub = subs[inst.Bx + 1]
								local nups = sub.num_upval
								local uvlist
								if nups ~= 0 then
									uvlist = {}
									for i = 1, nups do
										local pseudo = code[pc + i - 1]
										if pseudo.op == OPCODE_RM[0] then
											uvlist[i - 1] = open_lua_upvalue(open_list, pseudo.B, memory)
										elseif pseudo.op == OPCODE_RM[4] then
											uvlist[i - 1] = upvals[pseudo.B]
										end
									end
									pc = pc + nups
								end
								memory[inst.A] = lua_wrap_state(sub, env, uvlist)
							else
								local A = inst.A
								local B = inst.B
								if (not memory[B]) ~= (inst.C ~= 0) then
									memory[A] = memory[B]
									pc = pc + code[pc].sBx
								end
								pc = pc + 1
							end
						else
							memory[inst.A] = -memory[inst.B]
						end
					elseif op > 33 then
						if op < 36 then
							if op > 34 then
								local A = inst.A
								local len = inst.B
								if len == 0 then
									len = vararg.len
									top_index = A + len - 1
								end
								table.move(vararg.list, 1, len, A, memory)
							else
								local A = inst.A
								local init, limit, step
								init = assert(tonumber(memory[A]), "`for` initial value must be a number")
								limit = assert(tonumber(memory[A + 1]), "`for` limit must be a number")
								step = assert(tonumber(memory[A + 2]), "`for` step must be a number")
								memory[A] = init - step
								memory[A + 1] = limit
								memory[A + 2] = step
								pc = pc + inst.sBx
							end
						elseif op > 36 then
							local A = inst.A
							local C = inst.C
							local len = inst.B
							local tab = memory[A]
							local offset
							if len == 0 then
								len = top_index - A
							end
							if C == 0 then
								C = inst[pc].value
								pc = pc + 1
							end
							offset = (C - 1) * FIELDS_PER_FLUSH
							table.move(memory, A + 1, A + len, offset + 1, tab)
						else
							memory[inst.A] = not memory[inst.B]
						end
					else
						if (not memory[inst.A]) ~= (inst.C ~= 0) then
							pc = pc + code[pc].sBx
						end
						pc = pc + 1
					end
				else
					local A = inst.A
					local base = A + 3
					local vals = { memory[A](memory[A + 1], memory[A + 2]) }
					table.move(vals, 1, inst.C, base, memory)
					if memory[base] ~= nil then
						memory[A + 2] = memory[base]
						pc = pc + code[pc].sBx
					end
					pc = pc + 1
				end
			else
				pc = pc + inst.sBx
			end
			state.pc = pc
		end
	end
	function lua_wrap_state(proto, env, upval)
		local function wrapped(...)
			local passed = table.pack(...)
			local memory = table.create(proto.max_stack)
			local vararg = { len = 0, list = {} }
			table.move(passed, 1, proto.num_param, 0, memory)
			if proto.num_param < passed.n then
				local start = proto.num_param + 1
				local len = passed.n - proto.num_param
				vararg.len = len
				table.move(passed, start, start + len - 1, 1, vararg.list)
			end
			local state = { vararg = vararg, memory = memory, code = proto.code, subs = proto.subs, pc = 1 }
			local result = table.pack(pcall(run_lua_func, state, env, upval))
			if result[1] then
				return table.unpack(result, 2, result.n)
			else
				local failed = { pc = state.pc, source = proto.source, lines = proto.lines }
				on_lua_error(failed, result[2])
				return
			end
		end
		return wrapped
	end
	createExecutable = function(bCode, env)
		return lua_wrap_state(lua_bc_to_state(bCode), env or getfenv(0))
	end
end
getfenv().script = nil

return setmetatable({},{__metatable={"Protected metatable"},__call=function(self,source)
	local executable
	for i,v in getfenv(2) do 
		getfenv(1)[i] = v
	end
	local env = getfenv(1)
	local name = (env.script and env.script:GetFullName())
	local ran, failureReason = pcall(function()
		local compiledBytecode = compile(source, name)
		executable = createExecutable(compiledBytecode, env)
	end)

	if ran then
		return setmetatable({},{__metatable="protected loadstring",__call=function(self,...)
			return setfenv(executable, env)(...)
		end})
	end
	return nil, failureReason
end,})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX9457E11F4F454BC19B0D68AE515D3523">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Loader</string>
					<string name="ScriptGuid">{2D3874E7-9CD9-48CA-8630-9043F3FED785}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}
players = {}
local err = error

local error = function(...)
	local args = table.pack(...)
	local whatmodule = args[1]
	table.remove(args,1)
	task.defer(err,`OwOLoader.{script.Parent.Name}.{script.Name}:{whatmodule}:: {table.unpack(args)}`) return 
end

function module:NFL_set(tab) 
	players = tab
end

function module:WaitForLoad(player:Instance,t:number) 
	local functionname = "WaitForLoad"
	if typeof(player) ~= "Instance" then 
		error(functionname,"Argument 1 (Player) is not a Instance") 
	elseif not player:IsA("Player") then 
		error(functionname,`Argument 1 (Player) should follow it className "Player" `) 
	end
	if typeof(t) ~= "number" then 
		error(functionname,"Argument 2 (T) is not a number") 
	end
	
	local t = t or 10
	local t2 = tick()
	repeat wait() until players[player] == "Ready" or t2+t < tick()
	
	if players[player] == "Ready" then
		wait(1)
		return true
	else
		warn(functionname,`Infinite yield possible`)
	end
end

function module:IsLoaded(player:Instance) 
	if players[player] == "Ready" then
		return true
	else
		return false
	end
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX13B330E5CD654558B40349651A3BC818">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">interop</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX780C5FEF653D415E81962FD7EA9305C3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ParametersConvert</string>
					<string name="ScriptGuid">{7F4264ED-935C-4141-8416-8DDC17D60150}</string>
					<ProtectedString name="Source"><![CDATA[local fenv = getfenv(1)

local parameters = {
	Vector3 = {"Vector3","Orientation","Size","JointOffset","RotVelocity"},
	CFrame = {"CFrame","PivotOffset"},
	Color3 = {"Color3","Color3uint8","Color"}
}
local wrongparameters = {
	size = "Size",
	Color3uint8 = "Color",
	EmitterSize = "RollOffMinDistance",
	XmlRead_MaxDistance_3 = "RollOffMaxDistance"
}
local Enumumerators = {
	RunContext = { [0] = "Legacy", [1] = "Server", [2] = "Client"}
	
}
return function(parameter,set)

	if wrongparameters[parameter] then
		parameter =  wrongparameters[parameter]
	end
	
	for i,v in parameters do 
		if table.find(v,parameter) then
			if typeof(set) ~= "table" then
				set = fenv[i]["new"](set)
			else
				set = fenv[i]["new"](unpack(set))
			end
			
			break
		end
	end
	
	
	return parameter,set
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5E29559FA7D944A08CE9EC58EA84BB26">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ApiDump</string>
					<string name="ScriptGuid">{BD10B1FF-9B70-4A93-97AD-7578206256DE}</string>
					<ProtectedString name="Source"><![CDATA[local classProperties = {}
local isnull = function(t)
	for i, v in t do
		return false
	end
	return true
end


return function()
	print("ApiDump is running")
	local apiSuccess, apiDump = pcall(
		game:GetService("HttpService").GetAsync,
		game:GetService("HttpService"),
		"https://raw.githubusercontent.com/MaximumADHD/Roblox-Client-Tracker/roblox/API-Dump.json"
	)
	if not apiSuccess then
		game:GetService("Players").PlayerAdded:Connect(function(plr) plr:Kick(`Sorry but OWO Loader cant get API-Dump bc of {apiDump}`) end)
		for i,v in game:GetService("Players"):GetPlayers() do 
			v:Kick(`Sorry but OWO Loader cant get API-Dump bc of {apiDump}`)
		end
		return
	end

	local classNames = {}

	for _, class in game:GetService("HttpService"):JSONDecode(apiDump).Classes do
		classNames[class.Name] = class
	end

	local function indexClass(class, name)
		for _, member in class.Members do
			if member.MemberType == "Property" and member.Security.Read == "None" and (not member.Tags or (not table.find(member.Tags, "NotScriptable") and not table.find(member.Tags, "ReadOnly"))) and member.Name ~= "Parent" then
				print(classProperties[name],name, member.Name)
				table.insert(classProperties[name], member.Name)
			end
		end
		if class.Superclass ~= "<<<ROOT>>>" then
			indexClass(classNames[class.Superclass], name)
		end
	end

	local function checker(class)
		local parameters = {}
		for _, member in class.Members do
			if member.MemberType == "Property" and member.Security.Read == "None" and (not member.Tags or (not table.find(member.Tags, "NotScriptable") and not table.find(member.Tags, "ReadOnly"))) and member.Name ~= "Parent"  then
				table.insert(parameters,member.Name)
			end
		end
		if class.Superclass ~= "<<<ROOT>>>" then
			checker(classNames[class.Superclass])
		end

		if isnull(parameters) then parameters = nil end
		return parameters
	end


	for name, class in classNames do
		if (class.Tags and table.find(class.Tags, "NotCreatable")) then continue end
		local parameters = checker(class)
		if parameters then
			classProperties[class.Name] = parameters
		end
	end


	print("ApiDumper done with work")
	return classProperties
end
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX0C7342A6205144ECB9E5BCA0C2C883F9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalStorage</string>
					<string name="ScriptGuid">{5B5F3D7A-BE20-40F4-91EB-B1FD712BAE11}</string>
					<ProtectedString name="Source"><![CDATA[local err = error
local error = function(...)
	local args = table.pack(...)
	task.defer(err,`OwOLoader: {table.unpack(args)}`) return 
end
function size(a)
	if typeof(a) == "string" then
		a = a:len()
	end
	local b = "Byte"
	
	if a>1024 then
		a = a/1024
		b = "KB" 
	end
	if a>1024 then
		a = a/1024
		b = "MB" 
	end
	if a>1024 then
		a = a/1024
		b = "GB" 
	end
	return tostring(math.round(a))+b
end

local LuaSourceContainer = {}
local Module = {}
function Module:Import(id,source,scripttype)
	if source[id] then
		error("Sorry but this id already in list its just error and im will fix that soon (i think) ")
		return	
	end	
	warn(`Size of script source {size(source)}`)
	LuaSourceContainer[id] = {scripttype,source}
	local c=0
	for i,v in LuaSourceContainer do 
		c+= v:len()
	end
	warn(`Size of LocalLuaSourceContainer {size(c)}`)
end
function Module:Export()
	return LuaSourceContainer
end
return Module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>